<h1 align = "center">邪童 の 算法笔记</h1>

<br>

### 戒骄戒躁, 努力沉淀       ICPC冲冲冲!!!

```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <bits/stdc++.h>

#define x first
#define y second
#define endl '\n'

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
typedef pair<int,string> PIS;
typedef pair<char,string> PCS;
typedef pair<double,double> PDD;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cout << "xt love ac" << endl;
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 目录



## 基础语法

#### 基础语法

> + 基本输入输出
> + 循环语句
>   + 曼哈顿距离
> + 数组
>   + 数组操作常用函数
>   + 偏移量技巧
> + 字符串
>   + 字符串的输入输出
>   + 字符串常用操作
> + 类、结构体、指针和引用
> + STL容器
>   + vector
>   + queue / priority_queue
>   + stack
>   + deque
>   + set / multiset
>   + map
>   + unordered_set / unordered_multiset / unordered_map
>   + bitset
>   + pair
> + 位运算
> + 常用库函数



___

## 基础算法

#### 基础算法

> + 排序算法
>   + 快速排序
>   + 归并排序
> + 二分算法
>   + 整数二分
>   + 浮点数二分
> + 高精度运算
>   + 高精度加法
>   + 高精度减法
>   + 高精度乘法
>   + 高精度除以低精度
> + 前缀和与差分
>   + 前缀和
>     + 一维前缀和
>     + 二维前缀和
>   + 差分
>     + 一维差分
>     + 二维差分
> + 离散化

#### 数据结构

>+ 数组模拟实现数据结构
>   + 数组模拟链表实现
>     + 单链表
>     + 双链表
>
>   + 数组模拟栈实现
>
>   + 数组模拟队列实现
>
>   + 数组模拟堆实现
>
>+ KMP算法
>+ Trie树
>+ 并查集
>   + 普通并查集
>   + 维护size的并查集
>   + 维护到祖宗节点距离的并查集
>
>+ 哈希表
>   + 一般哈希
>     + 拉链法
>     + 开放寻址法
>
>   + 字符串哈希
>
>+ C++ STL容器
>   + vector
>   + pair
>   + string
>   + queue
>   + priority_queue
>   + stack
>   + deque
>   + set / multiset
>   + map / multimap
>   + unordered_set / unordered_map / unordered_multiset / unordered_multimap
>   + bitset
>

#### 搜索与图论

> + 图论基础
>   + 深度优先遍历(DFS)
>   + 宽度优先遍历(BFS)
>   + 树与图的存储
>   + 树与图的深度优先遍历
>   + 树与图的宽度优先遍历
>   + 拓扑排序
> + 最短路
>   + 单源最短路
>     + 朴素Dijkstra算法
>     + 堆优化版Dijkstra算法
>     + Bellman - Ford算法
>     + SPFA算法
>   + 多源汇最短路
>     + Floyd算法
> + 最小生成树
>   + Prim算法
>   + Kruskal算法
> + 二分图
>   + 染色法
>   + 匈牙利算法

#### 数学知识

> + 数论
>   + 质数
>     + 试除法判定质数
>     + 试除法分解质因数
>     + 朴素筛法求素数
>     + 线性筛法求素数
>   + 约数
>     + 试除法求所有约数
>     + 求约数个数
>     + 求约数之和
>     + 欧几里得算法
>   + 欧拉函数
>     + 公式求欧拉函数
>     + 筛法求欧拉函数
>   + 快速幂
>   + 扩展欧几里得算法
> + 高斯消元
> + 组合计数
>   + 递推法求组合数
>   + 预处理逆元求组合数
>   + Lucas定理
>   + 分解质因数法求组合数
>   + 卡特兰数
> + 简单博弈论
>   + 容斥原理
>   + NIM游戏
>   + 公平组合游戏ICG
>   + 有向图游戏
>   + Mex运算
>   + SG函数
>   + 有向图游戏的和

#### 动态规划

> + 背包问题
>   + 01背包问题
>   + 完全背包问题
>   + 多重背包问题
>   + 混合背包问题
>   + 二维费用的背包问题
>   + 分组背包问题
>   + 树上背包问题
>   + 背包问题求方案数
>   + 背包问题求具体方案
> + 常见dp问题
>   + 基础线性dp
>   + 基础区间dp
>   + 计数类dp
>   + 数位统计dp
>   + 状态压缩dp
>   + 树形dp
> + 记忆化搜索



---

## 提高算法

#### 动态规划

> + 数字三角形模型
> + 最长上升子序列模型
> + 背包模型
> + 状态机模型
> + 状态压缩DP
> + 区间DP
> + 树形DP
> + 数位DP
> + 单调队列优化DP
> + 斜率优化DP

#### 搜索

> + BFS
>   + Flood Fill
>   + 最短路模型
>   + 多源BFS
>   + 最小步数模型
>   + 双端队列广搜
>   + 双向广搜
>   + A\*
> + DFS
>   + 连通性模型
>   + 搜索顺序
>   + 剪枝与优化
>   + 迭代加深
>   + 双向DFS
>   + IDA\*

#### 图论

> + 差分约束
> + 最近公共祖先
> + 有向图的强连通分量
> + 无向图的双连通分量
> + 欧拉回路和欧拉路径

#### 高级数据结构 

> + 并查集
> + 树状数组
> + 线段树
> + 可持久化数据结构
>   + 可持久化 Trie
>   + 可持久化线段树
> + 平衡树 —— Treap
> + AC自动机

#### 数学知识

> + 同余 - 中国剩余定理
> + 矩阵乘法

#### 基础算法

> + 位运算 - 龟速乘



___

## 进阶算法

#### 图论

> + 网络流的基本概念
> + 最大流之算法模板
> + 最大流之二分图匹配
> + 最大流之上下界可行流
> + 最大流之多源汇最大流
> + 最大流之关键边
> + 最大流之最大流判定
> + 最大流之拆点
> + 最小割之算法模板
> + 最小割之最大权闭合图
> + 最小割之最大密度子图
> + 最小割之最小点权覆盖集
> + 最小割之最大点权独立集
> + 最小割之建图实战
> + 费用流之算法模板
> + 费用流之直接应用
> + 费用流之二分图最优匹配
> + 费用流之最大权不相交路径
> + 费用流之网格图模型
> + 费用流之拆点
> + 2 - SAT
> + 朱刘算法

#### 数据结构

> + Splay
> + 树套树
> + 莫队
>   + 莫队之基础莫队
>   + 莫队之带修改的莫队
>   + 莫队之回滚莫队
>   + 莫队之树上莫队
>   + 莫队之二次离线莫队
> + 树链剖分
> + 动态树
> + Dancing Links
> + 左偏树
> + 后缀数组
> + 后缀自动机
> + 点分治
> + CDQ 分治

#### 动态规划

> + 基环树DP

#### 计算几何

> + 二维计算几何基础
> + 凸包
> + 半平面交
> + 最小圆覆盖
> + 三维计算几何基础
> + 三维凸包
> + 旋转卡壳
> + 扫描线
> + 自适应辛普森积分

#### 搜索

>+ 模拟退火

#### 基础算法

> + 启发式合并
> + manacher算法
> + 最小表示法
> + 打表



---

## 杂谈

#### 最短路问题路径保存

#### 数据读入

#### 算法竞赛文件读写

#### 求逆元的四种方法

#### 扩展欧几里得求解不定方程

#### 三分

#### __int 128 输入输出模板

#### 求解斐波那契数列的若干方法

#### 动态规划专题

#### 交互题专题

#### 对拍器

#### 算法竞赛及OJ题面常用英文单词整理



---



<div style="page-break-after:always;"></div>

# C++ 基础语法

### 基本输入输出

```c++
#include<iostream>

using namespace std;

int main()
{
    cout<<"xt love ac"<<endl;
    return 0;
}
```



> 头文件
>
> `#include <cstdio>` 包含 `printf` (输出)， `scanf` (输入)
>
> `#include <iostream>` 包含 `cin` (读入), `cout` (输出)
>
> `using namespace std` 使用 `std` 命名空间

> 万能头文件 `#include <bits/stdc++.h>` 

```c++
//关闭同步流
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
```



>变量类型
>
>布尔型 `bool` , 字符型 `char`
>
>整型 `int` , 浮点型 `float` , 双精度浮点型 `double`

> `char` 类型和整型做运算, 会转化为整型. 若想输出 `char` 类型, 需要强制类型转换
>
> `char c = 'A'` , `cout << (char)(c+32) << endl`





---

### 循环语句

[打印菱形](https://www.acwing.com/problem/content/729/) : 输入一个奇数 `n` , 输出一个由 `*` 构成的n阶实心菱形

> 曼哈顿距离
>
> 点 `(x1,y1)` 与点 `(x2,y2)` 之间的曼哈顿距离
>
> `c` = `|x1 - x2|` + `|y1 - y2|`

```c++
//打印n阶实心菱形

cin>>n;
int cx=n/2,cy=n/2;
for(int i=0;i<n;i++)
{
    for(int j=0;j<n;j++)
        if(abs(i-cx)+abs(j-cy)<=n/2)cout<<'*';
		else cout<<' ';
    cout<<'\n';
}
```





---

### 数组

> 数组操作常用函数:
>
> 翻转数组函数 `reverse(a,a+n)` , 第一个参数表示翻转的数组的起始位置, 第二个参数表示翻转的数组的末位置的下一个位置
>
> 初始化数组函数 `memset(a,0,sizeof a)` , 第一个参数表示初始化起点, 第二个参数表示初始化数组(只有0和-1是原值), 第三个参数表示初始化长度
>
> 复制数组函数 `memcpy(b,a,sizeof a)` , 第一个参数表示目标数组, 第二个参数表示待复制数组, 第三个参数表示复制长度



打印[蛇形矩阵](https://www.acwing.com/problem/content/758/)

> 偏移量技巧
>
> `dx[4] = {0,1,0,-1}` , `dy[4] = {1,0,-1,0}`

```c++
//打印蛇形矩阵

int res[100][100];
int main()
{
    int n,m;
    cin>>n>>m;
    
    int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
    
    for(int x=0,y=0,d=0,k=1;k<=n*m;k++)
    {
        res[x][y]=k;
        int a=x+dx[d],b=y+dy[d];
        if(a<0||a>=n||b<0||b>=m||res[a][b])
        {
            d=(d+1)%4;
            a=x+dx[d],b=y+dy[d];
        }
        x=a,y=b;
    }
    
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
            cout<<res[i][j]<<' ';
        cout<<'\n';
    }
    
    return 0;
}
```





---

### 字符串

> 字符串的输入输出: 
>
> `cin` 读取到 `空格` , `回车` 即停止读入
>
> 读入带 `空格` 的字符串:
>
> `fgets(a,100,stdin)`
>
> `getline(cin,a)`
>
> `printf` 输出字符串:
>
> `printf("%s",a.c_str)`



> `string` 初始化:
>
> `string s1`  , 默认初始化, `s1` 是一个空字符串
>
> `string s2 = s1` , `s2` 是 `s1` 的副本, 注意 `s2` 只是与 `s1` 的值相同, 并不指向同一地址
>
> `string s3 = "xietong"` , `s3` 是该字符串字面量的副本
>
> `string s4 = (10,'c')` , `s4` 的内容是 `cccccccccc`



> 字符串常用操作: 
>
> 求字符串长度 `strlen(str)` (不含空字符)
>
> 比较两个字符串的大小 `strcmp(a,b)` (`a<b` 返回 `-1` , `a==b` 返回 `0` , `a>b` 返回 `1` )
>
> 将字符串 `b` 复制给从 `a` 开始的字符串 `strcpy(a,b)`
>
> 下标遍历字符串 `for(int i = 0, len = strlen(str); i < len ; i++ )`
>
> 范围遍历字符串(不能改变字符串内容) `for(char c : s)`
>
> 范围遍历并改变字符串中的内容 `for(char &c : s)`





---

### 类、结构体、指针和引用

> 类:$\quad$ 关键字  `class` 
>
> 类里面有两个关键字 `private` 和 `public`
>
> `private` 后面的内容是私有成员变量, 在类的外部不能访问
>
> `public` 后面的内容是公有成员变量, 在类的外部可以访问

> 结构体: $\quad$ 关键字 `struct`

> 区别: 对于没有声明 `private` / `public` 的成员变量
>
> 类 `class` 默认为 `private` , 结构体 `struct` 默认为 `public` 



> 定义指针:
>
> `int a = 10` 
>
> `int *p = &a` , `p` 是 `int` 类型变量的指针, 定义 `p` 为 `a` 的地址
>
> `int *` 看作一个类型——指针
>
> 改变地址内变量的值: `*p = 12`

> 数组名是一种特殊的指针, 指针可以做运算
>
> `int a[5] = {1,2,3,4,5}` , `cout << a << endl`
>
> 输出的是 `数组a` 的地址, 也是 `a[0]` 的地址



> 引用: `int &p = a`
>
> 定义 `p` 和 `a` 相同地址, `p` 和 `a` 共用相同的地址和值



> 调用成员变量:
>
> 调用的变量是一个变量: 
>
> `Node a = Node(1)`
>
> `a.next` , `a.val`
>
> 调用的变量是一个指针:
>
> `Node *p = new Node(1)`
>
> `p->next = p` , `p->val`



> 链表

```c++
struct Node
{
    int val;
    Node* next;
};
```

`Node *p = new Node(1)` 返回值是地址

`Node p = Node(1)` 返回值是值

```c++
struct Node
{
    int val;
    Node* next;
    Node(int_val):val(_val),next(NULL){}
}

int main()
{
    auto p = new Node(1);
    auto q = new Node(2);
    auto o = new Node(3);
    
    p->next = q;
    q->next = o;
    
    return 0;
}
```

```c++
//通常将头节点的地址存储到head变量中
Node* head = p;
```

```c++
//遍历链表
for(Node* i=head;i;i=i->next)
{
    cout << i->val << endl;
}
```

```c++
//创建新节点
Node* u = new Node(4);
u->next = head;
head = u;
```

```c++
//删除节点
head->next = head->next->next;
```





---

### STL容器

> `vector` , `#include <vector>`
>
> `vector` 是一个变长数组

```c++
int main()
{
    vector<int> a;	//相当于一个长度动态变化的int数组
    vector<int> b[233];		//相当于第一维长233,第二维长度动态变化的int数组
    
    a.size();		//返回元素个数
    a.empty();		//若a为空返回true,否则返回false
    a.clear();		//清空数组a
    
    struct ret{...};
    vector<ret> c;		//结构体类型也可以保存在vector中
}
```

> 迭代器, 类似于指针
>
> 定义迭代器 `vector<int>::iterator it =a.begin()`, 定义 `a` 的迭代器
>
> 取值: `*it` , 取地址: `it` 
>
> `a.begin()` 返回 `a` 的第一个元素的地址
>
> `a.end()` 返回 `a` 的最后一个元素的下一个位置的地址

```c++
//遍历vector
vector<int> a ({1,2,3});
for(int i=0;i<a.size();i++)cout<<a[i]<<' ';
for(auto it=a.begin();it!=a.end();it++)
    cout<<*it<<' ';
```

```c++
a.front()		//返回a的第一个元素
a.back()		//返回a的最后一个元素
a.push_back(x)		//把元素x插入到a的尾部
a.pop_back()		//删除a的最后一个元素
```



> `queue` , `#include <queue>`
>
> `priority_queue` , `#include <queue>`

> `queue` 循环队列: 优先弹出先进入的元素(先进先出)
>
> `priority_queue` 优先队列: 大根堆优先弹出最大的元素, 小根堆优先弹出最小的元素

```c++
queue<int> a;		//循环队列
struct rec{...};priority_queue<rec>a;	//结构体中必须定义小于号
priority_queue<int> a;		//大根堆
priority_queue<int,vector<int>,greater<int>>a;		//小根堆
```

```c++
//在结构体rec中定义小于号
struct rec
{
    int a,b;
    bool operator<(const rec &t)const
    {
        return a<t,a;
    }
};
//大根堆要重载小于号,小根堆要重载大于号
```

```c++
//循环队列 queue
queue<int> q;
q.push(x)		//在队尾插入元素x
q.pop()			//弹出队头元素
q.front()		//返回队头元素
q.back()		//返回队尾元素
```

```c++
//优先队列 priority_queue
priority_queue<int> q;	//大根堆
q.push(x)		//插入元素x
q.top()			//返回最大值
q.pop()			//删除最大值
```

> **队列、优先队列、栈没有 `clear` 函数**



> 栈 `stack` , `#include <stack>`
>
> 栈: 后进先出

```c++
stack<int> q;
q.push(x)		//插入一个元素x
q.top()			//返回栈顶元素(输入的最后一个元素)
q.pop()			//弹出栈顶元素
```



> 双端队列 `deque` , `#include <deque>`

```c++
deque<int> a;
a.begin(),a.end()		//返回队头/队尾的迭代器
a.front(),a.back()		//返回队头/队尾元素
a.push_back(x)		//从队尾入队
a.push_front(x)		//从队头入队
a.pop_back()		//删除队尾元素
a.pop_front()		//删除队头元素
a.clear()		//清空队列
a[0]			//双端队列支持随机访址
```



> `set` , `#include <set>`
>
> `multiset` , `#include <set>`

> `set<int> s` 元素不能重复, 会自动删掉重复元素
>
> `multiset<int> s` 元素可以重复

> 结构体定义为`set` , 要重载小于号

> 设 `it` 是 `set` 的一个迭代器, `set<int>::iterator it`
>
> `it++` 会指向 `it` 下一个元素, `it--` 会指向 `it` 上一个元素(元素从小到大排序)

```c++
a.begin(),a.end()		//返回队头/队尾的迭代器
a.insert(x)			//插入一个元素x
a.find(x)			//若查找到元素x,返回x的迭代器,否则返回a.end()
if(a.find(x)==a.end())		//判断x在a中是否存在
a.lower_bound(x)		//返回大于等于x的最小元素的迭代器
a.upper_bound(x)		//返回大于x的最小元素的迭代器
a.erase(x)			//删掉x的所有迭代器
a.erase(it)			//删掉迭代器it
a.count(x)			//返回a中x的个数
```



> `map` , `#include <map>`
>
> `map` 是映射, 存储数对(有序,按第一个参数从小到大排序)

```c++
map<int,int> a;
a[1]=2;
a[7]=96;
cout<<a[1]<<endl;	//输出2

a.insert({,})		//插入
a.find(第一个参数)		//返回第二个参数的迭代器
a[第一个参数]			//返回第二个参数的值
//可通过"a[]= "来修改第二个参数的值
```



> `unordered_set` , `#include <unordered_set>`
>
> 无序的 `set` , 元素不能重复
>
> 除不含 `lower_bound` 和 `upper_bound` 外, 其余函数同 `set`

> `unordered_multiset` , `#include <unordered_set>`
>
> 无序的 `multiset` , 元素可以重复
>
> 除不含 `lower_bound` 和 `upper_bound` 外, 其余函数同 `multiset`

> `unordered_map` , `#include <unordered_map>`
>
> 无序的 `map`



> `bitset` , `#include <bitset>` , `01串`

```c++
bitset<1000>a;		//定义长度为1000的01串
a[0]=1;			//没有定义的默认为0
a.count()		//返回a中1的个数
a.set(i)		//把第i位设为1
a.reset(i)		//把第i位设为0
```



> `pair` , `#include <utility>`

```c++
pair<int,int> a,b;
a = make_pair(,)	//赋值
cout << a.first << ' ' << a.second << endl;		//输出
```

> `pair` 可比较, `if(a==b)` / `if(a>b)` / `if(a<b)`
>
> 先比较 `first` 参数, 后比较 `second` 参数





---

### 位运算

|  位运算   |             |                 |                  |                         |
| :-------: | :---------: | :-------------: | :--------------: | :---------------------: |
|  `与 &`   | `0 & 0 = 0` |   `0 & 1 = 0`   |   `1 & 0 = 0`    |       `1 & 1 = 1`       |
|  `或 |`   | `0 | 0 = 0` |   `0 | 1 = 1`   |   `1 | 0 = 1`    |       `1 | 1 = 1`       |
| `取反 ~`  |  `~ 0 = 1`  |    `~ 1 = 0`    |                  |                         |
| `异或 ^`  | `0 ^ 0 = 0` |   `0 ^ 1 = 1`   |   `1 ^ 0 = 1`    |       `1 ^ 1 = 0`       |
| `右移 >>` | `a = 11011` | `a>>1` = `1101` | `a右移k次, a>>k` | 等价于 $\dfrac{a}{2^k}$ |
| `左移 <<` |  `a = 110`  | `a<<1` = `1100` | `a左移k次, a<<k` |   等价于 $a\cdot2^k$    |

> 求 `x` 的第 `k` 位数字: `x>>k&1`
>
> 返回 `x` 的最后一位 `1` : `x&-x`





---

### 常用库函数

> `reverse` 翻转

```c++
vector<int> a({1,2,3,4,5});
reverse(a.begin(),a.end());

int a[]={1,2,3,4,5};
reverse(a,a+5);

//reverse第一个参数为起始指针,第二个参数为末位下一位指针
```



> `unique` 去重

```c++
//unique返回值为新数组的end()

//求不同元素的个数
int m=unique(a.begin(),a.end())-a.begin();
int m=unique(a,a+n)-a;

//排序并删除多余元素
a.erase(unique(a.begin(),a.end()),a.end());
//a.erase(l,r)    删除[l,r)内元素
```



> `random_shuffle` 随机打乱

```c++
random_shuffle(a.begin(),a.end());
```

```c++
#include<ctime>
srand(time(0));	//返回到1970年1月1日的秒数
//生成随机种子
```



> `sort` 排序

```c++
sort(a.begin(),a.end());	//按从小到大排序
sort(a.begin(),a.end(),greater<int>());		//按从大到小排序

bool cmp (int a,int b)	//a是否应该排在b前面
{
    return a>b;
}
sort(a.begin(),a.end(),cmp);

//结构体排序:
//1.传入第三个参数(定义比较方案的函数)
//2.在结构体内重载比较方法
struct Rec
{
    int x,y;
}a[5];
sort(a,a+5,cmp);

struct Rec
{
    int x,y;
    bool operator<(const Rec &t)const
    {
        return x<t.x;
    }
}a[5];
sort(a,a+5);
```



> `lower_bound` / `upper_bound` 二分
>
> `lower_bound` 返回大于等于 `x` 的第一个元素的迭代器
>
> `upper_bound` 返回大于 `x` 的第一个元素的迭代器
>
> 前提: 区间内有序(从小到大排序)

```c++
int a[]={1,2,4,5,6};
int *p=lower_bound(a,a+5,4);
cout<<*p<<endl;

int t=lower_bound(a,a+5,4)-a;
cout<<a[t]<<endl;

vector<int> a({1,2,4,5,6});
int t=lower_bound(a.begin(),a.end(),4)-a.begin();
cout<<a[t]<<endl;
```



<div style="page-break-after:always;"></div>

# 排序算法

#### 快速排序

```c++
//快速排序算法模板

void quick_sort (int q[],int l,int r)
{
    if(l>=r)return;
    
    int i=l-1,j=r+1,x=q[l];	//x=q[r]
    while(i<j)
    {
        do i++; while(q[i]<x);
        do j--; while(q[j]>x);
        if(i<j)swap(q[i],q[j]);
        else break;
    }
    quick_sort(q,l,j),quick_sort(q,j+1,r);
    //quick_sort(q,l,i-1),quick_sort(q,i,r);
}
```

```
注意边界问题!!!
当x取q[l]时,递归不能用左指针i
当x取q[r]时,递归不能用右指针j
```





---

#### 归并排序

```c++
//归并排序模板

void merge_sort (int q[],int l,int r)
{
    if(l>=r)return;
    
    int mid=(l+r)/2;
    merge_sort(q,l,mid);
    merge_sort(q,mid+1,r);
    
    int k=0,i=l,j=mid+1;
    while(i<=mid&&j<=r)
        if(q[i]<q[j])tmp[k++]=q[i++];
    	else tmp[k++]=q[j++];
    while(i<=mid)tmp[k++]=q[i++];
    while(j<=r)tmp[k++]=q[j++];
    
    for(int i=l,j=0;i<=r;i++,j++)q[i]=tmp[j];
}
```



<div style="page-break-after:always;"></div>

# 二分算法

### 整数二分

> 二分与单调性的关系: 如果有单调性, 一定可以二分; 可以二分的题目, 不一定非得有单调性

> 二分的本质: 边界
>
> 在区间上定义了某种性质, 该性质在区间右半边满足, 左半边不满足, 使整个区间一分为二
>
> 二分可以寻找性质的边界(既可以寻找边界 `i` , 也可以寻找边界 `j` )

<img src="E:\个人博客\博客内容\算法竞赛\基础算法\基础算法\整数二分.png" width = "50%">



> ① 寻找边界 `i` :$\quad$ $\quad$  `mid = (l+r+1)/2`
> $$
> if(check(mid))
> \begin{cases}
> true \quad [mid,r]:l=mid\\[2ex]
> false \quad [l,mid-1]:r=mid-1\\[2ex]
> \end{cases}
> $$

> ② 寻找边界 `j` : $\quad$ $\quad$ `mid = (l+r)/2`
> $$
> if(check(mid))
> \begin{cases}
> true \quad [l,mid]:r=mid\\[2ex]
> false \quad [mid+1,r]:l=mid+1\\[2ex]
> \end{cases}
> $$

> 对 `true` : 更新左边界, 定义 `mid` 要上取整; 更新右边界, 定义 `mid` 要下取整, 防止陷入死循环



```c++
//整数二分算法模板1(寻找边界i)

int bsearch_1 (int l,int r)
{
    while(l<r)
    {
        int mid=(l+r+1)/2;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    return l;
}
```



```c++
//整数二分算法模板2(寻找边界j)

int bsearch_2 (int l,int r)
{
    while(l<r)
    {
        int mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    return l;
}
```





---

### 浮点数二分

> 因为浮点数没有整除, 所以不需要处理边界
>
> 需要时刻保证答案在区间内部
>
> 当区间长度很小的时候, 可以认为找到答案



```c++
//浮点数二分算法模板

double bsearch_3 (double l,double r)
{
    const double eps=1e-6;	
    //eps表示精度,取决于题目对精度的要求(一般取题目要求保留小数点后位数+2)
    
    while(r-l>eps)
    {
        double mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    return l;
}
```



<div style="page-break-after:always;"></div>

# 高精度运算

> C++ 存储大整数:
>
> 将大整数的每一位存储到数组中, 用 `vector` 存(自带 `size` 函数)
>
> 从低位开始存——方便进位
>
> (即将个位数存储在 `A[0]` , 十位数存储在 `A[1]` )



___

### 高精度加法

````c++
//高精度加法模板
//C = A + B ,A >= 0 ,B >= 0

vector<int> add (vector<int> &A,vector<int> &B)
{
    vector<int> C;
    int t=0;	//进位
    for(int i=0;i<A.size()||i<B.size();i++)
    {
        if(i<A.size())t+=A[i];
        if(i<B.size())t+=B[i];
        C.push_back(t%10);
        t/=10;
    }
    
    if(t)C.push_back(1);
    return C;
}

int main()
{
    string a,b;
    vector<int> A,B;
    
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    
    vector<int> C=add(A,B);
    
    for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
    return 0;
}
````





---

### 高精度减法

```c++
//高精度减法模板
//C = A - B ,A >= B ,A >= 0 ,B >= 0

vector<int> sub (vector<int> &A,vector<int> &B)
{
    vector<int> C;
    
    int t=0;	//借位
    for(int i=0;i<A.size();i++)
    {
        t=A[i]-t;
        if(i<B.size())t-=B[i];
        C.push_back((t+10)%10);
        if(t<0)t=1;
        else t=0;
    }
    
    while(C.size()>1&&C.back()==0)C.pop_back();	//删除前导0
    return C;
}

//判断是否有A>=B
bool cmp (vector<int> &A,vector<int> &B)
{
    if(A.size()!=B.size())return A.size()>B.size();
    for(int i=A.size()-1;i>=0;i--)
        if(A[i]!=B[i])return A[i]>B[i];
    return true;
}

int main()
{
    string a,b;
    vector<int> A,B;
    
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    
    if(cmp(A,B))	//判断是否满足A>=B
    {
        vector<int> C=sub(A,B);	//若A>=B,输出C=(A-B)
        for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
    }
    else
    {
        vector<int> C=sub(B,A);	//若A<B,输出C=-(B-A)
        printf("-");
        for(int i=C.size();i>=0;i--)printf("%d",C[i]);
    }
    return 0;
}
```





---

### 高精度乘法

```c++
//高精度乘低精度模板   C = A * b
//把b看作整体一起乘

vector<int> mul (vector<int> &A,int b)
{
    vector<int> C;
    
    int t=0;	//进位
    for(int i=0;i<A.size()||t;i++)
    {
        if(i<A.size())t+=A[i]*b;
        C.push_back(t%10);
        t/=10;
    }
    
    return C;
}

int main()
{
    string a;
    int b;
    
    cin>>a>>b;
    
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    
    vector<int> C=mul(A,b);
    for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
    
    return 0;
}
```





---

### 高精度除以低精度

```c++
//高精度除以低精度模板
//除法从最高位开始算
//商C = A / b , 余数r = A % b

vector<int> div (vector<int> &A,int &r)
{
    vector<int> C;
    
    r=0;	//余数
    for(int i=A.size()-1;i>=0;i--)
    {
        r=r*10+A[i];
        C.push_back(r/b);
        r%=b;
    }
    
    reverse(C.begin(),C.end());	//按统一形式存储
    while(C.size()>1&&C.back()==0)C.pop_back();	//删除前导0
    
    return C;
}

int main()
{
    string a;
    int b;
    
    cin>>a>>b;
    
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    
    int r;	//余数
    vector<int> C=div(A,b,r);
    
    for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
    cout<<'\n'<<r<<'\n';
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 前缀和与差分

### 前缀和

> 原数组: `a1` , `a2` , `a3` , $\cdots$ , `an`
>
> 前缀和数组: `si` = `a1` + `a2` + $\cdots$ + `ai` , `s0 = 0`

> ① 如何求前缀和数组 `Si` : `Si` = `Si-1` + `ai` , `s0 = 0`
>
> ② 前缀和数组的作用: 快速地求出原数组中一段数的和



##### 一维前缀和

> `S[i]` = `S[i-1]` + `a[i]` = `a[1]` + `a[2]` + $\cdots$ + `a[i]`
>
> `a[l]` + $\cdots$ + `a[r]` = `S[r]` - `S[l-1]` 



##### 二维前缀和

> `S[i,j]` 表示 `a[i,j]` 左上角全部元素的和
>
> `S[i,j]` = `a[i,j]` + `S[i-1,j]` + `S[i,j-1]` - `S[i-1,j-1]`

> 二位前缀和的作用: 快速求出矩阵数组中子矩阵的和
>
> `a[x1,y1]` (左上角) 到 `a[x2,y2]` (右下角) 的矩阵的元素之和为:
>
> `S[x2,y2]` - `S[x2,y1-1]` - `S[x1-1,y2]` + `S[x1-1,y1-1]`





---

### 差分

> 差分, 即前缀和的逆运算
>
> 原数组: `a1` , `a2` , `a3` , $\cdots$ , `an`
>
> 构造差分数组: `b1` , `b2` , `b3` , $\cdots$ , `bn`
>
> 使得 `ai` = `b1` + `b2` + $\cdots$ + `bi`



##### 一维差分

> 构造 `bi` = `ai` - `ai-1` , `a0 = 0`
>
> `b1` = `a1`
>
> `b2` = `a2` - `a1`
>
> `b3` = `a3` - `a2`
>
> $\quad$ $\cdots$ 
>
> `bn` = `an` - `an-1`

> 由差分数组 `b[]` 可推原数组 `a[]`
>
> `ai` = `b1` + `b2` + $\cdots$ + `bi`

> 操作: 对数组 `a[]` , 区间 `[l,r]` 内所有数加 `c`
>
> 只需 `b[l] += c` , `b[r+1] -= c`
>
> `ai` = `b1` + `b2` + $\cdots$ + `bi`

> 思想: 原数组 `a[]` 全 `0` , 差分数组 `b[]` 也全 `0`
>
> 给 `a[1]` 赋值 `a1` $\Leftrightarrow$ 对区间 `[1,1]` 内数加 `a1` $\Leftrightarrow$ `b1 += a1` , `b2 -= a1` 

```c++
void insert (int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}
```

> 初始化: `insert (i,i,a[i])`



##### 二维差分

> 原数组 `a[i][j]` , 构造差分数组 `S[i][j]`
>
> `a[i][j]` 表示 `S[i][j]` 左上角全部元素之和

> `S[i][j] + = c` $\longrightarrow$ `a[i][j]` 右下角所有元素加 `c`
>
> 给 `a[x1,y1]` (左上角) 到 `a[x2,y2]` (右下角) 的矩阵内所有元素加上 `c` :
>
> `b[x1][y1] += c` , `b[x2+1][y1] -= c` , `b[x1][y2+1] -= c` , `b[x2+1][y2+1] += c` 

```c++
void insert (int x1,int y1,int x2,int y2,int c)
{
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}
```

> 初始化: `insert(i,j,i,j,a[i][j])` 



<div style="page-break-after:always;"></div>

# 离散化

> 特点: 值域大(0 ~ $10^9$) , 个数少($10^5$)

> $$
> \begin{CD}
> a[\quad] : \underbrace{1\quad2\quad5\quad8\quad10\quad\cdots\quad10^9}_{10^5个}  
> @>{映射到从0开始的连续自然数}>{离散化}> 0,\quad1,\quad2,\quad\cdots,\quad n-1
> \end{CD}
> $$

> ① `a[]` 中可能有重复元素 $\quad$ $\quad$ **去重** 
>
> ② 如何算出 `x` 离散化后的值 (在 `a[]` 数组中的下标) $\quad$ $\quad$ **二分**



```c++
//离散化模板

vector<int> alls;	//存储所有待离散化的值
sort(alls.begin(),alls.end());	//将所有值排序
alls.erase(unique(alls.begin(),alls.end()),alls.end());	//去重
```

```c++
//二分求出x对应的离散化的值

int find (int x)
{
    int l=0,r=alls.size()-1;
    while(l<r)
    {
        int mid=(l+r)/2;
        if(alls[mid]>=x)r=mid;
        else l=mid+1;
    }
    return r;
}
```



<div style="page-break-after:always;"></div>

# 数组模拟实现数据结构

### 数组模拟链表实现

> ① 单链表: 邻接表 (存储图和树)
>
> ② 双链表: 优化某些问题



##### 单链表

`int e[N]` 存储 `val` , `int ne[N]` 存储 `next` 

`````c++
//单链表模板

int head,e[N],ne[N],idx;
//head表示头节点的下标,e[i]表示节点i的值,ne[i]表示节点i的指针是多少,idx存储当前已经用到了哪个点

void init() //初始化
{
    head=-1;
    idx=0;
}

void add_to_head (int x) //将x插到头节点
{
    e[idx]=x;
    ne[idx]=head;
    head=idx++;
}

void add (int k,int x) //将x插到下标是k的点后面
{
    e[idx]=x;
    ne[idx]=ne[k];
    ne[k]=idx++;
}

void remove (int k) //删除下标是k的点的下一个点
{
    ne[k]=ne[ne[k]];
}
`````



##### 双链表

每个节点有两个指针, 指向上一个和下一个节点

```c++
int l[N],r[N];
0: head	  //下标为0的点作为头节点
1: tail   //下标为1的点作为尾节点
```

```c++
//双链表模板

int e[N],l[N],r[N],idx;
//e[]表示节点的值,l[]表示节点的左指针,r[]表示节点的右指针,idx表示当前用到了哪个节点

void init() //初始化
{
    r[0]=1,l[1]=0;	//0是左端点,1是右端点
    idx=2;
}

void add_to_right (int a,int x) //在节点a的右边插入一个数x
{
    e[idx]=x;
    l[idx]=a,r[idx]=r[a];
    l[[r[a]]]=idx,r[a]=idx;
    idx++;
}

void remove (int k) //删除节点k
{
    l[r[k]]=l[k];
    r[l[k]]=r[k];
}
```





---

### 数组模拟栈实现

```c++
//数组模拟栈模板

int stk[N],tt=0; //tt表示栈顶

stk[++tt]=x;  //向栈顶插入一个数x

tt--;	//向栈顶弹出一个数

stk[tt];	//栈顶的值

if(tt>0){}	//判断栈是否为空
```



**单调栈**

常见模型: 找出每个数左边离它最近的比它大/ 小的数

```c++
int stk[N],tt=0;
for(int i=1;i<=n;i++)
{
    while(tt&&check(stk[tt],a[i]))tt--;
    stk[++tt]=a[i];
}
```





---

### 数组模拟队列实现

```c++
//数组模拟队列模板

int q[N],hh=0,tt=-1;  //hh表示队头,tt表示队尾

q[++tt]=x;	//向队尾插入一个数x

hh++;	//从队头弹出一个数

q[hh];	//队头的值

if(hh<=tt){}	//判断队列是否为空
```



**单调队列**

常用模型: 找出滑动窗口中的最大值/ 最小值

```c++
int q[N],hh=0,tt=-1;
for(int i=1;i<=n;i++)
{
    while(hh<=tt&&check_out(q[hh]))hh++;  //判断队头是否滑出窗口
    while(hh<=tt&&check(q[tt],a[i]))t--;
    q[++tt]=a[i];
}
```







---

### 数组模拟堆实现

> 堆是一棵完全二叉树

> 对于小根堆: 每一个点都小于等于左右两个子节点

> 存储方式(完全二叉树的存储方式): 用一维数组存储
>
> 堆数组下标从1开始(1为根节点)
>
> x的左儿子是 2x , x的右儿子是 2x+1



> 如何手写一个堆?
>
> 1. 插入一个数     `heap[++size] = x` , `up(size)`
> 2. 求集合中的最小值     `heap[1]`
> 3. 删除最小值     `heap[1] = heap[size]` , `size-- ` , `down(1)`
> 4. 删除任意一个元素     `heap[k] = heap[size]` , `size--` , `down(k)` , `up(k)`
> 5. 删除任意一个元素     `heap[k] = x` , `down(k)` , `up(k)`



```c++
//堆数组操作模板

//O(n)建堆
for(int i=n/2;i;i--)down(i);

//down操作
void down (int u)
{
    int t=u;		//t最终存储最小值下标
    if(u*2<=size&&h[u*2]<h[t])t=u*2;
    if(u*2+1<=size&&h[u*2+1]<h[t])t=u*2+1;
    if(u!=t)
    {
        swap(h[u],h[t]);
        down(t);
    }
}

//up操作
void up (int u)
{
    while(u/2&&h[u/2]>h[u])
    {
        swap(h[u/2],h[u]);
        u/=2;
    }
}
```



```c++
//维护映射关系的堆模板

int h[N],ph[N],hp[N],size;
//h[]存储堆中的值
//ph[k]存储第k个插入的点在堆中的位置
//hp[k]存储堆中下标是k的点是第几个插入的

//交换两个点,及其映射关系
void heap_swap (int a,int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a],hp[b]);
    swap(h[a],h[b]);
}
```



<div style="page-break-after:always;"></div>

# KMP算法

> KMP算法用于解决字符串匹配问题, str1 某个字符串是否与 str2 一样, 如果一样, 返回 str2 开始的位置



```c++
//KMP算法模板

int n,m;
char s[N],p[M];
int ne[M];
//s[]是长文本,p[]是模式串(短串),n是s的长度,m是p的长度

//读入字符串
cin>>n>>s+1>>m>>p+1;  //KMP算法习惯下标从1开始

//求模式串的next数组
for(int i=2,j=0;i<=m;i++)
{
    while(j&&p[i]!=p[j+1])j=ne[j];
    if(p[i]==p[j+1])j++;
    ne[i]=j;
}

//KMP匹配过程
for(int i=1,j=0;i<=n;i++)
{
    while(j&&s[i]!=p[j+1])j=ne[j];
    if(s[i]==p[j+1])j++;
    
    if(j==m) //匹配成功
    {
        j=ne[j];
    }
}
```



<div style="page-break-after:always;"></div>

# Trie 树

> Trie 树, 高效地存储和查找字符串集合的数据结构



```c++
//Trie树模板
int son[N][26],cnt[N],idx;

//插入一个字符串
void insert (char str[])
{
    int p=0;
    for(int i=0;str[i];i++)
    {
        int u=str[i]-'a';
        if(!son[p][u])son[p][u]=++idx;
        p=son[p][u];
    }
    cnt[p]++;
}

//查询字符串出现的次数
int query (char str[])
{
    int p=0;
    for(int i=0;str[i];i++)
    {
        int u=str[i]-'a';
        if(!son[p][u])return 0;
        p=son[p][u];
    }
    return cnt[p];
}
```



<div style="page-break-after:always;"></div>

# 并查集

> 并查集
>
> 1. 将两个集合合并
> 2. 询问两个元素是否在一个集合当中

> 基本原理: 每个集合用一颗树来表示, 树根的编号就是整个集合的编号. 每个节点存储它的父节点, p[x] 表示 x 的父节点.

> ① 如何判断树根     `if(p[x]==x)`
>
> ② 如何求x的集合编号     `while(p[x]!=x)x=p[x]`
>
> ③ 如何合并两个集合     p[x] 是 x 的集合编号, p[y] 是 y 的集合编号, `p[x]=y`

> **优化: 路径压缩**



---

### 普通并查集

```c++
//并查集模板

int p[N];
for(int i=1;i<=n;i++)p[i]=i;	//初始化,假定节点编号是1~n

int find (int x)	//返回x的祖宗节点 + 路径压缩
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

//合并a和b所在的两个集合
p[find(a)]=find(b)
```





---

### 维护size的并查集

```c++
//维护size的并查集模板

int p[N],size[N];
for(int i=1;i<=n;i++)	//初始化,假定节点编号是1~n
{						//size[]只有祖宗节点的有意义,表示祖宗节点所在集合中的点的数量
    p[i]=i;
    size[i]=1;
}

int find (int x)	//返回x的祖宗节点 + 路径压缩
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

//合并a和b所在的两个集合
size[find(b)]+=size[find(a)];
p[find(a)]=find(b);
//注意:顺序不能调换
```





---

### 维护到祖宗节点距离的并查集

```c++
//维护到祖宗节点距离的并查集模板

int p[N],d[N];	//p[]存储每个点的祖宗节点,d[x]存储x到p[x]的距离
for(int i=1;i<=n;i++)p[i]=i;

int find (int x)	//返回x的祖宗节点 + 路径压缩
{
    if(p[x]!=x)
    {
        int u=find(p[x]);
        d[x]+=d[p[x]];
        p[x]=u;
    }
    return p[x];
}

//合并a和b所在的两个集合
p[find(a)]=find(b);
d[find(a)]=distance;  //根据具体问题,初始化find(a)的偏移量
```



<div style="page-break-after:always;"></div>

# 哈希表

$$
哈希表
\begin{cases}
存储结构 \begin{cases} 开放寻址法 \\[2ex] 拉链法 \\[2ex] \end{cases} \\[3ex]
字符串哈希方式\\[3ex]
\end{cases}
$$



---

### 一般哈希

##### 开放寻址法

```c++
//开放寻址法模板

const int N=(数据范围的2~3倍,质数),null=(数据范围外的数,常用0x3f3f3f3f);
int h[N];
memset(h,null,sizeof h);

//如果x在哈希表中,返回x的下标;如果x不在哈希表中,返回x应该插入的位置
int find (int x)
{
    int t=(x%N+N)%N;
    while(h[t]!=null&&h[t]!=x)
    {
        t++;
        if(t==N)t=0;
    }
    return t;
}
```



##### 拉链法

```c++
//拉链法模板

int h[N],e[N],ne[N],idx;
memset(h,-1,sizeof h);	//将单数组每个点的指针初始化为空指针-1

//向哈希表中插入一个数
void insert (int x)
{
    int k=(x%N+N)%N;  //保证k为非负数
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

//在哈希表中查询某个数是否存在
bool find (int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
        if(e[i]==x)return true;
    return false;
}
```





---

### 字符串哈希

> 核心思想: 将字符串看成 p 进制数,  p 的经验值是 `131` 或 `13331` , 取这两个值冲突概率低

> 小技巧: 取模的数用 $2^{64}$ , 这样直接用 `unsigned long long` 存储, 溢出的结果就是取模的结果



```c++
//字符串哈希模板

const int p=131;
unsigned long long h[N],p[N];
//h[k]存储字符串前k个字母的哈希值,p[k]存储(p^k)%(2^64)

//初始化
p[0]=1;
for(int i=1;i<=n;i++)
{
    h[i]=h[i-1]*p+str[i];
    p[i]=p[i-1]*p;
}

//计算子串str[l~r]的哈希值
unsigned long long get (int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
```



<div style="page-break-after:always;"></div>

# C++ STL容器

> `vector`           变长数组, 倍增的思想
>
> `string`           字符串, `substr()` , `c_str()`
>
> `queue`             队列, `push()` , `front()` , `pop()`
>
> `priority_queue`           优先队列, `push()` , `top()` , `pop()`
>
> `stack`             栈, `push()` , `top()` , `pop()`
>
> `deque`             双端队列
>
> `set` , `map` , `multiset` , `multimap`           基于平衡二叉树(红黑树), 动态维护有序序列
>
> `unordered_set` , `unordered_map` , `unordered_multiset` , `unordered_multimap`          哈希表
>
> `bitset`           压位



---

### vector

>初始化:
>
>`vector <int> a (10)`          长度为10的数组
>
>`vector <int> a (10,3)`      长度为10的数组, 每一个数为3
>
>`vector <int> a [10]`          定义了10个vector



> `vector` 支持的函数:
>
> `a.size()`        返回元素个数
>
> `a.empty()`      空返回 `true` , 非空返回 `false`
>
> `a.clear()`      清空
>
> `a.front()` / `a.back()`      返回第一个数/ 最后一个数
>
> `a.push_back()`      在最后插入一个数
>
> `a.pop_back()`        删除最后一个数
>
> `a.begin()`              返回 `a` 的第一个元素的迭代器
>
> `a.end()`                  返回 `a` 的最后一个元素的下一个元素的迭代器
>
> `a[]`                           `vector` 支持随机寻址



> `vector` 的遍历:
>
> `for(int i = 0 ; i < a.size() ; i++) cout << a[i] << ' ';`      用数组下标遍历
>
> `for(vector<int>::iterator i = a.begin() ; i != a.end() ; i++) cout << *i << ' ';`      用迭代器遍历
>
> `for(auto x : a) cout << x << ' ';`      C++的范围遍历



> 倍增思想: 系统为某一程序分配空间时所需时间, 与空间大小无关, 与申请次数有关.
>
> `vector` 每一次数组长度不够时, 将数组长度扩大一倍.





---

### pair

> 初始化:
>
> `pair <int,int> p`
>
> `pair <int,pair <int,int>> p`



> `pair` 支持的操作:
>
> `p.first`      返回第一个元素
>
> `p.second`    返回第二个元素





---

### string

> 初始化:      `string a`



> `string` 支持的函数:
>
> `a.length()`      返回字符串长度
>
> `a.size()`          返回元素个数
>
> `a.empty()`        空返回 `true` , 非空返回 `false`
>
> `a.clear()`        清空
>
> `a.find('x')`    返回字符 `x` 在字符串中下标
>
> `a.substr(,)`    返回某个子串
>
> 第一个参数表示子串起点下标, 第二个参数表示子串长度. 
>
> 若第二个参数过大(或无第二个参数), 返回从第一个参数开始的整个子串.



> 若用 `printf` 输出 `string` 要用 `a.c_str()`





---

### queue

> 初始化:      `queue <int> a`



> `queue` 支持的函数:
>
> `a.size()`       返回元素个数
>
> `a.empty()`     空返回 `true` , 非空返回 `false`
>
> `a.push(x)`     向队尾插入一个元素 `x`
>
> `a.front()`     返回队头元素
>
> `a.back()`       返回队尾元素
>
> `a.pop()`         弹出队头元素



> 注意: `queue` 没有 `clear` 函数
>
> `a = queue <int> ();`      相当于 `clear` 功能





---

### priority_queue

> 初始化:
>
> `priority_queue <int> heap`      优先队列, 默认是大根堆
>
> `priority_queue <int,vector<int>,greater<int>> heap` 定义小根堆



> `priority_queue` 支持的函数:
>
> `heap.push(x)`      插入一个元素 `x`
>
> `heap.top()`          返回堆顶元素
>
> `heap.pop()`          弹出堆顶元素



> 注意: `priority_queue` 没有 `clear` 元素





---

### stack

> 初始化:      `stack <int> a`



> `stack` 支持的函数:
>
> `a.size()`       返回元素个数
>
> `a.empty()`     空返回 `true` , 非空返回 `false` 
>
> `a.push(x)`     向栈顶插入一个元素 `x`
>
> `a.top()`         返回栈顶元素
>
> `a.pop()`         弹出栈顶元素



>  注意: `stack` 没有 `clear` 函数





---

### deque

> 初始化:      `deque <int> q`



> `deque` 支持的函数:
>
> `q.size()`        返回元素个数
>
> `q.empty()`      空返回 `true` , 非空返回 `false`
>
> `q.clear()`      清空
>
> `q.front()`      返回队头元素
>
> `q.back()`        返回队尾元素
>
> `q.push_back()`      向队尾插入一个元素 `x`
>
> `q.pop_back()`        弹出队尾元素
>
> `q.push_front()`     向队头插入一个元素 `x`
>
> `q.pop_front()`       弹出队头元素
>
> `q[]`                   `deque` 支持随机访址
>
> `q.begin()`       返回第一个元素的迭代器
>
> `q.end()`           返回最后一个元素下一个元素的迭代器





---

### set / multiset

==`set` 元素不能重复, `multiset` 元素可以重复==



> 初始化: 
>
> `set <int> s`
>
> `multiset <int> ms`



> `set` / `multiset` 支持的函数:
>
> `s.size()`      返回元素个数
>
> `s.empty()`     空返回 `true` , 非空返回 `false` 
>
> `s.clear()`     清空
>
> `s.insert(x)`      插入一个数 `x`
>
> `s.find(x)`          查找一个数 `x` , 存在返回 `x` 的迭代器, 不存在返回 `end()` 的迭代器
>
> `s.count(x)`        返回某一个数 `x` 的个数
>
> `s.erase()`          输入的是一个数 `x` , 则删除所有 `x` ; 输入的是一个迭代器, 则删除这个迭代器
>
> `s.lower_bound(x)`      返回大于等于 `x` 的最小的数的迭代器, 不存在则返回 `end()`
>
> `s.upper_bound(x)`      返回大于 `x` 的最小的数的迭代器, 不存在则返回 `end()`
>
> `++` / `--`                返回前驱/ 后继的迭代器





---

### map / multimap

> 初始化:
>
> `map <string,int> a`
>
> `a ["xt"] = 666`
>
> `cout << a ["xt"] <<endl;`   输出"1"
>
> **可将第一个参数作为数组下标**



> `map` / `multimap` 支持的函数:
>
> `a.size()`        返回元素个数
>
> `a.empty()`      空返回 `true` , 非空返回 `false` 
>
> `a.clear()`      清空
>
> `a.begin()`      返回第一个元素的迭代器
>
> `a.end()`          返回最后一个元素下一个元素的迭代器
>
> `++` / `--`            返回前驱/ 后继的迭代器
>
> `a.insert()`     插入的数需要是一个 `pair` 
>
> `a.erase()`       输入的参数需要是一个 `pair` 或迭代器
>
> `a.find()`
>
> `a[]`





---

### unordered_set / unordered_map / unordered_multiset / unordered_multimap

> 允许存在重复元素的 `set` 和`map` 
>
> 增删查改的时间复杂度是 O(1)
>
> 除不支持 `lower_bound()` 和 `upper_bound()` 外, 其余支持函数与 `set` 和`map` 相同





---

### bitset

> 初始化:      `bitset <10000> S` 
>
> `bitset` 只能存储 `0` 和 `1` , `< >` 内参数表示长度



> `bitset` 支持的操作:
>
> `~S`      取反
>
> `&` , `|` , `^`      与、或、异或
>
> `>>` , `<<`        位运算
>
> `==` , `!=`        等于、不等于
>
> `S.count()`      返回有多少个 `1`
>
> `S.any()`          判断是否至少有一个 `1`
>
> `S.none()`        判断是否全为 `0`
>
> `S.set()`           把所有位置成 `1`
>
> `S.set(k,v)`     把第 `k` 位变成 `v`
>
> `S.reset()`       把所有位置成 `0`
>
> `S.flip()`         把所有位取反
>
> `S.flip(k)`       把第 `k` 位取反



<div style="page-break-after:always;"></div>

# 图论基础

### 深度优先遍历

> 深度优先遍历(DFS), 指从图中一个未遍历的节点u开始, 沿着一条路一直走到底, 然后从这条路尽头回退到上一个节点, 再从另一条路开始走到底. 不断递归重复此过程, 直到所有节点都遍历完成. 



深度优先遍历经典问题Ⅰ [排列数字](https://www.acwing.com/problem/content/844/)

````c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N=10;
int n;
int path[N];
bool st[N];

void dfs(int u)
{
    if(u==n)
    {
        for(int i=0;i<n;i++)cout<<path[i]<<' ';
        cout<<'\n';
        return;
    }
    
    for(int i=1;i<=n;i++)
        if(!st[i])
        {
            path[u]=i;
            st[i]=true;
            dfs(u+1);
            st[i]=false;	//恢复现场 + 回溯
        }
}

int main()
{
    cin>>n;
    dfs(0);
    return 0;
}
````



深度优先遍历经典问题Ⅱ [n-皇后问题](https://www.acwing.com/problem/content/845/)

````c++
//第一种搜索顺序(按行搜索)

#include<iostream>
#include<algorithm>

using namespace std;

const int N=20;
int n;
char g[N][N];
bool col[N],dg[N],udg[N];	//col表示列，dg表示“/”对角线，udg表示“\”对角线

void dfs(int u)		//u按行搜索
{
    if(u==n)
    {
        for(int i=0;i<n;i++)cout<<g[i]<<'\n';
        cout<<'\n';
        return;
    }
    
    for(int i=0;i<=n;i++)
        if(!col[i]&&!dg[u+i]&&!udg[n-u+i])
        {
            g[u][i]='Q';
            col[i]=dg[u+i]=udg[n-u+i]=true;
            dfs(u+1);
            col[i]=dg[u+i]=udg[n-u+i]=false;	//恢复现场+回溯
            g[u][i]='.';
        }
}

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            g[i][j]='.';
    dfs(0);
    return 0;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------

//第二种搜索顺序(按每一个格子搜索)

#include<iostream>
#include<algorithm>

using namespace std;

const int N=20;
int n;
char g[N][N];
bool row[N],col[N],dg[N],udg[N];

void dfs(int x,int y,int s)		//s是皇后个数
{
    if(y==n)y=0,x++;
    if(x==n)
    {
        if(s==n)
        {
            for(int i=0;i<n;i++)cout<<g[i]<<'\n';
            cout<<'\n';
        }
        return;
    }
    
    //不放皇后
    dfs(x,y+1,s);
    //放皇后
    if(!row[x]&&!col[y]&&!dg[x+y]&&!udg[x-y+n])
    {
        g[x][y]='Q';
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=true;
        dfs(x,y+1,s+1);
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=false;		//恢复现场+回溯
        g[x][y]='.';
    }
}

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            g[i][j]='.';
    dfs(0,0,0);
    return 0;
}
````





---

### 宽度优先遍历

> 宽度优先遍历(BFS), 又称广度优先遍历, 指从图的一个未遍历的节点出发, 先遍历这个节点的相邻节点, 再依次遍历每个相邻节点的相邻节点.



宽度优先遍历经典题目Ⅰ [走迷宫](https://www.acwing.com/problem/content/846/)

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

const int N=110;
int n,m;
int g[N][N],d[N][N];	
//g[][]用于存储迷宫地图,d[][]用于记录每个点是否被搜索过,存储每一个点到起点的距离

int bfs()
{
    queue<pair<int,int>>q;
    
    memset(d,-1,sizeof d);
    d[0][0]=0;
    q.push({0,0});
    
    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};	//偏移量
    
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        
        for(int i=0;i<4;i++)
        {
            int x=t.first+dx[i],y=t.second+dy[i];
            if(x>=0&&x<n&&y>=0&&y<m&&g[x][y]==0&&d[x][y]=-1)
            {
                d[x][y]=d[t.first][t.second]+1;
                q.push({x,y});
            }
        }
    }
    
    return d[n-1][m-1];
}

int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            cin>>g[i][j];
    
    cout<<bfs()<<endl;
    return 0;
}
```



宽度优先遍历经典问题Ⅱ [八数码](https://www.acwing.com/problem/content/847/)

````c++
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<queue>

using namespace std;

int bfs(string start)
{
    string end="12345678x";
    
    queue<string>q;
    unordered_map<string,int>d;
    
    q.push(start);
    d[start]=0;
    
    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        
        int distance=d[t];
        if(t==end)return distance;
        
        //状态转移
        int k=t.find('x');
        int x=k/3,y=k%3;
        for(int i=0;i<4;i++)
        {
            int a=x+dx[i],b=y+dy[i];
            if(a>=0&&a<3&&b>=0&&b<3)
            {
                swap(t[k],t[a*3+b]);
                if(d.count(t)==0)
                {
                    d[t]=distance+1;
                    q.push(t);
                }
                swap(t[k],t[a*3+b]);
            }
        }
    }
    
    return -1;
}
````





---

### 树与图的存储

> 树是一种特殊的图(无环连通图)
>
> 图分为有向图、无向图
>
> 无向图是特殊的有向图, 对无向图中的边ab, 存储两条有向边 a $\to$ b , b $\to$ a 
> $$
> 有向图的存储 
> \begin{cases} 
> 邻接矩阵(不能处理重边) \\[4ex]
> 邻接表 
> \end{cases}
> $$



```c++
int h[N],e[N],ne[N],idx;

//添加一条从a到b的边
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
```





---

### 树与图的深度优先遍历

```c++
void dfs(int u)
{
    st[u]=true;		//表示点u已经被遍历过
    
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])dfs(j);
    }
}
```





---

### 树与图的宽度优先遍历

```c++
queue<int>q;
st[1]=true;		//表示1号点已经被遍历过
q.push(1);

while(q.size())
{
    int t=q.front();
    q.pop();
    
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            st[j]=true;
            q.push(j);
        }
    }
}
```





---

### 拓扑排序

> 拓扑排序是图的宽度优先搜索的一个应用
>
> 拓扑图即有向无环图



```c++
//拓扑排序模板
bool topsort()
{
    int hh=0,tt=-1;
    
    //d[i]存储点i的入度
    for(int i=1;i<=n;i++)
        if(d[i]==0)q[++tt]=i;
    
    while(hh<=tt)
    {
        int t=q[hh++];
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(--d[j]==0)q[++tt]=j;
        }
    }
    
    //如果所有点都入队了,说明存在拓扑序列;否则不存在拓扑序列
    return tt==n-1;
}
```



<div style="page-break-after:always;"></div>

# 最短路问题

$$
最短路
\begin{cases}
\ 单源最短路 \quad \begin{cases}\ 所有边权都是正数 \quad \begin{cases}\ 朴素Dijkstra算法 \quad \\[3ex] 堆优化版Dijkstra算法 \quad \end{cases}\ \\[5ex] 存在负权边 \quad \begin{cases}\ Bell-Ford算法 \quad \\[3ex] SPFA算法 \quad \end{cases}\ \end{cases}\ \\[7ex]
 多源汇最短路 \quad Floyd算法
\end{cases}\
$$



---

### 朴素Dijkstra算法

> **朴素Dijkstra 基本思想：**
>
> 集合 s 存储当前已确定最短距离的点
>
> ①dist [ 1 ] = 0 , dist [ i ] = + $ \infty $
>
> ②迭代$\quad$$\quad$for	i : 1 ~ n
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$t $\gets$ 不在s中的, 距离最近的点
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$s $\gets$ t
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$用t更新其他点

> 边的存储方式
>
> + 稠密图 —— 邻接矩阵
> + 稀疏图 —— 邻接表



````c++
//朴素Dijkstra算法模板

int g[N][N];	//存储每条边
int dist[N];	//存储1号点到每个点的最短距离
bool st[N];		//存储每个点的最短路是否已确定

//求1号点到n号点的最短路,如果不存在则返回-1
int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    
    for(int i=0;i<n;i++)
    {
        int t=-1;	//在还未确定最短路的点中,寻找距离最小的点
        for(int j=1;j<=n;j++)
            if(!st[j]&&(t==-1||dist[t]>dist[j]))
                t=j;
        
        //用t更新其他点的距离
        for(int j=1;j<=n;j++)
            dist[j]=min(dist[j],dist[t]+g[t][j]);
        
        st[t]=true;
    }
    
    if(dist[n]==0x3f3f3f3f)return -1;
    return dist[n];
}
````



---

### 堆优化版Dijkstra算法

````c++
//堆优化版Dijkstra算法模板
typedef pair<int,int> PII;

int n;		//点的数量
int h[N],w[N],e[N],ne[N],idx;	//邻接表存储所有边
int dist[N];		//存储所有点到1号点的距离
bool st[N];			//存储每个点的最短路是否已确定

//邻接表存储所有边
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

//求1号点到n号点的最短距离,如果不存在则返回-1
int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    priority_queue <PII,vector<PII>,greater<PII>> heap;
    heap.push({0,1});
    
    while(heap.size())
    {
        auto t=heap.top();
        heap.pop();
        int ver=t.second,distance=t.first;
        
        if(st[ver])continue;
        st[ver]=true;
        
        for(int i=h[ver];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>distance+w[i])
            {
                dist[j]=distance+w[i];
                heap.push({dist[j],j});
            }
        }
    }
    
    if(dist[n]==0x3f3f3f3f)return -1;
    return dist[n];
}
````



___

### Bellman - Ford算法

> **Bellman - Ford算法基本思想:**
>
> 迭代		for	n次		==(迭代k次,表示经过不超过k条边)==
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$for	所有边a, b, w		$a \stackrel{w}{\rightarrow} b$
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$dist[b] = min (dist[b] , dist[a] + w)



````c++
//Bell-Ford算法模板

int n,m,k;		//n表示点数,m表示边数,k表示经过不超过k条边
int dist[N];	//dist[x]用于存储1到x的最短距离
int backup[N];	//backup[x]用于备份数组dist[N]

struct Edge		//存储边
{
    int a,b,w;
}edge[N];

//求1到n经过不超过k条边的最短路距离,如果无法从1走到n则返回-1
int bellman_ford()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    
    for(int i=0;i<k;i++)
    {
        memcpy(backup,dist,sizeof dist);
        
        for(int j=0;j<m;j++)
        {
            int a=edges[i].a,b=edges[i].b,w=edges[i].w;
            dist[b]=min(dist[b],backup[a]+w);
        }
    }
    
    if(dist[n]>0x3f3f3f3f/2)return -1;
    return dist[n];
}
````



---

### SPFA算法

````c++
//spfa算法模板

int n;		//总点数
int h[N],w[N],e[N],ne[N],idx;		//邻接表存储所有边
int dist[N];		//存储每个点到1号点的最短距离
bool st[N];			//存储每个点是否在队列中

//邻接表存储所有边
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

//求1号点到n号点的最短路距离,如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    
    queue<int>q;
    q.push(1);
    st[1]=true;
    
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=false;
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                if(!st[j])	//如果队列中已存在j,则不需要将j重复插入
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    
    if(dist[n]==0x3f3f3f3f)return -1;
    return dist[n];
}
````



````c++
//spfa判断图中是否存在负环模板

int n;		//总点数
int h[N],w[N],e[N],ne[N],idx;		//邻接表存储所有边
int dist[N],cnt[N];			//dist[x]存储1号点到x号点的最短距离,cnt[x]存储1到x的最短路中经过的点数
bool st[N];			//存储每个点是否在队列中

//如果存在负环,则返回true,否则返回false
bool spfa()
{
    //不需要初始化dist数组
    //原理:如果某条最短路径上有n个点(除了自己),那么加上自己之后一共有n+1个点,由鸽巢原理一定有两个点相同,所以存在环
    
    queue<int>q;
    for(int i=1;i<=n;i++;i++)
    {
        q.push(i);
        st[i]=true;
    }
    
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=false;
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n)return true;
                //如果从1号点到x的最短路中包含至少n个点(不包括自己),则说明存在环
                
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    
    return false;
}
````



---

### Floyd算法

> **Floyd算法基本思想**
>
> 邻接矩阵 d[i, j] 存储每一条边
>
> 初始化三重循环		for(int k = 1 ; k <= n ; k++ )
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$for(int i = 1 ; i <= n ; i++ )
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$for(int j = 1 ; j <= n ; j++ )
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$$\quad$d[i, j] = min(d[i, j] , d[i, k] + d[k, j])



````c++
//Floyd算法模板

//初始化
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(i==j)d[i][j]=0;
		else d[i][j]=0x3f3f3f3f;

//算法结束后,d[a][b]表示a到b的最短距离
void floyd()
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}
````



<div style="page-break-after:always;"></div>

# 最小生成树

$$
最小生成树
\begin{cases}
\ Prim算法 \quad \begin{cases}\ 朴素版Prim\ \\[3ex] 堆优化版Prim\ \end{cases}\ \\[5ex]
 Kruskal算法 
\end{cases}\
$$



---

### Prim算法

> **朴素Prim基本思想**
>
> dist [ i ] $\longleftarrow$ + $\infin$
>
> for (int i = 0 ; i < n ; i ++)
>
> $\quad$$\quad$$\quad$t $\longleftarrow$ 找到集合外距离最近的点
>
> $\quad$$\quad$$\quad$用t更新其他点到集合的距离
>
> $\quad$$\quad$$\quad$st [ t ] = true



````c++
//朴素版Prim算法模板

int n;		//表示点数
int g[N][N];	//邻接矩阵,存储所有边
int dist[N];	//存储其他点到当前最小生成树的距离
bool st[N];		//存储每个点是否已经在生成树中

//如果图不连通则返回INF(值是0x3f3f3f3f),否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist,0x3f,sizeof dist);
    
    int res=0;
    for(int i=0;i<n;i++)
    {
        int t=-1;
        for(int j=1;j<=n;j++)
            if(!st[j]&&(t==-1||dist[t]>dist[j]))
                t=j;
        
        if(i&&dist[t]==INF)return INF;
        
        if(i)res+=dist[t];
        st[t]=true;
        
        for(int j=1;j<=n;j++)dist[j]=min(dist[j],g[t][j]);
    }
    
    return res;
}
````





___

### Kruskal 算法

> **Kruskal算法基本思想**
>
> ① 将所有边按权重从小到大排序
>
> ② 枚举每一条边 a $\to$ b ,权重c
>
> $\quad$$\quad$$\quad$$\quad$if a、b 不连通
>
> $\quad$$\quad$$\quad$$\quad$$\quad$$\quad$将这条边加入集合中



````c++
//Kruskal算法模板

int n,m;	//n是点数,m是边数
int p[N];	//并查集的父节点数组

int find(int x)		//并查集核心操作
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

struct Edge		//存储边
{
    int a,b,w;
    
    bool operator<(const Edge &W)const
    {
        return w<W.w;
    }
}edges[M];

int kruskal()
{
    sort(edges,edges+m);
    
    for(int i=1;i<=n;i++)p[i]=i;	//初始化并查集
    
    int res=0,cnt=0;
    for(int i=0;i<m;i++)
    {
        int a=edges[i].a,b=edges[i].b,w=edges[i].w;
        
        a=find(a),b=find(b);
        if(a!=b)		//如果两个连通块不连通,则将这两个连通块合并
        {
            p[a]=b;
            res+=w;
            cnt++;
        }
    }
    
    if(cnt<n-1)return INF;
    return res;
}
````



<div style="page-break-after:always;"></div>

# 二分图

$$
二分图
\begin{cases}
\ 染色法 \\[4ex]
 匈牙利算法
\end{cases}\
$$



---

### 染色法

````c++
//染色法判别二分图模板

int n;		//n表示点数
int h[N],e[M],ne[M],idx;	//邻接表存储图
int color[N];		//表示每个点的颜色,-1表示为染色,0表示白色,1表示黑色

//参数:u表示当前节点,c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u]=c;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(color[j]==-1)
        {
            if(!dfs(j,!c))return false;
        }
        else if(color[j]==c)return false;
    }
    return true;
}

bool check()
{
    memset(color,-1,sizeof color);
    bool flag=true;
    for(int i=1;i<=n;i++)
        if(color[i]==-1)
            if(!dfs(i,0))
            {
                flag=false;
                break;
            }
    return flag;
}
````





---

### 匈牙利算法

````c++
//匈牙利算法模板

int n1,n2;		//n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N],e[M],ne[M],idx;	//匈牙利算法中只会用到从第一个集合指向第二个集合的边
int match[N];		//存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];			//表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for(int i=h[x];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            st[j]=true;
            if(match[j]==0||find(match[j]))
            {
                match[j]=x;
                return true;
            }
        }
    }
    
    return false;
}

//求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res=0;
for(int i=1;i<=n;i++)
{
    memset(st,false,sizeof st);
    if(find(i))res++;
}
````



<div style="page-break-after:always;"></div>

# 数论

### 质数

> 在大于1的整数中, 如果只包含1和本身这两个约数, 就被称为质数, 或者叫质数



##### (1)质数的判定——试除法

```c++
//试除法判定质数模板
bool is_prime(int x)
{
    if(x<2)return false;
    for(int i=2;i<=x/i;i++)
        if(x%i==0)return false;
    return true;
}
```

````
注意:循环的结束条件为 i<=x/i ,若改为 i*i<=x 在x接近int上界时会有溢出风险
````



##### (2)分解质因数——试除法

```c++
//试除法分解质因数模板
void divide(int x)
{
    for(int i=2;i<=x/i;i++)
        if(x%i==0)
        {
            int s=0;
            while(x%i==0)
            {
                s++;
                x/=i;
            }
            cout<<i<<' '<<s<<'\n';
        }
    if(x>1)cout<<x<<' '<<1<<'\n';
    //n中最多只含一个大于sqrt(n)的质因子
}
```



##### (3)质数的判定——埃氏筛法

```c++
//朴素筛法求素数模板

int primes[N],cnt;	//primes[]存储所有的素数
bool st[N];		//st[]存储x是否被筛掉

void get_primes(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(st[i])continue;
        primes[cnt++]=i;
        for(int j=i+i;j<=n;j+=i)
            st[j]=true;
    }
}
```



##### (4)质数的判定——线性筛法

```c++
//线性筛法求素数模板

int primes[N],cnt;	//primes[]存储所有的素数
bool st[N];		//st[x]存储x是否被筛掉

void get_primes(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++)
        {
            st[primes[j]*i]=true;
            if(i%primes[j]==0)break;
            //primes[j]一定是i的最小质因子
        }
    }
}
```





---

### 约数

##### (1)试除法求一个数的所有约数

```c++
//试除法求所有的约数模板
vector<int> get_divisors (int x)
{
    vector<int>res;
    for(int i=1;i<=x/i;i++)
        if(x%i==0)
        {
            res.push_back(i);
            if(i!=x/i)res.push_back(x/i);
        }
    sort(res.begin(),res.end());
    return res;
}
```



##### (2)约数个数

##### (3)约数之和

> 如果 N = $p^{c_1}_{1}$ × $p1^{c_2}_{2}$ × $\cdots$ × $p^{c_k}_k$ 
>
> 约数个数: ($c_1$ + 1) × ($c_2$ + 1) × $\cdots$ × ($c_k$ + 1)
>
> 约数之和: ($p^0_1$ + $p^1_1$ + $p^2_1$ + $\cdots$ + $p^{c_1}_1$) × ($p^0_2$ + $p^1_2$ + $p^2_2$ + $\cdots$ + $p^{c_2}_2$) × $\cdots$ × ($p^0_k$ + $p^1_k$ + $\cdots$ + $p^{c_k}_k$ )



```c++
//求约数个数模板

unordered_map<int,int>primes;

while(n--)
{
    int x;
    cin>>x;
    
    for(int i=2;i<=x/i;i++)
        while(x%i==0)
        {
            x/=i;
            primes[i]++;
        }
    if(x>1)primes[x]++;
}
long long res=1;
for(auto p:primes)res=res*(p.second+1)%mod;
```



```c++
//求约数之和模板

unordered_map<int,int>primes;

while(n--)
{
    int x;
    cin>>x;
    
    for(int i=2;i<=x/i;i++)
        while(x%i==0)
        {
            x/=i;
            primes[i]++;
        }
    if(x>1)primes[x]++;
}

long long res=1;
for(auto p:primes)
{
    long long a=p.first,b=p.second;
    long long t=1;
    while(b--)t=(t*a+1)%mod;
    res=res*t%mod;
}
```



##### (4)欧几里得算法(辗转相除法)

> 原理: d 能整除 a , d 能整除 b $\longrightarrow$ 则 d 能整除 ax+by
>
> + a % b = a - [ $\dfrac{a}{b}$ ] × b = a - c × b
>
> + a 和 b的最大公约数
>
>   = b 和 a - c × b 的最大公约数
>
>   = b 和 a % b 的最大公约数



```c++
//欧几里得算法
int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
```





---

### 欧拉函数

> 欧拉函数 $\varphi$ ~(n)~      1 ~ n 中与n互质的数的个数
>
> 
>
> 如果 N = $p^{\alpha_1}_1$ × $p^{\alpha_2}_2$ × $\cdots$ × $p^{\alpha_k}_k$
>
> $\varphi$ ~(N)~ = N × (1 - $\dfrac{1}{p_1}$) × (1 - $\dfrac{1}{p_2}$) × $\cdots$ × (1 - $\dfrac{1}{p_k}$)



```c++
//公式法求欧拉函数模板
int phi(int x)
{
    int res=x;
    for(int i=2;i<=x/i;i++)
        if(x%i==0)
        {
            res=res/i*(i-1);
            while(x%i==0)x/=i;
        }
    if(x>1)res=res/x*(x-1);
    
    return res;
}
```



```c++
//筛法求欧拉函数模板

int primes[N],cnt;		//primes[]存储所有的素数
int euler[N];			//存储每个数的欧拉函数
bool st[N];			//st[x]存储x是否被筛掉

void get_eulers(int n)
{
    eular[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            euler[i]=i-1;
        }
        for(int j=0;primes[j]<=n/i;j++)
        {
            int t=primes[j]*i;
            st[t]=true;
            if(i%primes[j]==0)
            {
                euler[t]=euler[i]*primes[j];
                break;
            }
            euler[t]=euler[i]*(primes[j]-1);
        }
    }
}
```



> 欧拉定理: 若 a 与 n 互质, 则 $a^{\varphi~(n)~}$ % n = 1

> 费马定理: 若 a 与 p 互质, p为质数, 则 $a^{p-1}$ % p = 1





___

### 快速幂

> 快速幂: 用 O(log~2~k)时间计算出 $a^k$ mod p

> 算法原理: 先预处理出
> $$
> \begin{cases}
> a^{2^0} \text{ mod p}\\[0.3ex]
> a^{2^1} \text{ mod p} \text{\quad\quad\quad\quad $a^{2^1}$ = $a^{2^{0}*2}$ = $(a^{2^0})^{2}$}\\[0.3ex]
> a^{2^2} \text{ mod p} \text{\quad\quad\quad\quad $a^{2^2}$ = $a^{2^{1}*2}$ = $(a^{2^1})^{2}$}\\[0.3ex]
> \text{\quad\quad$\vdots$ }\\[0.3ex]
> a^{2^{log_{2}k}} \text{ mod p} \text{\quad\quad\quad\quad $a^{2^{log_{2}k}}$ = $(a^{2^{log_{2}k}-1})^{2}$}\\[0.3ex]
> \end{cases}
> $$
> $a^k$ = $a^{2^{x_1}}$ * $a^{2^{x_2}}$ $\cdots$ $a^{2^{x_t}}$
>
>   = $a^{2^{x_1}+2^{x_2}+2^{x_3}+\cdots+2^{x_t}}$



```c++
//快速幂模板
//求 (m^k)%p

int qmi(int m,int k,int p)
{
    int res=1%p,t=m;
    while(k)
    {
        if(k&1)res=res*t%p;
        t=t*t%p;
        k>>=1;
    }
    return res;
}
```





___

### 扩展欧几里得算法

> 裴蜀定理: 对于任意正整数a, b, 一定存在非零整数x, y, 使得 ax + by = gcd (a, b) 



```c++
//扩展欧几里得算法模板
//求x,y,使得ax+by=gcd(x,y)

int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1,y=0;
        return a;
    }
    
    int d=exgcd(b,a%b,y,x);
    y-=(a/b)*x;
    return d;
}
```



<div style="page-break-after:always;"></div>

# 高斯消元

> 用 $O(n^3)$ 时间复杂度, 求解含有 n 个方程的 n 元线性方程组
> $$
> \begin{cases}
> a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1\\[1ex]
> a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2\\[1ex]
> \quad\quad\quad\quad\quad\quad\quad \vdots \\[1ex]
> a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n = b_n\\[1ex]
> \end{cases}
> $$
> 枚举每一列 c
>
> ① 找到绝对值最大的一行
>
> ② 将该行换到最上面
>
> ③ 将该行第1个数变成1
>
> ④ 将下面所有行的第c列消成0



```c++
//高斯消元解线性方程组模板

//a[N][N]是增广矩阵
int gauss()
{
    int c,r;
    for(c=0,r=0,c<n;c++)
    {
        int t=r;
        for(int i=r;i<n;i++)	//找到绝对值最大的行
            if(fabs(a[i][c])>fabs(a[t][c]))
                t=i;
        if(fabs(a[t][c])<eps)continue;
        
        for(int i=c;i<=n;i++)swap(a[t][i],a[r][i]);
        //将绝对值最大的行换到最顶端
        for(int i=n;i>=c;i--)a[r][i]/=a[r][c];
        //将当前行的首位变成1
        for(int i=r+1;i<=n;i++)	//用当前行将下面所有的列消成0
            if(fabs(a[i][c])>eps)
                for(int j=n;j>=c;j--)
                    a[i][j]-=a[r][j]*a[i][c];
        
        r++;
    }
    if(r<n)
    {
        for(int i=r;i<n;i++)
            if(fabs(a[i][n])>eps)
                return 2;	//无解
        return 1;	//有无穷多解
    }
    
    for(int i=n-1;i>=0;i--)
        for(int j=i+1;j<n;j++)
            a[i][n]-=a[i][j]*a[j][n];
    return 0;	//唯一解
}
```



<div style="page-break-after:always;"></div>

# 组合计数

> 组合数
>
> $C^m_n$ = $\dfrac{n (n-1) (n-2) \cdots (n-m+1)}{m!}$ = $\dfrac{n!}{m! (n-m)!}$
>
> $C^m_n$ = $C^m_{n-1}$ +$C^{m-1}_{n-1}$



---

### 递推法求组合数

[求组合数Ⅰ](https://www.acwing.com/problem/content/887/)    $C^m_n$ = $C^m_{n-1}$ +$C^{m-1}_{n-1}$

```c++
//递推法求组合数模板

//c[a][b]存储C_a^b的方案数
for(int i=0;i<N;i++)
    for(int j=0;j<=i;j++)
        if(j==0)c[i][j]=1;
		else c[i][j]=c[i-1][j]+c[i-1][j-1];
```





---

### 预处理逆元求组合数

> 首先预处理出所有阶乘取模的余数 fact[N] , 以及所有阶乘取模的逆元 infact[N] 
>
> 如果取模的数是质数, 可以用费马小定理求逆元



[求组合数Ⅱ](https://www.acwing.com/problem/content/888/)     $C^m_n$ = $\dfrac{n!}{m!(n-m)!}$

````c++
//快速幂模板
int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&1)res=(long long)res*a%p;
        a=a*a%p;
        k>>=1;
    }
    return res;
}

//预处理阶乘的余数和阶乘余数的逆元
fact[0]=infact[0]=1;
for(int i=1;i<N;i++)
{
    fact[i]=(long long)fact[i-1]*i%mod;
    infact[i]=(long long)infact[i-1]*qmi(i,mod-2,mod)%mod;
}
````





---

### Lucas定理

> Lucas定理: 若p是质数, 则对于任意整数 1 $\le$ m $\le$ n , 有:
>
> $C^m_n$ $\equiv$ $C^{m\%p}_{n\%p}$  $\cdot$ $C^{m/p}_{n/p}$    (mod p)



[求组合数Ⅲ](https://www.acwing.com/problem/content/889/)        $C^m_n$ $\equiv$ $C^{m\%p}_{n\%p}$  $\cdot$ $C^{m/p}_{n/p}$    (mod p)

```c++
//快速幂模板
int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&1)(long long)res=res*a%p;
        a=(long long)a*a%p;
        k>>=1;
    }
    return res;
}

//通过定理求组合数C_a^b
int C(int a,int b,int p)
{
    if(a<b)return 0;
    
    long long x=1,y=1;	//x是分子,y是分母
    for(int i=a,j=1;j<=b;i--,j++)
    {
        x=(long long)x*i%p;
        y=(long long)y*j%p;
    }
    
    return x*(long long)qmi(y,p-2,p)%p;
}

int Lucas(long long a,long long b,int p)
{
    if(a<p&&b<p)return C(a,b,p);
    return (long long)C(a%p,b%p,p)*Lucas(a/p,b/p,p)%p;
}
```





___

### 分解质因数法求组合数

> 当我们需要求出组合数的真实值, 而非对某个数的余数时, 分解质因数的方式比较好用:
>
> ① 筛法求出范围内的所有质数
>
> ② 通过 $C^b_a$ = $\dfrac{a!}{b!(a-b)!}$ 这个公式求出每个质因子的次数
>
>    n ! 中 p 的次数是 [ $\dfrac{n}{p}$ ] + [ $\dfrac{n}{p^2}$ ] + $\cdots$ 
>
> ③ 用高精度乘法将所有质因子相乘



[求组合数Ⅳ](https://www.acwing.com/problem/content/890/)

```c++
int primes[N],cnt;	//存储所有质数
int sum[N];		//存储每个质数的次数
bool st[N];		//存储每个数是否已被筛掉

void get_primes(int n)	//线性筛法求素数
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++)
        {
            st[primes[j]*i]=true;
            if(i%primes[j]==0)break;
        }
    }
}

int get(int n,int p)	//求n!中p的次数
{
    int res=0;
    while(n)
    {
        res+=n/p;
        n/=p;
    }
    return res;
}

vector<int> mul (vector<int>a, int b)	//高精度乘低精度模板
{
    vector<int>c;
    int t=0;
    for(int i=0;i<a.size();i++)
    {
        t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    while(t)
    {
        c.push_back(t%10);
        t/=10;
    }
    return c;
}

get_primes(a);	//预处理范围内的所有质数

for(int i=0;i<cnt;i++)	//求每个质因数的次数
{
    int p=primes[i];
    sum[i]=get(a,p)-get(b,p)-get(a-b,p);
}

vector<int>res;
res.push_back(1);

for(int i=0;i<cnt;i++)		//用高精度乘法将所有质因子相乘
    for(int j=0;j<sum[i];j++)
        res=mul(res,primes[i]);
```





---

### 卡特兰数

> 给定n个0和n个1, 它们按照某种顺序排成长度为2n的序列, 满足任意前缀中0的个数都不少于1的个数的序列的数量为:
>
> Cat (n) = $C^n_{2n}$ - $C^{n-1}_{2n}$ = $\dfrac{C^n_{2n}}{n+1}$ 



<div style="page-break-after:always;"></div>

# 简单博弈论

### 容斥原理

> 设 S~1~ , S~2~ , $\ldots$ , S~n~ 为有限集合, |S| 表示集合S的大小, 则:
>
> |$\bigcup\limits_{i=1}^n\ S_i$| = $\sum\limits_{i=1}^n\ | S_i |$ - $\sum\limits_{1 \leqslant i \lt j \leqslant n}\ |S_i\bigcap S_j|$ + $\sum\limits_{1 \leqslant i \lt j \lt k \leqslant n}\ |S_i \bigcap S_j \bigcap S_k |$ $\cdots$ + $(-1)^{n+1}$ $\cdot$ $|S_1 \bigcap \cdots \bigcap S_n |$

> 位运算: 用 $2^m$ 的二进制数 $\underbrace{01011\cdots0011}_{m位}$ 来表示集合被选择的情况





---

### NIM 游戏

> 给定N堆物品, 第 i 堆物品有 $A_i$ 个. 两名玩家轮流行动, 每次可以任选一堆, 取走任意多个物品, 可把一堆取光, 但不能不取. 取走最后一件物品者获胜. 两人都采取最优策略, 问先手是否必胜.

> 我们把这种游戏称为 NIM 博弈. 把游戏过程中面临的状态称为局面. 整局游戏第一个行动的称为先手, 第二个行动的称为后手. 若在某一局面下无论采取何种行动, 都会输掉游戏, 则称该局面必败. 所谓采取最优策略是指, 若在某一局面下存在某种行动, 使得行动后对面面临必败局面, 则优先采取该行动. 同时, 这样的局面被称为必胜. 我们讨论的博弈问题一般都只考虑理想情况, 即两人均无失误, 都采取最优策略行动时游戏的结果.

> NIM 博弈不存在平局, 只有先手必胜和先手必败两种情况.



> **定理: NIM博弈先手必胜, 当且仅当 $A_1$ ^ $A_2$ ^ $\cdots$ ^ $A_n$ != 0**

> 必胜局面: 存在一种行动, 使得下一步必为必败局面.
>
> 必败局面: 无论进行何种行动, 下一步必为必胜局面.
>
> $A_1$ ^ $A_2$ ^ $\cdots$ ^ $A_n$ != 0 (必胜): 存在一种操作, 操作后 $A_1$ ^ $A_2$ ^ $\cdots$ ^ $A^{'}_i$ ^ $\cdots$ ^ $A_n$ == 0
>
> $A_1$ ^ $A_2$ ^ $\cdots$ ^ $A_n$ == 0 (必败): 任何一种操作后都有 $A_1$ ^ $A_2$ ^ $\cdots$ ^ $A^{'}_i$ ^ $\cdots$ ^ $A_n$ != 0





---

### 公平组合游戏 ICG

> 若一个游戏满足:
>
> 1. 由两名玩家交替行动
> 2. 在游戏进行过程的任意时刻, 可以执行的合法行动与轮到哪名玩家无关
> 3. 不能行动的玩家判负
>
> 则称该游戏为一个公平组合游戏.

> NIM 博弈属于公平组合游戏, 但城建的棋类游戏, 比如围棋, 就不是公平组合游戏. 因为围棋交战双方只能落黑子或和白子, 胜负判定也比较复杂, 不满足条件2和条件3





---

### 有向图游戏

> 给定一个有向无环图, 图中有一个唯一的起点, 在起点上放有一枚棋子. 两名玩家交替地把这枚棋子沿有向边进行移动, 每次可以移动一步, 无法移动者判负. 该游戏被称为有向图游戏.

> 任意一个公平组合游戏都可以转化为有向图游戏. 具体方法是, 把每个局面看成图中的一个节点, 并且从每个局面向沿着合法行动能够到达的下一个局面连有向边





---

### Mex 运算

> 设S表示一个非负整数集合. 定义 mex (S) 为求出不属于集合S的最小自然数的运算, 即: mex (S) = min {x} , x属于自然数, 且x不属于S





---

### SG 函数

> 在有向图游戏中, 对于每个节点 x , 设从 x 出发共有 k 条有向边, 分别到节点 $y_1$ , $y_2$ , $\ldots$ ,$y_k$ , 定义SG (x) 为x的后继节点 $y_1$ , $y_2$ , $\ldots$ , $y_k$ 的 SG 函数值构成的集合再执行 mex (S) 运算的结果, 即:
>
> SG (x) = mex ({ SG($y_1$) , SG($y_2$) , $\cdots$ , SG($y_k$) })
>
> 特别地, 整个有向图游戏G的 SG 函数值被定义为有向图起点S的 SG 函数值, 即 SG(G) = SG(s)





---

### 有向图游戏的和

> 设 $G_1$ , $G_2$ , $\cdots$ , $G_m$ 是m个有向图游戏. 定义有向图游戏G, 它的行动规则是任选某个有向图游戏 $G_i$ , 并在 $G_i$ 上行动一步. G被称为有向图游戏 $G_1$ , $G2$ , $\cdots$ , $G_m$ 的和.
>
> 有向图游戏的和的 SG 函数值等于它包含的各个子游戏 SG 函数值的异或和, 即 SG(G) = SG($G_1$) ^ SG($G_2$) ^ $\cdots$ ^ SG($G_k$)



> **定理: 有向图游戏的某个局面必胜, 当且仅当该局面对应节点的SG函数值大于0**
>
>    $\quad$$\quad$**有向图游戏的某个局面必败, 当且仅当该局面对应节点的SG函数值等于0**



<div style="page-break-after:always;"></div>

# 背包问题

> 背包问题是一种组合优化的NP完全问题. 问题可以描述为: 给定一组物品, 每种物品都有自己的体积和价值, 在限定的总体积内, 我们如何选择, 才能使得物品的总价值最高.



### 背包九讲

> ① 01背包问题
>
> 有 `N` 件物品和一个容量是 `V` 的背包, 每件物品只能使用一次
>
> 第 `i` 件物品的体积是 `vi` , 价值是 `wi` 
>
> 求解将哪些物品装入背包, 可使这些物品的总体积不超过背包容量, 且总价值最大

> ② 完全背包问题
>
> 有 `N` 种物品和一个容量是 `V` 的背包, 每种物品都有无限件可用
>
> 第 `i` 件物品的体积是 `vi` , 价值是 `wi`
>
> 求解将哪些物品装入背包, 可使这些物品的总体积不超过背包容量, 且总价值最大

> ③ 多重背包问题
>
> 有 `N` 种物品和一个容量是 `V` 的背包
>
> 第 `i` 种物品最多有 `si` 件, 每件体积是 `vi` , 价值是 `wi`
>
> 求解将哪些物品装入背包, 可使物品体积总和不超过背包容量, 且总价值最大

> ④ 混合背包问题
>
> 有 `N` 种物品和一个容量是 `V` 的背包
>
> 物品一共有三类:
>
> 第一类物品只能用一次 (01背包)
>
> 第二类物品可用无限次 (完全背包)
>
> 第三类物品最多只能用 `si` 次 (多重背包)
>
> 第 `i` 种物品, 每件体积是 `vi` , 价值是 `wi`
>
> 求解将哪些物品装入背包, 可使物品体积总和不超过背包容量, 且价值总和最大

> ⑤ 二位费用的背包问题
>
> 有 `N` 件物品和一个容量是 `V` 的背包, 背包能承受的最大重量是 `M`
>
> 每件物品只能用一次, 体积是 `vi` , 重量是 `mi` , 价值是 `wi` 
>
> 求解将哪些物品装入背包, 可使物品总体积不超过背包容量, 总重量不超过背包可承受的最大重量, 且价值总和最大

> ⑥ 分组背包问题
>
> 有 `N` 组物品和一个容量是 `V` 的背包
>
> 每组物品有若干个, 同一组内的物品最多只能选一个
>
> 每件物品的体积是 `vij` ,价值是 `wij` ,其中 `i` 是组号, `j` 是组内编号
>
> 求解将哪些物品装入背包, 可使物品总体积不超过背包容量, 且总价值最大

> ⑦ 有依赖的背包问题(树上背包问题)
>
> 有 `N` 件物品和一个容量是 `V` 的背包
>
> 物品之间具有依赖关系, 且依赖关系组成一棵树的性质. 如果选择一个物品, 则必须选择它的父节点
>
> 每件物品的编号是 `i` , 体积是 `vi` , 价值是 `wi` , 依赖的父节点编号是 `pi` .物品的下标范围是 1 ~ N
>
> 求解将哪些物品装入背包, 可使物品总体积不超过背包容量, 且总价值最大

> ⑧ 背包问题求方案数
>
> 有 `N` 件物品和一个容量是 `V` 的背包, 每件物品只能用一次
>
> 第 `i` 件物品的体积是 `vi` , 价值是 `wi`
>
> 求解将哪些物品装入背包, 可使这些物品的总体积不超过背包容量, 且总价值最大
>
> 输出最优选法的方案数

> ⑨ 背包问题求具体方案
>
> 有 `N` 件物品和一个容量是 `V` 的背包, 每件物品只能用一次
>
> 第 `i` 件物品的体积是 `vi` , 价值是 `wi`
>
> 求解将哪些物品装入背包, 可使这些物品的总体积不超过背包容量, 且总价值最大
>
> 输出字典序最小的方案, 这里的字典序是指所选物品的编号所构成的序列, 物品的编号范围是 1 ~ N





---

### 01背包问题

```c++
//朴素版解法
int dp[N][N];	//dp[i][j]表示前i个物品,背包容量是j的情况下的最大价值
int w[N],v[N];

for(int i=1;i<=n;i++)
    for(int j=0;j<=m;j++)
    {
        dp[i][j]=dp[i-1][j];
        if(j>=v[i])dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]]+w[i]);
    }
```



```c++
//滚动数组优化
int dp[N];
int v[N],w[N];

for(int i=1;i<=n;i++)
    for(int j=m;j>=v[i];j--)
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
```





---

### 完全背包问题

```c++
//朴素版未优化
int dp[N][N];
int v[N],w[N];

for(int i=1;i<=n;i++)
    for(int j=0;j<=m;j++)
        for(int k=0;k*v[i]<=j;k++)
            dp[i][j]==max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
```



```c++
//朴素解法
int dp[N][N];
int v[N],w[N];

for(int i=1;i<=n;i++)
    for(int j=0;j<=m;j++)
    {
        dp[i][j]=dp[i-1][j];
        if(v[i]<=j)dp[i][j]=max(dp[i][j],dp[i][j-v[i]]+w[i]);
    }
```



```c++
//优化空间版解法
int dp[N];
int v[N],w[N];

for(int i=1;i<=n;i++)
    for(int j=v[i];j<=m;j++)
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
```





---

### 多重背包问题

```c++
//朴素版解法
int dp[N][N];
int v[N],w[N],s[N];

for(int i=1;i<=n;i++)
    for(int j=0;j<=m;j++)
        for(int k=0;k<=s[i]&&k*v[i]<=j;k++)
            dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
```



> 二进制优化: 将 s[i] 个物品拆分成 $log_2$ s[i] 份, 作01背包问题

```c++
//二进制优化
int dp[N];
int v[N],w[N];

int cnt=0;
for(int i=1;i<=n;i++)
{
    int a,b,s;
    cin>>a>>b>>s;
    int k=1;
    while(k<=s)
    {
        cnt++;
        v[cnt]=a*k;
        w[cnt]=b*k;
        s-=k;
        k*=2;
    }
    if(s>0)
    {
        cnt++;
        v[cnt]=a*s;
        w[cnt]=b*s;
    }
}
n=cnt;

for(int i=1;i<=n;i++)
    for(int j=m;j>=v[i];j--)
        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
```





---

### 混合背包问题

```c++
int n,m;					//si=-1表示第i种物品只能用1次
int v[N],w[N],s[N];			//si=0表示第i种物品可以用无限次
int dp[N];					//si>0表示第i种物品可以用si次

struct Good
{
    int kind;
    int v,w;
};

vector <Good> good;

int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>s[i];
    for(int i=0;i<n;i++)
    {
        if(s[i]==-1)good.push_back({-1,v[i],w[i]});
        else if(s[i]==0)good.push_back({0,v[i],w[i]});
        else //多重背包二进制优化（分组）后，对于每一组都相当于是01背包
        {
            for(int k=1;k<=s[i];k*=2)
            {
                s[i]-=k;
                good.push_back({-1,v[i]*k,w[i]*k});
            }
            if(s[i]>0)good.push_back({-1,v[i]*s[i],w[i]*s[i]});
        }
    }
    
    //对于01背包和完全背包分两种情况状态转移即可
    for(auto goods:good)
    {
        //01背包
        if(goods.kind==-1)
        {
            for(int j=m;j>=goods.v;j--)
                dp[j]=max(dp[j],dp[j-goods.v]+goods.w);
        }
        //完全背包
		else
        {
            for(int j=goods.v;j<=m;j++)
                dp[j]=max(dp[j],dp[j-goods.v]+goods.w);
        }
    }
    
    cout<<dp[m]<<endl;
    return 0;
}
```





---

### 二位费用的背包问题

```c++
//dp[i][j]表示总体积是i，总重量是j的情况下，最大价值是多少
//同时对于状态转移的时候，两层for循环，一层是体积限制，一层是重量限制

int a,b,c;	//a为物品数量，b为背包最大容量，c为背包最大重量
int v[N],t[N],w[N];
int dp[N][N];

for(int i=0;i<a;i++)
    for(j=b;j>=v[i];j--)
        for(int k=c;k>=t[i];k--)
            dp[j][k]=max(dp[j][k],dp[j-v[i]][k-t[i]]+w[i]);
```





---

### 分组背包问题

```c++
int dp[N];
int v[N][N],w[N][N],s[N];

for(int i=1;i<=n;i++)
    for(int j=m;j>=0;j--)
        for(int k=0;k<s[i];k++)
            if(v[i][k]<=j)dp[j]=max(dp[j],dp[j-v[i][k]]+w[i][k]);
```





---

### 树上背包问题

> 特点: `N` 个物品, `V` 容量的背包, 物品之间有依赖关系, 且依赖关系可以构成一棵树, 如果选择某一个物品, 那么就必须选择这个物品的父亲物品

> 父节点编号范围:
>
> 内部节点: 1 $\leqslant$ $p_i$ $\leqslant$ N
>
> 根节点 $p_i$ = -1

> `dp[i][j]` 表示选择节点 `i` (在这里也就是根节点), 总体积是 `j` 时, 最大价值是多少. 当我们选择根节点后, 对于根节点的每一棵子树, 都相当于对根节点做分组背包了, 每一个根节点相当于一个组, 对于组内的节点分为选择或者不选择



```c++
int n,m;
int v[N],w[N];
int dp[N][N];
int h[N],e[N],ne[N],idx;

void add (int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void dfs (int u)
{
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int son=e[i];
        dfs(son);
        for(int j=m-v[u];j>=0;j--)
            for(int k=0;k<=j;k++)
                dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[son][k]);
    }
    
    //将根节点u加上
    for(int i=m;i>=v[u];i--)
        dp[u][i]=dp[u][i-v[u]]+w[u];
    //如果选择了子节点后,还没有选择到最后的root,那么就不能选择当前节点及其根节点了
    for(int i=0;i<v[u];i++)
        dp[u][i]=0;
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);
    
    int root;
    for(int i=1;i<=n;i++)
    {
        int p;
        cin>>v[i]>>w[i]>>p;
        if(p==-1)root=i;
        else add(p,i);
    }
    
    dfs(root);
    cout<<dp[root][m]<<endl;
    return 0;
}
```





---

### 背包问题求方案数

> 特点: 在背包问题下, 求出最优选法的方案数

> `f[j]` 表示体积恰好是 `j` 的情况下, 最大价值是多少
>
> `g[j]` 表示体积恰好是 `j` 的情况下, 方案数是多少
>
> 这个地方的 `f[]` 数组的含义与前面的背包问题不一样, 所有在这里的初始化, 也与前面不同
>
> `f[0 - N]` = - $\infty$ , `f[0]` = 0 , `g[0]` = 1



```c++
const int mod=1e9+7;
const int INF=0x3f3f3f3f;

int n,m;
int v[N],w[N];
int f[N],g[N];

int main()
{
    cin>>n>>m;
    g[0]=1;
    for(int i=1;i<=m;i++)f[i]=-INF;
    for(int i=0;i<n;i++)cin>>v[i]>>w[i];
    
    for(int i=0;i<n;i++)
        for(int j=m;j>=v[i];j--)
        {
            int t=max(f[j],f[j-v[i]]+w[i]);
            int s=0;
            if(t==f[j])s+=g[j];
            if(t==f[j=v[i]]+w[i])s+=g[j-v[i]];
            if(s>=mod)s-=mod;
            f[j]=t;
            g[j]=s;
        }
    
    int maxx=0;
    for(int i=0;i<=m;i++)maxx=max(maxx,f[i]);
    int ans=0;
    for(int i=0;i<=m;i++)
        if(maxx==f[i])
        {
            ans+=g[i];
            if(ans>=mod)ans-=mod;
        }
    
    cout<<ans<<endl;
    return 0;
}
```





---

### 背包问题求具体方案

> 特点: 在普通背包的基础下, 输出选择方案

> 我们要输出所选的方案, 首先我们按照普通背包的问题求解后, 我们会得到 `dp[]` 数组, 因此如果我们要求出选择了哪一些物品, 我们就可以对 `dp[]` 数组进行反推
>
> 如果 `dp[i][j]` = `dp[i-1][j]` , 说明没有选择第 `i` 个物品
>
> 如果 `dp[i][j]` = `dp[i-1][j-v[i]]` + `w[i]` , 说明选择了第 `i` 个物品
>
> 这个题目为了解唯一, 它的答案方案是字典序最小的方案, 因此我们可以按照贪心的思想去做, 如果能选择第 `i` 个物品, 那么我们就直接选择第 `i` 个物品, 而不选第 `i+1` 个物品(如果选择第 `i` 个物品和第 `i+1` 个物品所得的最大价值相同的话)
>
> 所以正确思路是我们按 `n` $\to$ `1` 的顺序求解01背包, 接着按 `1` $\to$ `n` 的顺序反推每个物品是否被选



```c++
int n,m;
int v[N],w[N];
int dp[N][N];

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    
    for(int i=n;i>=1;i--)
        for(int j=0;j<=m;j++)
        {
            dp[i][j]=dp[i+1][j];
            if(j>=v[i])dp[i][j]=max(dp[i][j],dp[i+1][j-v[i]]+w[i]);
        }
    
    int vol=m;
    for(int i=1;i<=n;i++)
        if(vol-v[i]>=0&&dp[i][vol]==dp[i+1][vol-v[i]]+w[i])
        {
            cout<<i<<' ';
            vol-=v[i];
        }
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 常见dp问题

> dp的引入
>
> 动态规划(简称dp), 是指把一个问题分解为若干个子问题, 通过局部最优解得到全局最优的一种算法策略或者说一种思想方法. 简单来讲, 就是用一个数组表示我们要求的问题的答案, 如果知道前一个问题的答案, 就可以推出后一个问题的答案

> dp有以下几个常见的概念:
>
> 1. 状态: 指当前所考虑的子问题的情况. 例如背包的已用体积, 区间的起止点, 以及用状态压缩手段压缩后的状态
> 2. 状态转移: 指由前一个子问题的答案推出当前问题的答案. 一般来讲会由一个表示赋值的等式给出, 称为状态转移方程
> 3. 无后效性: 指当前子问题的处理策略与后边问题的解答无关. 要记住我们是从子问题的答案推出新问题的答案, 与这个子问题的答案怎么来无关

> dp一般有以下三个步骤:
>
> 1. 设计状态: 指设计出合适的dp数组以及规定dp数组的含义. 设计出的dp数组要能够形容各种状态并且能无后效性地在状态之间进行转移
> 2. 推理状态转移方程: 顾名思义, 关键在于如何从已知问题的答案推出当前问题的答案, 有的时候需要多个方程, 有的时候一个方程要包含多个子状态
> 3. 确定边界条件: 递推的初值或者说记忆化搜索的回溯条件, 以及各个数组的初值





---

### 基础线性dp

> 线性dp往往指在一个序列上进行的dp, 当然也可能有两个甚至多个序列. 一般来讲, 线性dp的三个步骤分别有以下特点:
>
> 设计状态: 至少有一维表示当前考虑的对象在数列上的位置
>
> 状态转移: 必须找到这条线上前面的位置的dp值来推出当前位置的dp值
>
> 边界条件: 第一个位置单独讨论





---

### 基础区间dp

> 区间dp可以视作线性dp的一个分支, 之所以把它单独列出来是因为区间dp的解法比较特殊, 同时也比较固定. 区间dp与其他线性dp不同的地方在于它的状态是以序列上的一个区间来表示的, 而且大区间的答案可以由小区间的答案得到

> 区间dp的基本思路:
>
> 设计状态: 至少要有 `dp[l][r]` 两维分别表示区间的左端点和右端点
>
> 状态转移: 一般通过枚举区间 `[l,r]` 之间的点 `k` 把 `[l,r]` 分成 `[l,k]` 和 `[k+1,r]` , 然后用`dp[l][k]` 和 `dp[k+1][r]` 推出 `dp[l][r]` 
>
> 边界条件: 区间 `l==r` 时, `dp[l][r]` 可以从 `a[l]` 得出(或者为初值)

> 区间dp的枚举顺序往往很有趣. 根据dp顺序的原则, 执行赋值时等号右边的dp值一定要是已经算出来了的结果. 所以如果只是简单地从 `1~n` 分别枚举 `l` , `r` , `k` 就会出错, 这里给出两种常用的枚举方法:
>
> 1. 首先枚举区间长度 `len` : `1` ~ `n` , 然后枚举起点 `l` : `1` ~ `n` , 这样可以算出终点 `r = l + len -1` , 最后枚举断点 `k` : `l` ~ `r` . 注意终点 `r` 不能大于序列总长度 `n` 
> 2. 首先倒序枚举起点 `l` : `n` ~ `1` , 然后枚举终点 `r` : `l` ~ `n` , 最后枚举断点 `k` : `l` ~ `r` 
>
> 如果两种枚举都不喜欢, 那么也可以用记忆化搜索





---

### 计数类dp

> 所谓计数类dp就是常说的统计可行解数目的问题, 区别于求解最优解, 此类问题需要统计所有满足条件的可行解, 而求解最优解的dp问题往往只需要统计子问题时满足不漏的条件即可, 但是计数类dp需要满足不重不漏的条件, 是约束最高的

> 我们要求解此类问题一个重要的点就是如何划分子问题, 然后做到不重不漏, 大部分情况下我们想到的方法, 同一个解可能会被多次统计, 这是不合理的





---

### 数位统计dp

> 数位是指把一个数字按个、十、百、千等等一位位地拆开, 关注它每一位上的数字. 如果拆的是十进制数, 那么每一位数字都是 `0` ~ `9` , 其他进制可类比十进制

>数位dp: 用来解决一类特定问题, 这种问题比较好辨认, 一般具有这几个特征:
>
>1. 要求统计满足一定条件的数的数量(即, 最终目的为计数)
>2. 这些条件经过转化后可以使用 `数位` 的思想去理解和判断
>3. 输入会提供一个数字区间(有时也只提供上界)来作为统计的限制
>4. 上界很大(比如 $10^{18}$ ), 暴力枚举验证会超时

> 数位dp的基本原理:
>
> 考虑人类计数的方式, 最朴素的计数就是从小到大依次加一. 但我们发现对于位数比较多的数, 这样的过程中有许多重复的部分. 例如, 从 `7000` 数到 `7999` , 从 `8000` 数到 `8999` 和从 `9000` 数到 `9999` 的过程非常相似, 它们都是后三位从 `000` 变到 `999` , 不一样的地方只有千位这一位, 所以我们可以把这些过程归并起来, 将这些过程中产生的计数答案也都存在一个通用的数组里. 此数组根据题目具体要求设置状态, 用递推或dp的方式进行状态转移

> 数位dp中通常会利用常规计数的技巧, 比如把一个区间内的答案拆成两部分相减 (即 `ans[l,r] = ans[0,r] - ans[0,l-1]` )
>
> 那么有了通用答案数组, 接下来就是统计答案. 统计答案可以选择记忆化搜索, 也可以选择循环迭代递推. 为了不重不漏地统计所有不超过上限的答案, 要从高到低枚举每一位, 再考虑每一位都可以填哪些数字, 最后利用通用答案数组统计答案





---

### 状态压缩dp

> dp的时候需要设计状态, 但是有的状态会很复杂. 对于复杂的状态, 也许就不能再像以前那样用一个 `i` 简单表示. 或许这个状态表示一个有 n (n $\leqslant$ 16)个元素的集合, 甚至包含了每一个元素的情况. 为了应对这种情况, 我们可以利用状态压缩和位运算, 让一个数字表示一个集合.

> 状态压缩dp也需要三个步骤:
>
> 设计状态: 至少有一维是用一个数字(二进制)表示一个集合
>
> 状态转移: 考察每一个决策对集合的影响, 经常使用位运算进行转移
>
> 边界条件: 当集合为空或者说只有一个元素之类的
>
> 特别注意: 状态压缩是指数级的算法, 所以适合状态压缩的题往往有一个维度的数字很小(比如 n $\leqslant$ 12 , n $\leqslant$ 16)





---

### 树形dp

> 设计状态: 至少有一维表示当前正在考虑的树上节点 `p`
>
> 状态转移: 一般使用递归(深搜)由 `p` 的子节点的dp值得出 `p` 的dp值
>
> 边界条件: 叶子节点没有儿子, 可以只由叶子节点的值得出叶子的dp值



<div style="page-break-after:always;"></div>

# 记忆化搜索

> 搜索的低效在于没有能够很好地处理重叠子问题; 动态规划虽然比较好地处理了重叠子问题, 但是在有些拓扑关系比较复杂的题目面前, 又显得无奈. 记忆化搜索正是在这样的情况下产生的, 它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起



> **`记忆化搜索` = `搜索的形式` + `动态规划的思想`**



> 动态规划, 就是一个最优化问题, 先将问题分解为子问题, 并且对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案, 要不然的话就能找到一个更优的解来替代这个解, 得出新的最优子问题, 这当然和前提是矛盾的. 动态规划不同于贪心算法, 因为贪心算法是从局部最优来解决问题, 而动态规划是全局最优的. 用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策, 而是必须等待子问题得到了最优解之后才对当下的情况做出决策, 所以往往动态规划都可以用一个或多个递归式来描述. 而贪心算法却是先做出一个决策, 然后再去解决子问题. 这就是贪心和动态规划的不同
>
> 动态规划的一种变形就是记忆化搜索, 就是根据动态规划方程写出递归式, 然后在函数的开头直接返回以前计算过的结果, 当然这样做也需要一个存储结构记下前面计算过的结果(**空间换时间**), 所以又称记忆化搜索



<div style="page-break-after:always;"></div>

# 数字三角形模型

### 根题

>  [AcWing 898. 数字三角形](https://www.acwing.com/problem/content/900/)

> + 动态规划
>   + 状态表示 `f[i, j]`
>     + 集合: 所有从起点出发, 走到 $(i, j)$ 的路径
>     + 属性: 集合当中所有路径上的数总和的最大值 $Max$
>   + 状态计算
>     + 划分: 从左上方到 $(i, j)$ 和从右上方到 $(i, j)$
>     + 方程: `f[i, j] = max (f[i-1, j-1], f[i-1, j]) + a[i,j]`

<br>

### 衍生题

>  [AcWing 1015. 摘花生](https://www.acwing.com/problem/content/1017/)

> 传统DP问题思考角度: 阶段、决策、最优子结构、无后效性
>
> 闫氏思考法: 从集合角度思考DP
>
> + 状态表示 `f[i, j]`
>   + 集合: 所有从 $(1, 1)$ 走到 $(i, j)$ 的路线
>   + 属性: 最大值
>     + ==一般有最大值、最小值、数量==
> + 状态计算
>   + 集合划分: 最后一步是从上面下来和最后一步是从左边过来
>     + ==一般根据"最后一个操作" (最后一步, 最后取的物品等)==
>     + ==原则: 不重复 (求数量时一定要满足, 求最值不需要满足); 不漏 (一定要满足)==
>   + 转移方程: `f[i, j] = max (f[i-1, j], f[i, j-1]) + g[i, j]`
>     + ==可以将状态转移写成一个图, 以 `f[i, j]` 为起点, 子节点为 `f[i-1, j]`、`f[i, j-1]` , 以此类推. 计算时需要按照图的拓扑序来计算 (线性DP问题只需要按照下标从1开始循环计算就可以满足)==
>
> <br>
>
> `f[i][j]` 表示到达第 $i$ 行第 $j$ 列这个格子时可以获得的最大花生数
>
> 故状态转移方程为: `f[i][j] = max (f[i-1][j], f[i][j-1]) + a[i][j]`

<br>

> [AcWing 1018. 最低通行费](https://www.acwing.com/problem/content/1020/)

> $2n-1$ 意味着只能向右和向下走, 因此和摘花生的题是一样的.
>
> 但由于是求最小值, 所以需要对第一行和第一列做预处理.
>
> <br>
>
> `f[i][j]` 表示到达第 $i$ 行第 $j$ 列这个格子时的最低通行费
>
> 故状态转移方程为: `f[i][j] = min (f[i-1][j], f[i][j-1]) +a[i][j]` 

<br>

> [AcWing 1027. 方格取数](https://www.acwing.com/problem/content/1029/)

> + 状态表示
>
>   + 集合: `f[i, j, p, q]` 表示从 $(1, 1)$ , $(1, 1)$ 分别走到 $(i, j)$ , $(p, q)$ 的路径
>     + 可以令两条路径同时走, 满足 $i + j = p + q = k$ . 因此集合表示可以由四维优化成三维 `f[k, i, p]` , 表示从 $(1, 1)$ , $(1, 1)$ 分别走到 $(i, k-i)$ , $(p, k-p)$ 的路径
>     + 同时走有利于处理重合点的计算. 在转移状态时, 要考虑的重合情况只有 $i_1 = i_2$ 的情况, 路径上其他点的重合情况都被考虑过了
>   + 属性: 路径上经过的数总和的最大值
>
> + 状态计算
>
>   + 集合划分: 按照两条路径最后一步的方向划分
>
>   + 转移方程: `f[k][i][p] = max (f[k-1][i-1][p-1], f[k-1][i-1][p], f[k-1][i][p-1], f[k-1][i][p])` 
>
>     $\quad$ $\quad$ $\quad$ `if(i == p) f[k][i][p] += a[i][k-i];`
>
>     $\quad$ $\quad$ $\quad$ `else f[k][i][p] += a[i][k-i] + a[p][k-p];`



<div style="page-break-after:always;"></div>

# 最长上升子序列模型

### 闫氏DP分析法

> + 状态分析 `f[i]`
>   + 集合: 所有以 `a[i]` 结尾的严格单调上升子序列
>   + 属性: 子序列的最长长度
> + 状态计算
>   + 集合划分: 子序列倒数第二个数划分. 倒数第二个数是 `a[1]` 、`a[2]` 、`a[3]` $\dots$ `a[i-1]` 、空, 各是一类
>   + 转移方程: `if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1)`

<br>

---

### 根题

> [AcWing 895. 最长上升子序列](https://www.acwing.com/problem/content/897/)

> + 动态规划
>   + 状态表示 `f[i]`
>     + 维数原则: 一定要能把答案表示出来且能推出来, 在此基础上维数越小越好
>     + 集合: 所有以第 $i$ 个数结尾的上升子序列
>     + 属性: 集合里每一个上升子序列的长度的最大值
>   + 状态计算
>     + 划分: 以子序列倒数第二个数是否存在, 若存在, 则是数列中第几个数来划分
>     + 方程: 当 `a[j] < a[i]` 时, `f[i] = max(f[j] + 1)` $(0 \le j \le i - 1)$ , $j == 0$ 表示序列无倒数第二个数
>   + 输出子序列: 加一个数组 `g[N]` , 记录每个状态是由哪个状态转移过来的, 最后再沿着转移的轨迹输出序列
>     + `g[i] = j` 表示状态 $i$ 是由状态 $j$ 转移过来的 

<br>

> [AcWing 896. 最长上升子序列Ⅱ](https://www.acwing.com/problem/content/898/)

> + 优化: 去除冗余
>   + 状态计算, 从构建上升子序列的角度来看, 每一个子序列都是在更小的子序列后面加上一个符合要求的数得来的
>   + 因此我们可以从头开始, 先讨论只有一个数的最小子序列
>     + 对于 $a_i$ , $a_j$ , $a_i \ge a_j$ , 在 $a_i$ 后接续的子序列 (该序列第一个数在 $a_j$ 之后), 一定也可以接在 $a_j$ 后, 而在 $a_j$ 后接续的子序列却不一定能接续在 $a_i$ 后
>     + 所以 $a_j$ 是优于 $a_i$ 的, 因此考虑在长度为1的子序列后接续时, 考虑 $a_j$ 便不用考虑 $a_i$ 
>   + 按照上述的思想, 我们在考虑 `a[k]` 时, 可以把 `a[k]` 之前的数组成的不同长度的上升子序列的最小末尾值存下来. 要得出 `f[k]` , 可以通过二分查找在数组中找到 `a[k]` 能接上的最长子序列, 并更新其他子序列最小末尾值
>   + 可以证明, 存末尾值的数组中所有的数一定是严格上升序列, 否则一定由某长度的末尾值不是最小末尾值

<br>

### 衍生题

> [AcWing 1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)

> 这题就是求最长上升子序列和最长下降子序列长度的最大值.
>
> 正向反向跑两遍 $LIS$ 即可.
>
> <br>
>
> + 转移方程: `if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1)`

<br>

> [AcWing 1014. 登山](https://www.acwing.com/problem/content/1016/)

> 对于本题来说, 当前状态如果是上升状态, 则他下一阶段可以维持上升状态, 或者变成下降状态. 而对于已经处于下降状态来说的状态, 下一个阶段只能维持下降状态.
>
> <br>
>
> 思路一: 分别求最长上升子序列和最长下降子序列
>
> + 状态表示
>   + `f[i]` 表示所有以 `a[i]` 结尾的严格单调上升子序列
>   + `g[i]` 表示所有以 `a[i]` 开头的严格单调下降子序列
> + 状态属性
>   + 子序列的最长长度
> + 状态计算
>   + `if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1)` $(1 \le j \le i \le n)$
>   + `if(a[i] > a[i]) g[i] = max(g[i], g[j] + 1)` $(1 \le i \le j \le n)$
> + 答案表示
>   + 根据每一个点来划分: $ans = max$ (包含 $i$ 的最长上升子序列 + 最长下降子序列)
>   + `ans = max(f[i] + g[i] - 1)`
>
> <br>
>
> 思路二: 开二维数组记录当前状态 (上升/ 下降)
>
> + 状态表示 `f[i, j]`
>   + 集合: 当前状态为 $i$ (0为上升, 1为下降), 以 $j$ 结尾的所有路径
>   + 属性: 所有路径长度的最大值
> + 状态转移
>   + `if(a[j] < a[i]) f[0][i] = max(f[0][j] + 1, f[0][i]);`
>   + `if(a[j] > a[i]) f[1][i] = max(f[1][i], max(f[0][j] + 1, f[i][j] +1));`

<br>

> [AcWing 1012. 友好城市](https://www.acwing.com/problem/content/1014/)

> 分析题目可知, 对于选中的桥, 其南北两岸城市组成的序列, 都需要为严格单调上升子序列, 否则会出现桥与桥相交的情况.
>
> 因此, 本题的做法就是用 `pair` 存储一对友谊城市的坐标, 然后对南岸或北岸的坐标进行排序, 对另一岸形成的序列求 $LIS$ , 得到的就是最多的航线.

<br>

> [AcWing 1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)

> + 动态规划
>   + 状态表示 `f[i]` 
>     + 集合: 所有以 `a[i]` 结尾的上升子序列
>     + 属性: 集合里上升子序列的和的最大值
>   + 状态计算
>     + 集合划分: 以上升子序列的倒数第二个数划分
>     + 转移方程: `if(a[j] < a[i]) f[i] = max(f[i], f[j] + a[i])`

<br>

---

### 根题

> [AcWing 897. 最长公共子序列](https://www.acwing.com/problem/content/899/)

> + 动态规划
>
>   + 状态表示 `f[i, j]`
>
>     + 集合: 所有在第一个序列的前 $i$ 个字母中出现且在第二个序列的前 $j$ 个字母中出现的公共子序列
>     + 属性: 集合里的所有子序列长度的最大值
>
>   + 状态计算
>
>     + 集合划分: 以 `a[i]` 、`b[i]` 是否包含在子序列当中来划分, 共四种情况
>
>       + `a[i]` 、`b[j]` 都无: `f[i-1, j-1]`
>       + `a[i]` 、`b[j]` 都有: `f[i-1, j-1] + 1`
>       + 一有一无, 如果用 `f[i-1, j]` , `f[i, j-1]` 来表示, 很明显是不准确的, 虽然可以完全包含, 但会重复计算 `f[i-1, j-1]` . 动态规划划分集合的原则是不重不漏, 可遇到实际问题时, 原则不一定要严格遵守. 由于本题求的是最大值, 因此产生重复是完全不影响答案的, 于是我们仍然可以用 `f[i-1, j]` , `f[i, j-1]` 来表示 `a[i]` 、`b[j]` 一有一无的情况
>         + ==如果碰到集合属性是数量时, 那就要严格保证不重复==
>
>     + 转移方程: `f[i][j] = max(f[i - 1][j], f[i][j - 1]);`
>
>       $\quad$ $\quad$ $\quad$ `if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);`

<br>

### 衍生题

> [AcWing 1010. 拦截导弹](https://www.acwing.com/problem/content/1012/)

> 第一问: $LIS$
>
> 第二问: 贪心
>
> + 从前往后扫描每一个数, 对于每个数
>   + 如果现有的子序列的结尾都小于当前数, 则创建新子序列
>   + 将当前数放到结尾大于等于它的最小的子序列后面
> + 证明: $(A \le B \& B \le A \longrightarrow A = B)$ (调整法)
> + 最优解 ≤ 贪心解: 因为最优解是最少的导弹防御系统数, 所以最优解 ≤ 贪心解
> + 贪心解 ≤ 最优解: 假设贪心解与最优解不一样, 则按照求解的过程, 从前往后扫描每一个数, 找到第一个位置不一样的数 $x$ 
>   + 按照贪心放置的规则, 贪心解法中该数放在结尾大于等于它的最小的子序列后面. 设该数为 $a$ 
>   + 设最优解中该数放在以 $b$ 结尾的子序列后. 由贪心规则得, $a \le b$ 
>   + 设最优解中 $a$ 后面放置的是以 $y$ 为开头的子序列
>   + 因为 $a \le b$ , 所以以 $y$ 为开头的子序列可以接在 $b$ 后
>   + 按照以上分析, 我们可以进行如下调整: 将最优解中以 $x$ 开头的子序列放在 $a$ 后面, 以 $y$ 开头的子序列放在 $b$ 后
>   + 经过这样调整后, 我们不仅消除了两种方案中 $x$ 的位置的不一致, 同时并没有使最优解的序列数增加
>   + 以此类推, 我们可以从前往后扫描每一个数, 对最优解中每一个与贪心解位置不一样的数进行上述调整. 每一次调整均保证不增加最优解的序列数. 最终我们可以把最优解调整为符合贪心构造规则的一组解
>   + 综上, 我们可以证明, 贪心解 ≤ 最优解
> + $最优解 \le 贪心解 \& 贪心解 \le 最优解 \longrightarrow 最优解 = 贪心解$
>
> <br>
>
> 在代码实现时, 我们用一个数组 `g[N]` 存储贪心得到的不上升序列的最后一个数. 可以发现, 该数组里的数是单调上升的.
>
> 求至少需要多少个非上升子序列可以把整个序列填满, 答案恰是==整个序列的最长上升子序列长度==.

<br>

> [AcWing 187. 导弹防御系统](https://www.acwing.com/problem/content/189/)

> 存在两种防御系统, 一种打单调上升的序列, 一种打单调下降的序列. 解法与上一题的贪心相同, 但要考虑到每个数是放进单调上升的序列, 还是单调下降的序列, 因此需要爆搜dfs, 时间复杂度 $O(nlogn)$ (可以剪枝优化)
>
> <br>
>
> 爆搜中的dfs与bfs比较
>
> 爆搜一般不用bfs
>
> 1. bfs每次要在队列里存一层的数据, 而爆搜里, 每一层比上一层多一倍的数据. 因此bfs容易爆空间; 而dfs只存路径里的数据, 空间复杂度是线性的
> 2. bfs不容易剪枝, dfs容易剪枝优化

<br>

> [AcWing 272. 最长公共上升子序列](https://www.acwing.com/problem/content/274/)

> + 动态规划
>   + 状态表示 `f[i, j]`
>     + 集合: 所有由第一个序列前 $i$ 个字母, 和第二个序列前 $j$ 个字母构成的, 且以 `b[j]` 结尾的公共上升子序列
>     + 属性: Max length
>   + 状态计算
>     + 集合划分: 
>       + 不含 `a[i]`
>       + 含 `a[i]` : 子序列倒数第二个数是空、`b[1]` 、`b[2]` $\dots$ 
>     + 转移方程:
>       + 不含 `a[i]` : `f[i-1, j]`
>       + 含 `a[i]` : `f[i-1, k] + 1` 的最大值 ($0 \le k < j$ , 取0表示空)
>
> ```c++
> //暴力代码
> for(int i = 1; i <= n; i++)
>     for(int j = 1; j <= n; j++)
>     {
>         f[i][j] = f[i-1][j];
>         if(a[i] == b[j])
>         {
>             int maxv = 1;
>             for(int k = 1; k < j; k++)
>                 if(a[i] > b[k])
>                     maxv = max(maxv, f[i - 1][k] + 1);
>             f[i][j] = max(f[i][j], maxv);
>         }
>     }
> ```
>
> 可以看到暴力代码是 $O(n^3)$ 的复杂度, 数据范围为 $3000$ 时会 $TLE$ . 同时我们注意到第三重循环其实与第二重循环的循环变量无关, 因此可以合并到第二重循环里.
>
> ```c++
> //优化代码
> for(int i = 1; i <= n; i++)
> {
>     int maxv = 1;	//maxv是满足a[i]>b[k]的f[i-1][k]+1的前缀最大值
>     for(int j = 1; j <= n; j++)
>     {
>         f[i][j] = f[i - 1][j];
>         if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
>         if(a[i] > b[j]) maxv = max(maxv, f[i - 1][j] + 1);
>     } 
> }
> ```



<div style="page-break-after:always;"></div>

# 背包模型

### 背包问题

> + 动态规划重点: 状态表示 & 状态转移
> + 定义: 有编号 $1$ ~ $N$ 的 $N$ 个物品和一个体积为 $V$ 的背包, 对于每个物品 $i$ , 体积 $v_i$ , 价值(权重) $w_i$ . 要求往背包内装物品, 在装入背包物品总体积不超过背包体积的前提下, 求背包内物品价值总和的最大值
> + 分析思路
>   + 状态表示
>     + 可以把动态规划思想理解为每一个局面的最佳规划取决于上一个选择更少、更加简单的局面, 不断递归求出题目给出局面的最佳规划
>     + $f(c_1, c_2, \cdots , c_n)$ 表示一个 $n$ 维的局面
>       + 每一维是用来确定局面的一个条件 (比如背包问题的局面由容量和选择范围确定)
>       + 每个局面是所有满足条件的规划的集合
>       + 每一个集合由特定的属性, 比如最大值, 最小值, 最大数量等, 一般由题目要求的量决定
>     + 状态计算 (状态转移方程)
>       + 对应局面表示的集合的划分
>       + 每个集合可以划分成更小的集合, 这些小集合对应的每一维的条件也更小
>       + 一般可以以一维条件的改变来划分集合
>       + 集合划分后, 由更小的集合的属性来递推大集合的属性

<br>

---

### 根题

> ##### 01背包问题
>
> [AcWing 2. 01背包问题](https://www.acwing.com/problem/content/2/)

> + 特点: 每个物品只有一件
> + 二维动态规划
>   + 状态表示
>     + 集合: `f(i, j)` , 表示从 $1$ ~ $i$ 号物品之间选择, 体积总和不大于 $j$ 的所有选法组成的集合
>     + 属性: 价值最大值
>   + 状态计算: 集合的划分
>     + 从 $1$ ~ $i$ 号物品之间选择, 体积总和不大于 $j$ , 可以是从 $1$ ~ $i - 1$ 号物品之间选择, 体积总和不大于 $j$ ; 也可以是必选第 $i$ 号物品, 然后从 $1$ ~ $i - 1$ 号物品之间选择, 体积总和不大于 $j - v_i$ .
>     + 因此 `f(i, j)` 可以从 `f(i-1, j)` 转移过来, 也可以从 `f(i-1,j-v[i])` 转移过来. 方程如下
>       + `f(i, j) = max (f(i-1, j), f(i-1, j-v[i]) + w[i]))` 
> + 一维优化
>   + 可以发现, 二维做法时, 第一维只用到了 $i$ 和 $i - 1$ , 因此每次更新只需要将原来的值覆盖即可, 不需要存储, 因此第一维可以去掉
>     + 这是对滚动数组的优化
>   + 在更新第二维时, `f[j] = max (f[j], f[j - v[i]] + w[i])` 
>     + 如果不选 $i$ , 即不考虑加入新的物品, 则 `f[j] = f[j]` 
>     + 如果选 $i$ , 则需要 $i - 1$ 状态下的 `f[j - v[i]]` ; 由于 $j - v_i < j$ , 因此在 $i$ 状态下时, `f[j]` 一定要比 `f[j - v[i]]` 先更新, 所以 $j$ 要倒序遍历

<br>

### 衍生题

> ##### 01背包问题
>
> [AcWing 423. 采药](https://www.acwing.com/problem/content/description/425/)

> + 动态规划
>   + 状态表示 `f[i][j]` 
>     + 集合: 从前 $i$ 个物品中选, 体积不超过 $j$ 的选法
>     + 属性: $Max$ 
>   + 状态转移
>     + 不选第 $i$ 个物品: `f[i - 1][j]` 
>     + 选第 $i$ 个物品: `f[i - 1][j - v[i]] + w[i]` 
>   + 滚动数组优化:
>     + 由于 `f[i][j]` 只需用到当前层和上一层, 则结论可转化为: `f[j] = max(f[j], f[j - v[i]] + w[i])` 

<br>

> ##### 01背包问题
>
> [AcWing 1024. 装箱问题](https://www.acwing.com/problem/content/description/1026/)

> + 体积与价值相同的01背包问题
> + 要是剩余空间最小, 即要求最大价值

<br>

> ##### 二维费用的01背包问题
>
> [AcWing 1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/description/1024/)

> + 花费1: 精灵球数量
> + 花费2: 皮卡丘体力值
> + 价值: 收服小精灵的数量
> + 动态规划
>   + 状态表示 `f[i][j][k]` 
>     + 集合: 只从前 $i$ 个里面选, 费用1不超过 $j$ , 费用2不超过 $k$ 的选法
>     + 属性: $Max$ 
>   + 状态转移
>     + 不选第 $i$ 个物品: `f[i - 1][j][k]` 
>     + 选择第 $i$ 个物品: `f[i - 1][j - v1[i]][k - v2[i]] + 1` 
>   + 滚动数组优化:
>     + 由于 `f[i][j][k]` 只需用到当前层和上一层, 则结论可转化为: `f[j][k] = max(f[j][k], f[j - v1[i]][k - v2[i]] + 1)` 
> + 注意: 题目描述里说收服精灵时只有皮卡丘体力严格大于零才能成功收服, 因此集合表示的下标最大为 `体力值 - 1` 

<br>

---

### 根题

> ##### 完全背包问题
>
> [AcWing 3. 完全背包问题](https://www.acwing.com/problem/content/3/)

> + 特点: 物品件数无限制
> + 二维状态 + 二重循环
>   + 状态表示
>     + 集合: `f(i, j)`
>     + 属性: `max`
>   + 状态计算
>     + 按 $i$ 的个数维 $0, 1, 2, 3, \cdots , k (k \times v_i < j)$ 来划分集合
>     + `f(i, j) = max (f(i-1, j-0*v[i])+0*w[i], f(i-1, j-1*v[i])+1*w[i], ... , f(i-1, j-k*v[i])+k*w[i])` 
>     + `f(i, j-v[i]) = max (f(i-1, j-1*v[i]), f(i-1, j-2*v[i])+1*w[i], ... , f(i-1, j-k*v[i])+(k-1)*w[i])` 
>     + 可以发现, `f(i, j) = max (f(i - 1, j), f(i, j - v[i]) + w[i])` , 由此只需要两重循环
>     + 与01背包方程的区别: 01背包中条件为 `j - v[i]` 的状态是 $i - 1$ 条件下的, 而完全背包是 $i$ 条件下的
> + 一维状态 + 二重循环
>   + 完全按照01背包方程问题的优化方式来优化
>   + 唯一不同在于, 遍历 $j$ 时需要从小到大, 理由是01背包中条件为 `j - v[i]` 的状态是 $i - 1$ 条件下的, 而完全背包是 $i$ 条件下的, 因此 `f[j - v[i]]` 需要比 `f[j]` 更早更新, 所以 $j$ 要顺序遍历

<br>

> ##### 多重背包问题
>
> [AcWing 4. 多重背包问题](https://www.acwing.com/problem/content/4/)

> + 特点: 每个物品 $i$ 有 $s_i$ 件
> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 所有只从前 $i$ 个物品中选, 且总体积不超过 $j$ 的选法
>     + 属性: $Max$ 
>   + 状态计算
>     + 按 $i$ 的个数为 $0, 1, 2, 3, \cdots , s_i$ 来划分集合, 这一点与完全背包问题几乎一样
>     + 方程: `f[i, j] = max (f[i-1, j], f[i-1, j-v[i]]+w[i], f[i-1, j-2*v[i]]+2*w[i], ... , f[i-1, j-s*v[i]]+s*w[i])` 

<br>

> ##### 多重背包问题
>
> [AcWing 5. 多重背包问题Ⅱ](https://www.acwing.com/problem/content/5/)

> + 对前一题的优化
>   + 不能按照完全背包的优化方式来优化, 因为物品个数有限制, 因此 `f[i, j - v[i]]` 最后会多出一项 `f[i - 1, j - (s+1)*v[i]] + s*w[i]` , 就不能直接替换优化了
>   + 优化方法: 二进制优化
>     + 把 $s_i$ 分解为 $1, 2, 4, 8, \cdots , 2^k, s_i - (2^{k+1} - 1)$ , 这 $k + 2$ 个数, 可以在每个数只用一次的前提下组合出 $1$ ~ $s_i$ 之间的所有数
>     + 这样不仅 $s$ 的规模降到了 $\log s$ , 且整体的问题也等价于01背包问题, 就可以直接使用01背包问题的优化解法

<br>

> ##### 二维费用的背包问题
>
> [AcWing 8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)

> 二维费用的背包问题可以和01背包、完全背包、多重背包结合在一起.
>
> + 动态规划
>   + 状态表示 `f[i, j, k]` 
>     + 集合: 所有只从前 $i$ 个物品中选, 且总体积不超过 $j$ , 总重量不超过 $k$ 的选法
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分
>       + 不选第 $i$ 个物品: `f[i - 1, j, k]` 
>       + 选第 $i$ 个物品: `f[i - 1, j - v[i], k - m[i]] + w[i]` 
>     + 转移方程: `f[i, j, k] = max(f[i - 1, j, k], f[i - 1, j - v[i], k - m[i]] + w[i])` 
>       + 可以优化成一维: `f[j, k] = max(f[j, k], f[j - v[i], k - m[i]] + w[i])` 

<br>

---

### 衍生题

> ##### 二维费用的01背包问题
>
> [AcWing 1020. 潜水员](https://www.acwing.com/problem/content/description/1022/)

> + 动态规划
>   + 状态表示 `f[i, j, k]` 
>     + 集合: 所有从前 $i$ 个物品中选, 且氧气含量至少是 $j$ , 氮气含量至少是 $k$ 的选法
>       + ==体积的判定有下面三种, 初始化==
>       + ==至多: 全部初始化为 $0$ , 并保证集合中 $j, k \ge 0$==
>         + ==初始化为 $0$ 是根据实际意义来的. 至多时, 什么都不选, 价值为 $0$ , 也满足含义==
>       + ==恰好: `f[0, 0, 0] = 0  f[i, j, k] = INF (剩余所有方案)` , 且保证 $j, k \ge 0$==
>       + ==至少: `f[0, 0, 0] = 0  f[i, j, k] = INF (剩余所有方案)` , 且保证 $j, k \ge 0$==
>         + ==初始化为无穷的目的是在状态转移时不使用该方案的属性. 对于恰好来说, 有些方案不合法, 需要初始化成无穷; 对于至少来说, 有些方案还没被考虑到, 不影响它之前的方案的状态转移==
>         + ==INF是正无穷还是负无穷取决于问题是求最小值还是最大值==
>         + ==恰好和至少的初始化方式相同, 但不同在于, 恰好中无穷的方案是不合法的, 而至少中, 所有体积都是合法的, 即使算出负数体积也要转移过来==
>     + 属性: $Min$ 
>   + 状态计算
>     + 集合划分
>       + 不含 $i$ 的所有选法: `f[i - 1, j, k]` 
>       + 包含 $i$ 的所有选法: `f[i - 1, j - v1[i], k - v2[i]] + w[i]` 
>       + 当 $j < v1_i$ 或 $k < v2_i$ 时, 按照集合含义, 体积至少是一个负数, 意味着什么都不选, 这个状态在集合中是存在的, 需要从这个状态转移过来. 什么都不选, 和 $0$ 等同, 因此可以写成 `f[i - 1, max(j - v1[i], 0), max(k - v2[i], 0)] + w[i]` 
>     + 转移方程: `f[i, j, k] = min(f[i - 1, j, k], f[i - 1, max(j - v1[i], 0), max(k - v2[i], 0)] + w[i])` 
>       + 优化成二维: `f[j, k] = min(f[j, k], f[max(j - v1[i], 0), max(k - v2[i], 0)] + w[i])` 

<br>

> ##### 01背包问题
>
> [AcWing 278. 数字组合](https://www.acwing.com/problem/content/description/280/)

> 将 $M$ 看成背包容量, 把每一个数看成一个物品, $A_i$ 看成物品的体积. 目标是求出总体积恰好是 $M$ 的方案数
>
> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 所有只从前 $i$ 个物品中选, 且总体积恰好是 $j$ 的方案
>     + 属性: $Count$ 
>   + 状态计算
>     + 集合划分
>       + 不包括物品 $i$ 的所有选法: `f[i - 1, j]` 
>       + 包括物品 $i$ 的所有选法: `f[i - 1, j - v[i]]` 
>     + 转移方程: `f[i, j] = f[i - 1, j] + f[i - 1, j - v[i]]` 
>       + 优化成一维: `f[j] += f[j - v[i]]` 
>     + 初始化: `f[0] = 1` , 空集也是一种方案, 其他初始化为 $0$ 

<br>

> ##### 多重背包问题
>
> [AcWing 1019. 庆功会](https://www.acwing.com/problem/content/description/1021/)

> + 时间复杂度 ($n$表示物品种数, $v$表示物品体积, $s$表示每种物品的数量)
>   + 朴素版: $O(nvs)$ 
>   + 二进制优化: $O(nv \log s)$ 
>   + 单调队列优化: $O(nv)$ 
> + 动态规划
>   + 状态表示 `f[i][j]` 
>     + 集合: 只从前 $i$ 种物品中选, 总体积不超过 $j$ 的选法
>     + 属性: $Max$ 
>   + 状态转移
>     + 第 $i$ 种物品选 $k$ 个 (不超过总体积的情况下): `f[i - 1][j - k * v[i]] + k * w[i]` $(0 \le k \le s[i])$ 
>   + 滚动数组优化:
>     + 由于 `f[i][j]` 只需用到当前层和上一层, 则结论可转化为: `f[j] = max(f[j - k * v[i]] + k * w[i])` 

<br>

> ##### 完全背包问题
>
> [AcWing 1023. 买书](https://www.acwing.com/problem/content/description/1025/)

> + 动态规划
>
>   + 状态表示 `f[i, j]` 
>     + 集合: 所有只从前 $i$ 个物品中选, 且总体积恰好是 $j$ 的方案
>     + 属性: $Count$ 
>
>   + 状态计算
>     + 集合划分
>       + 不包括物品 $i$ 的所有选法: `f[i - 1, j]` 
>       + 包括物品 $i$ 的所有选法: `f[i - 1, j - v[i]]` 
>     + 转移方程: `f[i, j] = f[i - 1, j] + f[i - 1, j - v[i]]` 
>       + 优化成一维: `f[j] += f[j - v[i]]` 
>     + 初始化: `f[0] = 1` , 空集也是一种方案, 其他初始化为 $0$ 

<br>

---

### 根题

> ##### 分组背包问题
>
> [AcWing 9. 分组背包问题](https://www.acwing.com/problem/content/9/)

> + 物品被分成了几组, 每一组里只能选一件物品
> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 只从前 $i$ 组物品中选, 且总体积不大于 $j$ 的所有选法
>     + 属性: $Max$ 
>   + 状态计算
>     + 划分: 按第 $i$ 个物品从第 $i$ 组中不选或选哪个来划分
>     + 方程: `f[i, j] = max (f[i-1, j], f[i-1, j-v[i, k]] + w[i, k])` 

<br>

> ##### 背包问题求具体方案
>
> [AcWing 12. 背包问题求具体方案](https://www.acwing.com/problem/content/description/12/)

> 背包问题求具体方案可以和01背包、完全背包、多重背包结合在一起.
>
> + 01背包转移方程: `f[i, j] = max(f[i - 1, j], f[i - 1, j - v[i]] + w[i])` 
> + 求方案就是看每个状态是从哪个状态转移过来的, 对应的是最短路问题种的求路径
> + 同求最短路中求路径, 由于求路径与最短距离是相反的顺序, 因此如果要求从起点到终点的最短路径, 则在求最短距离时需要从终点开始遍历到起点. 同理, 背包问题的遍历就要从第 $n$ 个物品遍历到第 $1$ 个物品求属性, 再从 $1$ 到 $n$ 求方案
> + 题目中如果要求输出字典序最小的答案, 就要判断每个物品是否选择时贪心
>   + 只能选: 必选
>   + 只能不选: 必不选
>   + 可选可不选: 一定要选
>     + 因为背包问题是按字典序从小到大遍历每个物品, 如果不选, 则该方案的字典序一定比选的字典序大
> + 由于在求方案时需要用到 `i- 1` , `i + 1` 的数据, 因此不能简化维数
> + 另一种做法是开一个数组 `g[i, j]` , 记录该状态是由哪个状态转移过来的, 同LIS中输出最长上升子序列

```c++
//反着求最大值 f[1][m]
for(int i = n; i; i--)
    for(int j = 0; j <= m; j++)
    {
        f[i][j] = f[i + 1][j];
        if(j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
    }

//求具体方案
for(int i = 1, j = m; i <= n; i++)
    if(j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])
    {
        cout << i << ' ';
        j -= v[i];
    }
```

<br>

### 衍生题

> ##### 分组背包问题求具体方案
>
> [AcWing 1013. 机器分配](https://www.acwing.com/problem/content/description/1015/)

> $n$ 个公司对应 $n$ 组, 给第 $i$ 个公司分配机器 $1$ 台、$2$ 台、…… 、$m$ 台对应第 $i$ 组的第 $j$ 个物品, 每个物品就是分配的台数, 价值就是能提供的盈利.
>
> 求具体方案, 则 $i$ 逆序遍历, 找到每个状态是由哪个状态转移过来的.

```c++
//求最大价值
for(int i = n; i >= 1; i--)
    for(int j = 1; j <= m; j++)
        for(int k = 0; k <= j; k++)
            dp[i][j] = max(dp[i][j], dp[i + 1][j - k] + w[i][k]);

//求具体方案
for(int i = 1, j = m; i <= n; i++)
    for(int k = 0; k <= j; k++)
        if(dp[i][j] == dp[i + 1][j - k] + w[i][k])
        {
            cout << i << ' ' << k << endl;
            j -= k;
            break;
        }
```

<br>

> ##### 分组背包问题
>
> [AcWing 487. 金明的预算方案](https://www.acwing.com/problem/content/description/489/)

> 分组背包问题的本质是对每个组里的物品进行决策——选或不选, 且每个组里的物品决策是互斥的, 只能选择一个物品. 能转化成该模型的题目都可以用分组背包来解决.
>
> 本题转化为分组背包问题的思路是, 对于一个主件, 给其买附件的选择只能有一种. 比如一个主件有两个附件 $a$ , $b$ , 那买附件的选择就是不买、买 $a$ 、买 $b$ 、买 $ab$ , 这四种选择只能选择一种. 因此对于每个主件的决策就可以构成一组背包, 每个决策就是该组里的物品, 每组中只能选择一个物品. 
>
> 枚举对每个主件买附件的决策时使用二进制优化.

```c++
PII master[N];	//存储主件
vector<PII> servant[N];	//存储每一组的附件

//读入数据
for(int i = 1; i <= n; i++)
{
    int v, w, q;
    cin >> v >> w >> q;
    if(!q) master[i] = {v, v * w};
    else servant[q].push_back({v, v * w});
}

//分组背包
for(int i = 1; i <= n; i++)
    for(int j = m; j >= 0; j--)
        for(int k = 0; k < (1 << servant[i].size()); k++)
        {
            int v = master[i].first, w = master[i].second;	//主件
            for(int u = 0; u < servant[i].size(); u++)	//二进制枚举附件决策
                if((k >> u) & 1)
                {
                    v += servant[i][u].first;
                    w += servant[i][u].second;
                }
            if(v <= j) dp[j] = max(dp[j], dp[j - v] + w);
        }
```

<br>

---

### 根题

> ##### 混合背包问题
>
> [AcWing 7. 混合背包问题](https://www.acwing.com/problem/content/description/7/)

> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 只从前 $i$ 件物品中选, 且总体积不超过 $j$ 的所有选法
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分: 01、完全、多重
>     + 转移方程:
>       + 01: `f[i, j] = max(f[i - 1, j], f[i - 1, j - v[i]] + w[i])` 
>       + 完全: `f[i, j] = max(f[i - 1, j], f[i, j - v[i]] + w[i])` 
>       + 多重: `f[i, j] = max(f[i - 1, j], f[i - 1, j - v[i]] + w[i], f[i - 1, j - 2 * v[i]] + 2 * w[i], ... )` 
>       + 多重背包可以使用二进制优化
>     + 可以注意到, 每一种背包的状态转移方程只涉及到当前第 $i$ 个物品的种类, 因此每次只需判断物品种类, 然后使用相应的转移方程即可

<br>

> ##### 树上背包问题
>
> [AcWing 10. 有依赖的背包问题](https://www.acwing.com/problem/content/description/10/)

> + 动态规划
>   + 状态表示: `f[u, j]` 
>     + 集合: 所有以 $u$ 为根的子树中选, 且总体积不超过 $j$ 的方案
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分: 按子树划分
>       + 子树内部按照该子树方案用的体积来划分. 如果按照子树方案来划分, 则数量级是 $2^n$ 级别. 用体积来划分, 就是忽略具体的方案, 用方案需要的体积数将所有具体方案归类, 每种体积下的所有方案统一用属性代表, 可以把数据量降到 $m + 1$ 
>     + 转移方程: 枚举儿子节点, 每个节点为根的树相当于物品组, 用分组背包的方式循环

```c++
void dfs (int u)
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int son = e[i];
        dfs(son);
        
        for(int j = m - v[u]; j >= 0; j--)
            for(int k = 0; k <= j; k++)
                dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[son][k]);
    }
    
    for(int i = m; i >= v[u]; i--)
        dp[u][i] = dp[u][i - v[u]] + w[u];
    for(int i = 0; i < v[u]; i++) dp[u][i] = 0;
}
```

<br>

> ##### 背包问题求方案数
>
> [AcWing 11. 背包问题求方案数](https://www.acwing.com/problem/content/description/11/)

> `f[i, j] =  max(f[i - 1, j], f[i - 1][j - v[i]] + w[i])` 
>
> 另开一个数组 `g[N][N]` , `g[i, j]` 表示 `f[i, j]` 取最大值的方案数.
>
> 转移方程: 
>
> ```c++
> if (f[i - 1][j] > f[i - 1][j - v[i]] + w[i])
>  g[i][j] = g[i - 1][j];
> else if (f[i - 1][j] < f[i - 1][j - v[i]] + w[i])
>  g[i][j] = g[i - 1][j - v[i]];
> else g[i][j] = g[i - 1][j] + g[i - 1][j - v[i]];
> ```
>
> 可以优化成一维.

```c++
//初始化
memset(dp, -0x3f, sizeof dp);
dp[0] = 0;
g[0] = 1;

//读入数据
for(int i = 0; i < n; i++)
{
    int v, w;
    cin >> v >> w;
    for(int j = m; j >= v; j--)
    {
        int maxv = max(dp[j], dp[j - v] + w);
        int cnt = 0;
        if(maxv == dp[j]) cnt += g[j];
        if(maxv == dp[j - v] + w) cnt += g[j - v];
        g[j] = cnt;
        dp[j] = maxv;
    }
}

//求最优方案的方案数
int res = 0;
for(int i = 0; i <= m; i++) res = max(res, dp[i]);
int cnt = 0;
for(int i = 0; i <= m; i++)
    if(res == dp[i]) cnt += g[i];
```

<br>

> ##### 贪心
>
> [AcWing 125. 耍杂技的牛](https://www.acwing.com/problem/content/description/127/)

> 贪心. 
>
> 结论: 按 $w_i + s_i$ 从小到大排序
>
> 证明: 
>
> 假设 $w_i + s_i > w_{i+1} + s_{i+1}$ 
>
> $\quad\quad\quad\quad\quad$ 第 $i$ 个位置的牛 $\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad$ 第 $i + 1$ 个位置的牛
>
> 交换前: $w_1 + w_2 + \cdots + s_{i-1} - s_i$ $\quad\quad\quad\quad\quad\quad$ $w_1 + w_2 + \cdots + w_i - s_{i+1}$ 
>
> 交换后: $w_1 + w_2 + \cdots + w_{i-1} - s_{i-1}$ $\quad\quad\quad\quad$ $w_1 + w_ 2 + \cdots + w_{i-1} + w[i+1] - s_i$ 
>
> 在两边同时加上 $- (w_1 + w_2 + \cdots + w_{i-1}) + s_i + s_{i+1}$ , 则:
> $\quad\quad\quad\quad\quad$ 第 $i$ 个位置的牛 $\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad$ 第 $i + 1$ 个位置的牛
>
> 交换前: $\quad\quad\quad\quad$ $s_{i+1}$ $\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad$ $w_i + s_i$ 
>
> 交换后: $\quad\quad\quad\quad$ $s_i$ $\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad$ $w_{i+1} + s_{i+1}$ 
>
> 易得, $w_i + s_i = max\{w_i + s_i, w_{i+1} + s_{i+1}\}$ 
>
> 因此, 对于位置越小的 $i$ , $w_i + s_i$ 越小越好.

<br>

### 衍生题

> ##### 完全背包问题
>
> [AcWing 532. 货币系统](https://www.acwing.com/problem/content/description/534/)

> 求向量的秩.
>
> 将数组从小到大排序后, 对每一个数做完全背包, 遇到不能由前面的数线性表出的就 `res++` 

<br>

> ##### 贪心 + 01背包
>
> [AcWing 734. 能量石](https://www.acwing.com/problem/content/description/736/)

> + 贪心
>   + 结论: 按 $\dfrac{s_i}{l_i}$ 从小到大排序
>   + 证明:
>     + 先吃第 $i$ 块能量石, 再吃第 $i + 1$ 块能量石, 所得能量: $e' + e'_{i+1} - s_i \cdot l_{i+1}$ 
>     + 先吃第 $i + 1$ 块能量石, 再吃第 $i$ 块能量石, 所得能量: $e'_{i+1} + e'_i - s_{i+1} \cdot l_i$ 
>     + 若让前者大于后者, 则 $\dfrac{s_i}{l_i} < \dfrac{s_{i+1}}{l_{i+1}}$ 
> + 动态规划
>   + 集合表示 `f[i, j]` 
>     + 集合: 所有只从前 $i$ 个能量石中吃, 且时间为 $j$ 的方案
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分: 第 $i$ 个能量石吃还是不吃
>     + 转移方程: `f[i, j] = max(f[i - 1, j], f[i - 1, j - s[i]] + e[i] - (j - s[i]) * l[i])` 



<div style="page-break-after:always;"></div>

# 状态机模型

### 状态机模型

> 状态机是一个数学模型, 数学符号描述为 $M = ( \sum , S, s_0 , \delta , F)$ , 其中
>
> + $\sum$ : 输入表
> + $S$ : 状态的非空有限集合
> + $s_0$ : 初始状态, 是 $S$ 的元素
> + $\delta$ : 状态转移函数, $\delta : S \times \sum \to S$ 
> + $F$ : 最终状态的集合, 是 $S$ 的子集
>
> 该数学模型描述的是一个抽象的对象有许多状态, 组成集合 $S$ . 该对象初始状态为 $s_0$ , 然后对象接收输入 $\sum$ . 每次接收输入后, 对象都按照状态转移函数 $\delta$ 变换当前状态.

<br>

---

### 根题

> [AcWing 285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

> + 状态机分析
>   + 状态表示 `f[i][1] f[i][0]` 
>     + 集合
>       + `f[u][1]` 表示以 `u` 为根节点的子树并且包括u的总快乐指数
>       + `f[u][0]` 表示以 `u` 为根节点的子树并且不包括u的总快乐指数
>     + 属性: $Max$ 
>   + 状态计算: 要想求得一棵以 `u` 为根节点的子树的最大指数分为两种: 选 `u` 节点或不选 `u` 节点. 记点u的子节点是j
>     + 选 `u` : $f[u][1] = happy[u] + \sum f[j][0]$ 
>     + 不选 `u` : $f[u][0] = \sum max(f[j][1], f[j][0])$ 

<br>

### 衍生题

> [AcWing 1049. 大盗阿福](https://www.acwing.com/problem/content/1051/)

> + 动态规划
>   + 状态表示 `f[i]` 
>     + 集合: 从前 $i$ 家店铺抢劫的所有方案
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分
>       + 抢第 $i$ 家店铺: `f[i - 2] + w[i]` 
>       + 不抢第 $i$ 家店铺: `f[i - 1]` 
>     + 转移方程: `f[i] = max(f[i - 1], f[i - 2] + w[i])` 
>
> 按照上述的DP分析法, 需要用到 `f[i - 2]` 的信息. 如何才能只依赖 `f[i - 1]` 的信息?
>
> 在本题中, 当前物品选与不选的操作受之前物品选与不选的操作的影响, 而之前做过的DP题不存在这种关系限制. 因此引入状态和状态机, 状态存储的就是前面店铺被抢劫的信息
>
> `f[i]` 可以分解为两种状态:
>
> + `f[i, 0]` : 未选当前店铺
> + `f[i, 1]` : 选择当前店铺
>
> 状态机描述: 
>
> + 初始状态为 $0$ 
> + 当前状态为 $0$ 时
>   + 不抢: 继续为 $0$
>   + 抢: 状态变为 $1$ 
> + 当状态为 $1$ 时, 不能抢, 只能不抢, 变为 $0$ 
>
> 每一个店都要在状态机模型上走一条边, 因此任何一个抢劫方案都能对应状态机上一个长度为 $n$ 的走法
>
> + 状态机分析
>   + 状态表示 `f[i, 0] f[i, 1]` 
>     + 集合: 所有走了 $i$ 步, 且当前位于状态 $j$ 的所有走法
>     + 属性: $Max$ 
>   + 状态计算: 按照状态机的描述来转移状态
>     + `f[i, 0] = max(f[i - 1, 0], f[i - 1, 1])` 
>     + `f[i, 1] = f[i - 1, 0] + w[i]` 
>   + 初始化: `f[0, 0] = 0` 
>   + 可以优化成一维

<br>

> [AcWing 1057. 股票买卖 Ⅳ](https://www.acwing.com/problem/content/1059/)

> 状态机中有两种状态, 状态变换的边有权重, 为每次状态变换的收益
>
> + 手中有货
>   + 可以继续持有, 权重为 $0$ , 状态继续为手中有货
>   + 可以卖出, 权重为 $+w_i$ , 状态变为手中无货
> + 手中无货
>   + 可以不买货, 权重为 $0$ , 状态继续为手中无货
>   + 可以买入, 权重为 $-w_i$ , 状态变为手中有货
> + 起始状态: 手中无货
> + 结束状态: 手中无货或有货, 但无货肯定比有货获得收益更优
>
> <br>
>
> + 状态机分析
>   + 状态表示 `f[i, j, 0] f[i, j, 1]` 
>     + 集合: 只考虑前 $i$ 天, 已经进行完前 $j - 1$ 次交易
>     + `f[i, j, 0]` : 表示已经完成了第 $j$ 次交易, 手中无货
>     + `f[i, j, 1]` : 表示正在进行第 $j$ 次交易, 手中有货
>   + 状态计算
>     + `f[i, j, 0] = max(f[i - 1, j, 0], f[i - 1, j, 1] + w[i])` 
>     + `f[i, j, 1] = max(f[i - 1, j, 1], f[i - 1, j - 1, 0] - w[i])` 
>   + 初始化: $j$ 是一个正好的状态, 因此先全部初始化为无穷. 根据实际意义, `f[i, 0, 0] = 0` 

<br>

> [AcWing 1058. 股票买卖 Ⅴ](https://www.acwing.com/problem/content/1060/)

> 状态机中有三种状态
>
> + 手中有货
>   + 可以继续持有, 权重为 $0$ , 状态继续为手中有货
>   + 可以卖出, 权重为 $+w_i$ , 状态变为手中无货的第 $1$ 天
> + 手中无货的第 $1$ 天
>   + 不能买入, 权重为 $0$ , 状态变为手中无货的第 $\ge 2$ 天
> + 手中无货的第 $\ge 2$ 天
>   + 可以不买入, 权重为 $0$ , 状态继续为手中无货的第 $\ge 2$ 天
>   + 可以买入, 权重为 $-w_i$ , 状态变为手中有货
> + 起始状态 (入口) : 手中无货的第 $\ge 2$ 天
> + 结束状态 (出口) : 手中无货的第 $1$ 天或第 $\ge 2$ 天
>
> <br>
>
> + 状态机分析
>   + 状态表示 `f[i, 0] f[i, 1] f[i, 2]` 
>     + `f[i, 0]` : 第 $i$ 天手中有货
>     + `f[i, 1]` : 第 $i$ 天手中无货而第 $i - 1$ 天刚卖出
>     + `f[i, 2]` : 第 $i$ 天手中无货且可以买入
>   + 状态计算
>     + `f[i, 0] = max(f[i - 1, 0], f[i - 1, 2] - w[i])` 
>     + `f[i, 1] = f[i - 1, 0] + w[i]` 
>     + `f[i, 2] = max(f[i - 1, 2], f[i - 1, 1])` 
>   + 初始化: 入口初始化为 $0$ , 其他初始化为无穷

<br>

> [AcWing 1052. 设计密码](https://www.acwing.com/problem/content/1054/)

> 结合KMP的过程. 在字符串匹配时, 匹配子串上有一个 $j$ 指针, 每次判断 `s[i] == p[j + 1]` , 如果不等, $j$ 就会按照 `next[j]` 跳转直到相等或跳到开头. 我们把跳转看作状态的变化, 子串上的每一位字符都是一种状态, 则状态机中有 $m + 1$ 种状态 ( $m$ 为匹配子串长度, 子串头部也算一种状态). 对于每一状态, 状态转移的情况取决于当前要匹配的字符 `s[i]` . 本题而言, 被匹配字符串就是我们要设计的密码, 匹配子串就是要求不被密码包含的字符串 $T$ . 设计密码是, 每一位字符 `s[i]` 可以有 $26$ 个字母的选择, 每个选择会导致匹配子串中状态的转移, 因此在状态机中有 $m + 1$ 种状态, 每个状态有 $26$ 个转移情况 (转移情况可能存在重合)
>
> + 状态机分析
>   + 状态表示 `f[i, j]`
>     + 集合: 已经考虑完密码的前 $i$ 个字符, 且匹配子串指针跳到第 $j$ 个字符 (状态) 的所有方案
>     + 属性: $Count$ 
>   + 状态计算
>     + 这里的计算和上面几道题的计算有所差别. 上面几道题是考虑某一状态是从哪些状态转移过来的; 本题是考虑枚举到的状态会转移到哪些状态上去, 把本状态的属性叠加到转移到的状态属性上去
>       + $j$ 能转移到 $u$ : `f[i + 1, u] += f[i, j]`
>   + 初始化: `f[0, 0] = 1` 

```c++
cin >> n >> str + 1;
m = strlen(str + 1);

//求解 ne 数组
for(int i = 2, j = 0; i <= m; i++)
{
    while(j && str[i] != str[j + 1]) j = ne[j];
    if(str[i] == str[j + 1]) j++;
    ne[i] = j;
}

//字符串匹配
dp[0][0] = 1;	//已经确定 0 位密码,且子串可以匹配到第 0 位的方案数
for(int i = 0; i < n; i++)	//密码枚举到第 i 位
    for(int j = 0; j < m; j++)	//枚举第 i 位密码可以匹配的子串
        for(char k = 'a'; k <= 'z'; k++)	//枚举密码第 i 位填什么
        {
            int u = j;
            while(u && k != str[u + 1]) u = ne[u];
            if(k == str[u + 1]) u++;	//可以匹配
            if(u < m) dp[i + 1][u] += dp[i][j];
        }

int res = 0;
for(int i = 0; i < m; i++) res += dp[n][i];
```



<div style="page-break-after:always;"></div>

# 状态压缩DP

### 状态压缩DP

> + 棋盘式 (基于连通性)
> + 集合

> 把复杂的状态压缩成一个数, 比如利用数的二进制表示其中隐藏的信息.
>
> 特点: $n$ 不会很大, 因为涉及 $2^n$ 

<br>

---

### 根题

> [AcWing 291. 蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)

> + 可以发现, 当横向格子确定好之后, 剩下的竖向格子只有完全填充这一种摆法, 因此只需枚举横向格子
> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 所有满足第 $i$ 列有伸出横向格子 (意思是 $1 \times 2$ 左边的格子在第 $i$ 列) 且从上往下拜访的方式与 $j$ 的二进制表示相对应的摆法
>     + 属性: $Count$ 
>   + 状态计算
>     + 转移: `f[i - 1, k]` 在满足格子不重叠 ( `k & j == 0` ) 和横格之间的连续空格不为奇数 ( `k | j 不存在连续奇数个0` ) 时可以转移到 `f[i, j]` 
>       + 连续空格不为奇数是为了保证竖向格子可以填充
>     + 方程: `f[i, j] += f[i - 1][k]` 

```c++
for(int i = 0; i < 1 << n; i++)
{
    st[i] = true;
    int cnt = 0;
    for(int j = 0; j < n; j++)
        if(i >> j & 1)
        {
            if(cnt & 1) st[i] = false;
            cnt = 0;
        }
    	else cnt++;
    if(cnt & 1) st[i] = false;
}

dp[0][0] = 1;
for(int i = 1; i <= m; i++)
    for(int j = 0; j < 1 << n; j++)
        for(int k = 0; k < 1 << n; k++)
            if((j & k) == 0 && st[j | k])
                dp[i][j] += dp[i - 1][k];

cout << dp[m][0] << endl;
```

<br>

> [AcWing 91. 最短Hamilton路径](https://www.acwing.com/problem/content/93/)

> + 动态规划
>   + 状态表示 `f[i, j]` 
>     + 集合: 从 $0$ 走到 `j` , 走过的所有点对应 `i` 的二进制表示的所有路径
>       + 二进制的每一位, $0$ 表示为走过, $1$ 表示走过
>     + 属性: 集合所有路径的最小值
>   + 状态计算
>     + 划分: 以倒数第二个点编号来划分
>     + 方程: 倒数第二个点 `k` 范围从 $0$ 到 $n - 1$ , 则 `f[i, j] = min(f[i - {j}, k] + w[k, j])` 

```c++
dp[1][0] = 0;
for(int i = 0; i < i << n; i++)
    for(int j = 0; j < n; j++)
        if(i >> j & 1)
            for(int k = 0; k < n; k++)
                if(i >> k & 1)
                    dp[i][j] = min(dp[i][j], dp[i - (1 << j)][k] + w[k][j]);

cout << dp[(1 << n) - 1][n - 1] << endl;
```

<br>

### 衍生题

> [AcWing 1064. 小国王](https://www.acwing.com/problem/content/1066/)

> 连通性题目, 一个国王的攻击范围构成一个连通区域.
>
> 可以发现, 如果固定方向按行摆放国王, 比如从上往下, 当前行摆放国王的摆法只受前面摆放国王的限制, 因此可以用DP优化.
>
> + 状态压缩DP
>   + 集合表示 `f[i, j, s]` 
>     + 集合: 所有只摆在前 $i$ 行, 已经摆了 $j$ 个国王, 并且第 $i$ 行摆放的状态是 $s$ 的方案
>       + $s$ 用数的二进制来表示状态, $1$ 为国王
>     + 属性: $Count$ 
>   + 状态计算
>     + 集合划分: 按照第 $i - 1$ 行国王的摆放方式来划分, 需要满足以下要求:
>       + 第 $i - 1$ 行内部不能有两个 $1$ 相邻
>       + 第 $i - 1$ 行和第 $i$ 行之间也不能互相攻击到
>       + 用 $a$ , $b$ 分别指代第 $i - 1$ 行和第 $i$ 行国王的摆放情况, 则以上条件可以表示为 $a \& b == 0$ , $a | b 不能有两个相邻的 1$ 
>     + 状态转移: 对 `f[i, j, a]` 集合划分, 划分出的子集可以统一表示为:
>       + 已经摆完了前 $i$ 行, 并且第 $i$ 行的状态是 $a$ , 第 $i - 1$ 行的状态是 $b$ , 已经摆了 $j$ 个国王的所有方案
>       + 由于每个子集的第 $i$ 行状态都是 $a$ , 因此子集的表示等同于: 已经摆完前 $i - 1$ 行, 并且第 $i - 1$ 行的状态是 $b$ , 已经摆了 $j - count(a)$ 个国王的所有方案

```c++
int cnt [M];	//	记录每个状态中1的个数,即摆放国王个数
long long dp[N][K][M];
vector<int> state;	//所有合法状态
vector<int> head[M];	//记录每个状态能转移到的状态

//判断状态是否合法,即是否存在相邻的1
bool check (int state)
{
    for(int i = 0; i < n; i++)
        if((state >> i & 1) && (state >> i + 1 & 1))
            return false;
    return true;
}

//统计状态中1的个数
int count (int state)
{
    int res = 0;
    for(int i = 0; i < n; i++)
        res += state >> i & 1;
    return res;
}

//筛选出所有合法的状态
for(int i = 0; i < 1 << n; i++)
    if(check(i))
    {
        state.push_back(i);
        cnt[i] = count(i);
    }

//枚举所有合法状态能转移到的状态
for(int i = 0; i < state.size(); i++)
    for(int j = 0; j < state.size(); j++)
    {
        int a = state[i], b = state[j];
        if((a & b) == 0 && check(a | b))
            head[a].push_back(b);
    }

dp[0][0][0] = 1;
for(int i = 1; i <= n + 1; i++)
    for(int j = 0; j <= m; j++)
        for(auto a: state)	//枚举第i行状态	
            for(auto b: state)	//枚举第i-1行状态
                if(j >= cnt[a])
                    dp[i][j][a] += dp[i - 1][j - cnt[a]][b];

cout << dp[n + 1][m][0] << endl;
/*等价于 long long res = 0;
for(auto x: state) res += dp[n][m][x];
cout << res << endl;	*/
```

<br>

> [AcWing 327. 玉米田](https://www.acwing.com/problem/content/329/)

> + 状态压缩DP
>   + 集合表示 `f[i, s]` 
>     + 集合: 所有已经摆完前 $i$ 行, 且第 $i$ 行的状态是 $s$ 的所有摆放方案
>     + 属性: $Count$ 
>   + 状态计算
>     + 集合划分: 按合法的上一行的摆放状态来划分. 令 $a$ , $b$ 分别表示第 $i - 1$ 行和第 $i$ 行的状态, 则划分后的子集表示为:
>       + 已经摆完前 $i$ 行, 第 $i - 1$ 行的状态是 $b$ 的所有摆放方案
>       + 等价于: 已经摆完前 $i - 1$ 行, 且第 $i - 1$ 行的状态是 $b$ 的所有摆放方案 `f[i - 1, b]` 
>       + $a$ , $b$ 需要满足
>         + $a$ , $b$ 的二进制表示中不包含连续两个 $1$ 
>         + $a \& b == 0$ 
>     + 状态转移: `f[i, a] = sum(f[i - 1, b])` 

```c++
int g[N];
int dp[N][M];
vector<int> state;
vector<int> head[M];

bool check (int state)
{
    for(int i = 0; i < m; i++)
        if((state >> i & 1) && (state >> i + 1 & 1))
            return false;
    return true;
}

for(int i = 1; i <= n; i++)
    for(int j = 0; j < m; j++)
    {
        int t;
        cin >> t;
        g[i] += !t << j;	//该行的状态不能根实际摆放的状态有交集
    }

for(int i = 0; i < 1 >> m; i++)
    if(check(i))
        state.push_back(i);

for(int i = 0; i < state.size(); i++)
    for(int j = 0; j < state.size(); j++)
    {
        int a = state[i], b = state[j];
        if((a & b) == 0) head[a].push_back(b);
    }

dp[0][0] = 1;
for(int i = 1; i <= n + 1; i++)
    for(auto a: state)	//枚举所有状态
        if((g[i] & a) == 0) // 该行状态是否与枚举的状态冲突
			for(auto b: head[a])
                dp[i][a] += dp[i - 1][b];

cout << dp[n + 1][0] << endl;
```

<br>

> [AcWing 292. 炮兵阵地](https://www.acwing.com/problem/content/294/)

> + 状态压缩DP
>   + 状态计算 `f[i, j, k]` 
>     + 集合: 所有已经摆完前 $i$ 行, 且第 $i - 1$ 行的状态是 $j$ , 第 $i$ 行的状态是 $k$ 的摆放方案
>     + 属性: $Max$ 
>   + 状态计算
>     + 集合划分: 根据第 $i - 2$ 行的状态来划分. 令第 $i - 1$ 行的状态为 $a$ , 第 $i$ 行状态为 $b$ , 第 $i - 2$ 行状态为 $c$ , 则 $a$ , $b$ , $c$ 需要满足
>       + `((a & b) | (a & c) | (b & c)) == 0` 
>       + `((g[i - 1] & a) | (g[i] & b)) == 0` 
>       + $a$ , $b$ , $c$ 中的 $1$ 不能相邻或间隔一个单位
>     + 状态转移
>       + 枚举 $c$ , `f[i, a, b] = max(f[i, a, b], f[i - 1, c, a] + cnt[b])` 
>
> 由于本题空间有限, 需要用滚动数组存储数据. 方法就是将原本写法代码中所有的 `f[n][j][k]` 变成 `f[n & 1][j][k]` 

```c++
int g[N];
int cnt[M];
int dp[2][M][M];
vector<int> state;

bool check (int state)
{
    for(int i = 0; i < m; i++)
        if((state >> i & 1) && ((state >> i + 1 & 1) || (state >> i + 2 & 1)))
            return false;
    return true;
}

int count (int state)
{
    int res = 0;
    for(int i = 0; i < m; i++)
        res += state >> i & 1;
    return res;
}

for(int i = 1;i <= n; i++)
    for(int j = 0; j < m; j++)
    {
        char c;
        cin >> c;
        g[i] += (c == 'H') << j;
    }

for(int i = 0; i < 1 << m; i++)
    if(check(i))
    {
        state.push_back(i);
        cnt[i] = count(i);
    }

for(int i = 1; i <= n + 2; i++)
    for(auto a: state)
        for(auto b: state)
            for(auto c: state)
            {
                if((a & b) || (a & c) || (b & c)) continue;
                if((g[i] & b) || (g[i - 1] & a)) continue;
                dp[i & 1][b][a] = max(dp[i & 1][b][a], dp[i - 1 & 1][a][c] + cnt[b]);
            }

cout << dp[n + 2 & 1][0][0] << endl;
```



<div style="page-break-after:always;"></div>

# 区间DP

### 区间DP

> + 环形区间DP $\Longrightarrow$ 破环成链
> + 区间DP记录方案数
> + 区间DP + 高精度
> + 二维区间DP

<br>

---

### 根题

> [AcWing 282. 石子合并](https://www.acwing.com/problem/content/description/284/)

> + 状态表示
>   + $f_{i, j}$ 表示将 $i$ 到 $j$ 这一段石子合并成一堆的方案的集合
>   + 属性: $min$ 
> + 状态计算
>   + 如果按第 $k$ 个点为分界点, 那么代价是 $f_{l, k} + f_{k + 1, r} + s_r - s_{l - 1}$ 
>   + 状态转移方程 $f_{l, r} = min_{k \in [l, r - 1]} \{f_{l, k} + f_{k + 1, r} + s_r - s_{l - 1} \}$ 
>   + 因为状态转移方程都是要用到区间长度比自己小的, 所以区间长度要从小到大枚举

```c++
for(int len = 2; len <= n; len ++)
    for(int l = 1; l + len - 1 <= n; l ++)
    {
        int r = l + len - 1;
        dp[l][r] = INF;
        for(int k = l; k < r; k++)
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]);
    }

cout << dp[1][n] << endl;
```

<br>

### 衍生题

> [AcWing 1068. 环形石子合并](https://www.acwing.com/problem/content/description/1070/)

> 环形区间DP, 将长度为 $n$ 的环变成长度为 $2n$ 的链, 破环成链后就是根题的区间DP问题
>
> + 状态表示 $f[l, r]$ 
>   + 集合: 区间 $[l, r]$ 内的石子合并后的得分
>   + 属性: $min$ / $max$ 
> + 状态转移
>   + $f_{l, r} = min \{f_{l, k} + f_{k + 1, r} + s_r - s_{l - 1} \}$ 
> + 答案就是所有长度为 $n$ 的区间的最小值 / 最大值

```c++
for(int i = 1; i <= n; i++)
{
    cin >> s[i];
    s[i + n] = s[i];	//破环成链
}
for(int i = 1; i <= n * 2; i++)
    s[i] += s[i - 1];	//前缀和

for(int len = 2; len <= n; len++)
    for(int l = 1; l + len - 1 <= n * 2; l++)
    {
        int r = l + len - 1;
        dp1[l][r] = INF, dp2[l][r] = -INF;
        for(int k = l; k < r; k++)
        {
            dp1[l][r] = min(dp1[l][r], dp1[l][k] + dp1[k + 1][r] + s[r] - s[l - 1]);
            dp2[l][r] = max(dp2[l][r], dp2[l][k] + dp2[k + 1][r] + s[r] - s[l - 1]);
        }
    }

int minv = INF, maxv = -INF;
for(int i = 1; i <= n; i++)
{
    minv = min(minv, dp1[i][i + n - 1]);
    maxv = max(maxv, dp2[i][i + n - 1]);
}
cout << minv << '\n' << maxv << endl;
```

<br>

> [AcWing 320. 能量项链](https://www.acwing.com/problem/content/description/322/)

> 环形DP $\Longrightarrow$ 破环成链
>
> + 状态表示 $f[l, r]$ 
>   + 集合: 区间 $[l, r]$ 内的珠子合并后的得分
>   + 属性: $max$ 
> + 状态转移
>   + $f_[l, r] = max \{f_{l, k} + f_{k, r} + w_l \cdot w_k \cdot w_r \}$ 
> + 答案 = $max \{f[i][i + n]\} (1 \le i \le n)$ 

```c++
for(int i = 1; i <= n; i++)
{
    cin >> w[i];
    w[i + n] = w[i];
}

for(int len = 3; len <= n + 1; len ++)
    for(int l = 1; l + len - 1 <= n * 2; l++)
    {
        int r = l + len - 1;
        for(int k = l + 1; k < r; k++)
            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + w[l] * w[k] * w[r]);
    }

int res = 0;
for(int i = 1; i <= n; i++)
    res = max(res, dp[i][i + n]);
cout << res << endl;
```

<br>

> [AcWing 1069. 凸多边形的划分](https://www.acwing.com/problem/content/description/1071/)

> + 状态表示 $f[l][r]$ 
>   + 集合: 区间 $[l, r]$ 内的顶点划分三角形后各权值乘积之和
>   + 属性: $min$ 
> + 状态转移
>   + $f_[l, r] = min \{f_{l, k} + f_{k, r} + w_l \cdot w_k \cdot w_r\}$ 
> + 为什么不用破环成链?
>   + 因为划分完三角形后, 凸多边形的所有边都一定是某个三角形的一边, 即每条边都一定存在

```c++
//朴素版
for(int len = 3; len <= n; len ++)
    for(int l = 1; l + len - 1 <= n; l++)
    {
        int r = l + len - 1;
        dp[l][r] = INF;
        for(int k = l + 1; k < r; k++)
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k][r] + w[l] * w[k] * w[r]);
    }
cout << dp[1][n] << endl;
```

```c++
//高精度
int n, w[N];
LL f[N][N][M], temp[M];

//高精度乘法
void mul(LL a[], LL b)
{
    LL c[M] = {0}, t = 0;
    for(int i = 0; i < M; i++)
    {
        t += a[i] * b;
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

//高精度加法
void add(LL a[], LL b[])
{
    LL c[M] = {0};
    for(int i = 0, t = 0; i < M; i++)
    {
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

//高精度比较
int cmp(LL a[], LL b[])
{
    for(int i = M - 1; i >= 0; i--)
        if(a[i] > b[i]) return 1;
    	else if(a[i] < b[i]) return -1;
    return 0;
}

//高精度打印
void print(LL a[])
{
    int k = M - 1;
    while(k & !a[k]) k --;
    while(k >= 0) cout << a[k --];
}

int main()
{
    for(int len = 3; len <= n; len ++)
    	for(int l = 1; l + len - 1 <= n; l++)
        {
            int r = l + len - 1;
            dp[l][r][M - 1] = 1;	//初始化为正无穷
			for(int k = l + 1; k < r; k++)
            {
                memset(temp, 0, sizeof temp);
                temp[0] = w[l];
                mul(temp, w[k]);
                mul(temp, w[r]);
                add(temp, dp[l][k]);
                add(temp, dp[k][r]);
                if(cmp(temp, dp[l][r]) < 0)
                    memcpy(dp[l][r], temp, sizeof temp);
            }
        }
    
    print(dp[1][n]);
}
```

<br>

> [AcWing 321. 棋盘分割](https://www.acwing.com/problem/content/description/323/)

> + 状态表示 $f[x_1, y_1, x_2, y_2, k]$ 
>   + 集合: 子矩阵 $[x_1, y_1, x_2, y_2]$ 砍 $k$ 🔪后的均方差
>   + 属性: $min$ 
> + 状态转移
>   + 横着切: $min(dp(x_1, y_1, i, y_2, k - 1) + get(i + 1, y_1, x_2, y_2), dp(i + 1, y_1, x_2, y_2, k + 1) + get(x_1, y_1, i, y_2))$ 
>   + 竖着切: $min(dp(x_1, y_1, x_2, i, k + 1) + get(x_1, i + 1, x_2, y_2), dp(x_1, i + 1, x_2, y_2, k + 1) + get(x_1, y_1, x_2, i))$ 

```c++
int n, m = 8;
int s[M][M];
double f[M][M][M][M][N];
double X;	//平均值

int get_sum(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x2f][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
}

double get(int x1, int y1, int x2, int y2)
{
    double sum = get_sum(x1, y1, x2, y2) - X;
    return sum * sum / n;
}

//记忆化搜索
double dp(int x1, int y1, int x2, int y2, int k)
{
    double &v = f[x1][y1][x2][y2][k];
    if(v >= 0) return v;
    if(k == 1) return v = get(x1, y1, x2, y2);
    
    v = INF;
    for(int i = x1; i < x2; i++)	//横着切
    {
        v = min(v, dp(i + 1, y1, x2, y2, k - 1) + get(x1, y1, i, y2));
        v = min(v, dp(x1, y1, i, y2, k - 1) + get(i + 1, y1, x2, y2));
    }
    for(int i = y1; i < y2; i++)	//竖着切
    {
        v = min(v, dp(x1, i + 1, x2, y2, k - 1) + get(x1, y1, x2, i));
        v = min(v, dp(x1, y1, x2, i, k - 1) + get(x1, i + 1, x2, y2));
    }
    
    return v;
}

int main()
{
    cin >> n;
    for(int i = 1; i <= m; i++)
        for(int j = 1; j <= m; j++)
        {
            cin >> s[i][j];
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }
    
    X = (double)s[m][m] / n;
    memset(f, -1, sizeof f);
    
    printf("%.3lf\n", sqrt(dp(1, 1, m, m, n)));
}
```



<div style="page-break-after:always;"></div>

# 树形DP

### 根题

> [AcWing 285. 没有上司的舞会](https://www.acwing.com/problem/content/description/287/)

> **思路**
>
> 1. 建立树, 找到该树的根节点 $root$ , 并 $dfs(root)$ 
> 2. $dp[u][0]$ 表示从以 $u$ 为根节点的子树里面选, 不选 $u$ 这个点的最大快乐值
> 3. $dp[u][1]$ 表示从以 $u$ 为根节点的子树里面选, 选择 $u$ 这个点的最大快乐值
> 4. 如果不选 $u$ 这个点, 那么它的儿子就可选可不选, $dp[u][0] += max(dp[j][0], dp[j][1])$
> 5. 如果选择 $u$ 这个点, 那么它的儿子就都不能选, $dp[u][1] += dp[j][0]$ 

```c++
void dfs(int u)
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        dp[u][0] += max(dp[j][0], dp[j][1]);
        dp[u][1] += dp[j][0];
    }
}

int main()
{
    dfs(root);
    cout << max(dp[root][0], dp[root][1]) << endl;
}
```

<br>

### 衍生题

> [AcWing 1072. 树的最长直径](https://www.acwing.com/problem/content/1074/)

> + 状态表示 $dp_{0/1, i}$ 
>   + 集合: 以节点 $i$ 为根的子树中, 从子树某一个节点到 $i$ 的最长路为 $dp_{0, i}$ , 次长路为 $dp_{1, i}$ 
>   + 属性: $max$ 
> + 状态计算
>   + 如果子节点的最长路加上对应边后大于当前的最长路, 那么就更新最长路
>   + 否则如果大于次长路, 那么就更新次长路
>   + 状态转移方程
>     + $dp_{0, i} = max_{s \in son_i} \{dp_{0, s} + w_{i, s} \}$ 
>     + $dp_{1, i} = max_{s \in son_i \& dp_{0, s} + w_{i, s} < dp_{0, s}} \{dp_{0, s} + w_{i, s} \}$ 

```c++
int dfs(int u, int fa)
{
    int d1 = 0, d2 = 0;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        int d = dfs(j, u) + w[i];
        if(d > d1) d2 = d1, d1 = d;
        else if(d > d2) d2 = d;
    }
    
    ans = max(ans, d1 + d2);
    return d1;
}
```

<br>

> [AcWing 1073. 树的中心](https://www.acwing.com/problem/content/description/1075/)

> 这个问题是 **树形DP** 中的一类经典模型, 常被称作 **换根DP**
>
> 在确定树的拓扑结构后单独求一个节点的最远距离时, 会在该树上比较哪些路径?
>
> 1. 从当前节点往下, 到子树中某个节点的最长路径
> 2. 从当前节点往上走到其父节点, 再从其父节点出发且不会到该节点的最长路径
>
> 此处就要引入 **换根DP** 的思想了
>
> **换根DP** 一般分为三个步骤:
>
> 1. 指定任意一个根节点
> 2. 一次 $dfs$ 遍历, 统计出当前子树内的节点对当前节点的贡献
> 3. 一次 $dfs$ 遍历, 统计出当前节点的父节点对当前节点的贡献, 然后合并统计答案
>
> 先 $dfs$ 一遍, 预处理出当前子树对于根的最大距离和次大距离
>
> 处理次大距离的原因是: 如果当前节点是其父节点子树的最大路径上的点, 则父节点子树的最大贡献不能算作对该节点的贡献
>
> 再 $dfs$ 一遍, 求解出每个节点的父节点对它的贡献, 两者比较, 取一个 $max$ 即可

```c++
int dfs1(int u, int fa)
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        int d = dfs1(j, u) + w[i];
        if(d > d1[u]) d2[u] = d1[u], d1[u] = d;
        else if(d > d2[u]) d2[u] = d;
    }
    
    return d1[u];
}

void dfs2(int u, int fa)
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        up[j] = d1[u] == d1[j] + w[i] ? max(d2[u], up[u]) + w[i] : max(d1[u], up[u]) + w[i];
        dfs2(j, u);
    }
}

int main()
{
    dfs1(1, -1);
    dfs2(1, -1);
    
    int ans = INF;
    for(int i = 1; i <= n; i++)
        ans = min(ans, max(d1[i], up[i]));
}
```



<div style="page-break-after:always;"></div>

# 数位DP

### 数位DP基本概念

**数位:** 把一个数字按照**个、十、百、千**等一位一位地拆开, 关注它每一位上的数字

如果拆的是 **十进制数** , 那么每一位数字都是 $0$ ~ $9$ , 其他进制可 **类比** 十进制

**数位DP:** 用来解决一类特定问题, 这种问题比较好辨认, 一般具有这几个特征: 

+ 要求统计满足一定条件的数的数量 (即, 最终目的为计数)
+ 这些条件经过转化后可以使用 「数位」的思想去理解和判断
+ 输入会提供一个数字区间 (有时也只提供上界) 来作为统计的限制
+ 上界很大 (比如 $10^9$ ), 暴力枚举验证会超时

从题目中分析出 **数位DP** 的模型后, 做法就非常的 **套路化** 了

题目要求 **一段区间** 内符合某些条件的数的个数, 我们用 **前缀和思想** 转换为求两个 **前缀区间** 的问题 $res[l, r] = res[1, r] - res[1, l - 1]$ 

接下来的问题就是统计答案

统计答案可以选择 **记忆化搜索** , 也可以选择 **循环迭代递推**

为了不重不漏地统计所有不超过上限的答案, 要 **从高到低** 枚举每一位

再考虑每一位都可以 **填哪些数字** , 最后利用上述 **前缀和思想** 统计答案

**记忆化搜索** 中要引入的参数通常有:

1. 当前枚举到的数位 $pos$ (搜索的深度)
2. 前一位数 (或是前几位数) 的情况 $pre$ (诸如 **前一位是什么、前几位总和是多少、某个数出现了几次** 等)
3. 前几位的数字是否等于上界的前几位数字 $limit \ (0/1)$ (限制本次搜索的数位范围)
4. 是否有前导零 $lead \ (0/1)$ 

**何时能用** **记忆化搜索** **优化掉当前搜索分支**

当当前数位能够枚举集合内所有元素的时候(没有贴着上界), 即 `!limit` 

<br>

---

### 数位DP 的 DFS 写法

数位 DP 问题一般是给定一个区间 $[L, R]$ , 问区间满足的条件的数有多少个

可以利用前缀和来求解答案: $\sum\limits_{i = 1}^{R} ans_i - \sum\limits_{i = 1}^{L - 1} ans_i$ 

### 模板 (伪代码)

```c++
int dfs(int pos, int pre, int lead, int limit)
{
    if(!pos)
    {
        //边界条件
    }
    if(!limit && !lead && dp[pos][pre] != -1) return dp[pos][pre];
    int res = 0, up = limit ? a[pos] : 无限制位;
    for(int i = 0; i <= up; i++)
    {
        if(不合法条件) continue;
        res += dfs(pos - 1, 未定参数, lead && !i, limit && i == up);
    }
    return limit ? res : (lead ? res : dp[pos][sum] = res);
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % 进制, x /= 进制;
    return dfs(len, 未定参数, 1, 1);
}

signed main()
{
    cin >> l >> r;
    cout << cal(r) - cal(l - 1) << endl;
}
```

### cal函数 (一般情况)

**注意每次初始化 DP 数组为 $-1$ , 长度 $len = 0$**

### 基本参数

$len$ : 数位长度, 一般根据这个来确定数组范围

$a_i$ : 每个数位具体数字

返回值 $return$ 根据题目的初始条件来确定前导 $0$ 以及 $pre$ 

### DFS 函数 (一般情况)

变量 $res$ 来记录答案, 初始化一般为 $0$ 

变量 $up$ 表示能枚举的最高位数

采用记忆化搜索的方式:

`if(!limit && !lead && dp[pos][pre] != -1) return dp[pos][pre];` 

> 只有无限制、无前导零才算, 不然都是未搜索完的情况

`return limit ? res : dp[pos][pre] = res;` 

> 如果最后还有限制, 那么返回 `res` , 否则返回 `dp[pos][pre]` 

### 基本参数

假设数字 $x$ 位数为 $a_1 \cdots a_n$ 

**必填参数:**

$pos$ : 表示数字的位数

> 从末位或第一位开始, 要根据题目的数字构造性质来选择顺序, 一般选择从 $a_1$ 到 $a_n$ 的顺序. 初始从 $len$ 开始的话, 边界条件应该是 $pos = 0$ , 限制位数应该是 $a_{pos}$ , DFS 时 $pos - 1$ ; 初始从 $1$ 开始的话, 边界条件应该是 $pos > len$ , 限制位数应该是 $a_{len - pos + 1}$ , DFS时 $pos + 1$ . 两种都可以, 看个人习惯

$limit$ : 可以填数的限制 (无限制的话 $(limit = 0)$ $0$ ~ $9$ 随便填, 否则只能填到 $a_i$ )

> 如果搜索到 $a_1 \cdots a_{pos} \cdots a_n$ , 原数位为 $a_1 \cdots a_k \cdots a_n$ , 那么我们必须对接下来搜索的数加以限制, 也就是不能超过区间右端点 $R$ , 所以要引入 $limit$ 这个参数, 如果 $limit = 1$ , 那么最高位数 $up \le a_{pos + 1}$ , 如果没有限制, 那么 $up = 9$ (十进制下) 这也就是确定搜索位数上界的语句 `limit ? a[pos] : 9;` 
>
> 如果 $limit = 1$ 且已经取到了能取到的最高位时 $(a_{pos} = a_k)$ , 那么下一个 $limit = 1$ 
>
> 如果 $limit = 1$ 且没有取到能取到的最高位时 $(a_{pos} < a_k)$ , 那么下一个 $limit = 0$ 
>
> 如果 $limit = 0$ , 那么下一个 $limit = 0$ , 因为前一位没有限制后一位必定没有限制
>
> 所以我们可以把这 $3$ 种情况合成一个语句进行下一次搜索: `limit && i == up` ( $i$ 为当前枚举的数字)

**可选参数:**

$pre$ : 表示上一个数是多少

> 有些题目会用到前面的数

$lead$ : 前导零是否存在, $lead = 1$ 存在前导零, 否则不存在

> 一般来说有些题目不加限制前导零会影响数字结构, 所以 $lead$ 是一个很重要的参数
>
> 如果 $lead = 1$ 且当前位为 $0$ , 那么说明当前位是前导 $0$ , 继续搜索 $pos + 1$ , 其他条件不变
>
> 如果 $lead = 1$ 且当前位不为 $0$ , 那么说明当前位的最高位, 继续搜索 $pos + 1$ , 条件变动
>
> 如果 $lead = 0$ , 则不需要操作

$sum$ : 搜索到当前所有数字之和

> 有些题目会出现数字之和的条件

$cnt$ : 某个数字出现的次数

> 有些题目会出现某个数字出现次数的条件

<br>

---

### [AcWing 1081. 度的数量](https://www.acwing.com/problem/content/description/1083/)

> 题意: 找到区间 $[L, R]$ 恰好为 $K$ 个 $B$ 的幂次方之和的数的个数
>
> 分析: 前导零不影响, 所以不需要 $lead$ . 因为需要记录数量, 所以要增加变量 $cnt$ . 前驱 $pre$ 不需要记录. 判断边界时只要最后数量 $cnt = K$ , 返回 $1$ , 否则返回 $0$ . 同时枚举数字时如果前面系数不为 $1$ 或者没搜索完就已经 $K$ 个了, 那么就 `continue` 

```c++
int l, r, K, B;
int a[N], len, dp[N][N];

int dfs(int pos, int cnt, int limit)
{
    if(!pos) return cnt == K;
    if(!limit && dp[pos][cnt] != -1) return dp[pos][cnt];
    int res = 0, up = limit ? a[pos] : B - 1;
    for(int i = 0; i <= up; i++)
    {
        if((i == 1 && cnt == K) || i > 1) continue;
        res += dfs(pos - 1, cnt + (i == 1), limit && i == up);
    }
    return limit ? res : dp[pos][cnt] = res;
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % B, x /= B;
    return dfs(len, 0, 1);
}

signed main()
{
    cin >> l >> r >> K >> B;
    cout << cal(r) - cal(l - 1) << endl;
}
```

<br>

### [AcWing 1082. 数字游戏](https://www.acwing.com/problem/content/description/1084/)

> 题意: 找到区间 $[L, R]$ 各位数字非严格单调递增的数的个数
>
> 分析: 前导零不影响, 所以不需要 $lead$ . 只需要判断枚举的位数是不是非严格单调递增来判断搜索是否继续

```c++
int l, r;
int a[N], len, dp[N][N];

int dfs(int pos, int pre, int limit)
{
    if(!pos) return 1;
    if(!limit && dp[pos][pre] != -1) return dp[pos][pre];
    int res = 0, up = limit ? a[pos] : 9;
    for(int i = pre; i <= up; i++)
        res += dfs(pos - 1, i, limit & i == up);
    return limit ? res : dp[pos][pre] = res;
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % 10, x /= 10;
    return dfs(len, 0, 1);
}

signed main()
{
    while(cin >> l >> r)
        cout << cal(r) - cal(l - 1) << endl;
}
```

<br>

### [AcWing 1083. Windy数](https://www.acwing.com/problem/content/description/1085/)

> 题意: 找到区间 $[L, R]$ 相邻数字之差至少为 $2$ 的数的个数
>
> 分析: 搜索初始条件第二个参数 $pre$ 必须填一个 $\le -2$ 的数来保证可以继续搜索下去, 不然会出错. 此题需要记录前导零, 不然忽视前导零的影响会造成最高位数 $0 - 0 = 0 < 2$ 无法继续搜索的情况

```c++
int l, r;
int a[N], len, dp[N][N];

int dfs(int pos, int pre, int lead, int limit)
{
    if(!pos) return 1;
    if(!limit && !lead && dp[pos][pre] != -1) return dp[pos][pre];
    int res = 0, up = limit ? a[pos] : 9;
    for(int i = 0; i <= up; i++)
    {
        if(abs(pre - i) < 2) continue;
        res += dfs(pos - 1, lead && !i ? -2 : i, lead && !i, limit && i == up);
    }
    return limit || lead ? res : dp[pos][pre] = res;
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % 10, x /= 10;
    return dfs(len, -2, 1, 1);
}

signed main()
{
    cin >> l >> r;
    cout << cal(r) - cal(l - 1) << endl;
}
```

<br>

### [AcWing 1084. 数字游戏Ⅱ](https://www.acwing.com/problem/content/description/1086/)

> 题意: 找到区间 $[L, R]$ 各位数字之和 $mod \ N = 0$ 的数的个数
>
> 分析: 前导零不影响, 所以不需要 $lead$ . 此题涉及到数字和, 所以要用到 $sum$ , 不需要记录前驱 $pre$ , 所以 $dp$ 状态变为了 $dp[pos][sum]$ . 边界条件位 $sum \ \% \ n == 0$ 

```c++
int l, r, p;
int a[N], len, dp[N][M];

int dfs(int pos, int sum, int limit)
{
    if(!pos) return sum % p == 0;
    if(!limit && dp[pos][sum] != -1) return dp[pos][sum];
    int res = 0, up = limit ? a[pos] : 9;
    for(int i = 0; i <= up; i++)
        res += dfs(pos - 1, sum + i, limit && i == up);
    return limit ? res : dp[pos][sum] = res;
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % 10, x /= 10;
    return dfs(len, 0, 1);
}

signed main()
{
    while(cin >> l >> r >> p)
        cout << cal(r) - cal(l - 1) << endl;
}
```

<br>

### [AcWing 1085. 不要62](https://www.acwing.com/problem/content/description/1087/)

> 题意: 找到区间 $[L, R]$ 不能出现 $4$ 和 $62$ 的数的个数
>
> 分析: 首先此题不需要 $lead$ , 其次有 $62$ 所以要记录前驱 $pre$ 

```c++
int l, r;
int a[N], len, dp[N][N];

int dfs(int pos, int pre, int limit)
{
    if(!pos) return 1;
    if(!limit && dp[pos][pre] != -1) return dp[pos][pre];
    int res = 0, up = limit ? a[pos] : 9;
    for(int i = 0; i <= up; i++)
    {
        if(i == 4 || (pre == 6 && i == 2)) continue;
        res += dfs(pos - 1, i, limit && i == up);
    }
    return limit ? res : dp[pos][pre] = res;
}

int cal(int x)
{
    memset(dp, -1, sizeof dp);
    len = 0;
    while(x) a[++ len] = x % 10, x /= 10;
    return dfs(len, 0, 1);
}

signed main()
{
    while(cin >> l >> r, l)
        cout << cal(r) - cal(l - 1) << endl;
}
```



<div style="page-break-after:always;"></div>

# 单调队列优化DP

### 根题

> [AcWing 154. 滑动窗口](https://www.acwing.com/problem/content/description/156/)

> 题意: 求大小为 $k$ 的滑动窗口, 从数组的最左边移动到最右边, 滑动窗口位于每个位置时, 窗口中的最大值和最小值
>
> 解题思路 (以最大值为例):
>
> + 如果当前的滑动窗口中有两个下标 `i` 和 `j` , 其中 `i` 在 `j` 的左侧( `i` < `j` ) , 并且 `i` 对应的元素不大于 `j` 对应的元素( `num[i]` < `num[j]` ) , 则
>
>   当滑动窗口向右移动时, 只要 `i` 还在窗口中, 那么 `j` 一定也还在窗口中. 这是由于 `i ` 在 `j` 的左侧所保证的
>
>   因此, 由于 `num[j]` 的存在, `num[i]` 一定不会是滑动窗口中的最大值, 可以将 `nums[i]` 永久地移除
>
> + 因此可以使用一个队列存储所有还没被移除的下标. 在队列中, 这些下标按照从小到大的顺序被存储, 并且它们在数组 `nums` 中对应的值是严格单调递增的
>
> + 当滑动窗口向右移动时, 需要把一个新的元素放入队列中
>
>   为了保持队列的性质, 会不断地将新的元素与队尾的元素相比较, 如果新元素大于队尾元素, 那么队尾的元素就可以被永久地移除, 将其弹出队列. 需要不断地进行此项操作, 直到队列为空或者新的元素小于队尾的元素
>
> + 由于队列中下标对应的元素是严格单调递减的, 因此此时队首下标对应的元素就是滑动窗口中的最大值
>
> + 窗口向右移动的时候, 还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的, 因此当队头元素在窗口的左边的时候, 弹出队头

```c++
//求最小值
deque<int> q;
for(int i = 1; i <= n; i++)
{
    while(q.size() && w[q.back()] >= w[i]) q.pop_back();
    q.push_back(i);
    while(q.size() && i - k >= q.front()) q.pop_front();
    if(i >= k) cout << w[q.front()] << ' ';
}

//求最大值
for(int i = 1; i <= n; i++)
{
    while(q.size() && w[q.back()] <= w[i]) q.pop_back();
    q.push_back(i);
    while(q.size() && i - k >= q.front()) q.pop_front();
    if(i >= k) cout << w[q.front()] << ' ';
} 
```

<br>

---

### 衍生题

> [AcWing 135. 最大子序和](https://www.acwing.com/problem/content/description/137/)

> + 状态表示 $dp[i]$ 
>   + 集合: 以 $i$ 为右端点, 长度不超过 $m$ 的连续子区间
>   + 属性: $max$ 
> + 状态转移
>   + $dp_i = max \{s_i - s_j \} = s_i - min \{s_j \}$ $(i - m \le j \le i - 1)$ ($s$ 为前缀和数组)
>   + 即对于每一个 $s_i$ 找到一个 $min \{s_j \}$ , 可用单调队列来维护
>   + $res = max \{ dp_i\}$ 

```c++
int main()
{
	cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        s[i] += s[i - 1];
    }
    
    deque<int> q;
    q.push_back(0);
    int res = -INF;
    for(int i = 1; i <= n; i++)
    {
        if(q.front() < i - m) q.pop_front();
        res = max(res, s[i] - s[q.front()]);
        while(q.size() && s[q.back()] >= s[i]) q.pop_back();
        q.push_back(i);
    }
    cout << res << endl;
}
```

<br>

> [AcWing 1088. 旅行问题](https://www.acwing.com/problem/content/description/1090/)

> + 状态表示 $dp[i]$ 
>   + 集合: 以 $i$ 为起点, 顺时针走一圈的方案
>   + 属性: $bool$ 
> + 状态转移
>   + $s[i]$ 表示从 $1$ 到 $i$ 的加油量 $-$ 消耗的油量
>   + $dp_i = min \{s_j - s_{i - 1} \} = min \{s_j \} - s_{i - 1} \ge 0$ $(i \le j \le i + n - 1)$ 
>   + 即对于每一个 $s_i$ , 找到一个 $min \{s_j \}$ , 可用单调队列来维护

```c++
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> p[i] >> d[i];
        p[n + i] = p[i], d[n + i] = d[i];	//破环成链
    }
    
    //顺时针
    for(int i = 1; i <= n * 2; i++)
        s[i] = s[i - 1] + p[i] - d[i];
    deque<int> q;
    for(int i = n * 2; i >= 1; i--)
    {
        if(q.size() && q.front() - i > n - 1) q.pop_front();
        while(q.size() && s[q.back()] >= s[i]) q.pop_back();
        q.push_back(i);
        if(i <= n) dp[i] = s[q.front()] - s[i - 1] >= 0;
    }
    
    //逆时针
    d[0] = d[n];
    for(int i = 1; i <= n * 2; i++)
        s[i] = s[i - 1] + p[i] - d[i - 1];
    while(q.size()) q.pop_back();
    for(int i = 0; i < n * 2; i++)
    {
        if(q.size() && i - q.front() > n - 1) q.pop_front();
        while(q.size() && s[q.back()] <= s[i]) q.pop_back();
        q.push_back(i);
        if(i >= n) dp[i + 1 - n] |= s[i + 1] - s[q.front()] >= 0;
    } 
}
```

<br>

> [AcWing 1089. 烽火传递](https://www.acwing.com/problem/content/description/1091/)

> + 状态表示 $dp[i]$ 
>   + 集合: 以 $i$ 为右端点, 选择第 $i$ 个元素的代价的集合
>   + 属性: $min$ 
> + 状态转移
>   + $dp_i = min \{dp_j \} + w_i$ $(i - m \le j \le i - 1)$ 
>   + $min \{dp_j \}$ 可以用单调队列来维护
>   + $res = min \{dp_i \}$ $(n - m + 1 \le i \le n)$ 

```c++
int main()
{
    deque<int> q;
    q.push_back(0);
    for(int i = 1; i <= n; i++)
    {
        if(i - q.front() > m) q.pop_front();
        dp[i] = dp[q.front()] + w[i];
        while(q.size() && dp[i] <= dp[q.back()]) q.pop_back();
        q.push_back(i);
    }
    
    int res = INF;
    for(int i = 0; i < m; i++)
        res = min(res, dp[n - i]);
}
```

<br>

> [AcWing 1090. 绿色通道](https://www.acwing.com/problem/content/description/1092/)

> + 二分答案找出满足条件的最小长度
> + 状态表示 $dp[i]$ 
>   + 集合: 以 $i$ 为右端点, 选择第 $i$ 个元素的代价的集合
>   + 属性: $min$ 
> + 状态转移
>   + $dp_i = min \{dp_j \} + w_i$ $(i - m - 1 \le j \le i - 1)$ 
>   + $min \{dp_j \}$ 可以用单调队列来维护
>   + $res = min \{dp_i \}$ $(n - m \le i \le n)$ 

```c++
bool check(int k)
{
    memset(dp, 0, sizeof dp);
    deque<int> q;
    q.push_back(0);
    
    for(int i = 1; i <= n; i++)
    {
        if(i - q.front() > k + 1) q.pop_back();
        dp[i] = dp[q.front()] + w[i];
        while(q.size() && dp[i] <= dp[q.back()]) q.pop_back();
        q.push_back(i);
    }
    
    int res = INF;
    for(int i = 0; i <= k; i++)
        res = min(res, dp[n - i]);
    return res <= m;
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> w[i];
    
    int l = 0, r = n;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
}
```

<br>

> [AcWing 1087. 修剪草坪](https://www.acwing.com/problem/content/description/1089/)

> + 状态表示 $dp[i]$ 
>
>   + 集合: 从前 $i$ 头牛中选得到的价值
>   + 属性: $max$
>
> + 状态转移
>
>   + 不选第 $i$ 头牛: $dp[i] = dp[i - 1]$ 
>
>   + 选第 $i$ 头牛, 枚举 $j$ 为以 $i$ 为结尾的连续区间的长度, $s[i]$ 表示前缀和
>
>     $dp[i] = dp[i - j - 1] + s[i] - s[i - j]$ $(1 \le j \le k)$ 

```c++
int main()
{
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        s[i] += s[i - 1];
    }
    
    deque<int> q;
    q.push_back(0);
    for(int i = 1; i <= n; i++)
    {
        if(i - q.front() > k) q.pop_back();
        dp[i] = max(dp[i - 1], dp[max(q.front() - 1), 0] + s[i] - s[q.front()]);
        while(q.size() && dp[max(q.back() - 1), 0] - s[q.back()] <= dp[max(i - 1, 0)] - s[i]) q.pop_back();
        q.push_back(i);
    }
}
```

<br>

> [AcWing 1091. 理想的正方形](https://www.acwing.com/problem/content/description/1093/)

> 1. 枚举每一行, 对于这一行, 将最值放入滑动窗口的最右边
> 2. 枚举每一列, 对于这一列, 将最值放入滑动窗口的最下边
> 3. 如此一来, $k \times k$ 的正方形的最值就在右下角

```c++
int n, m, k;
int w[N][N];
int row_min[N][N], row_max[N][N];
int q[N];

//将最小值放到滑动窗口的最右边
void get_min(int a[], int b[], int tot)
{
    int hh = 0, tt = 0;
    for(int i = 1; i <= tot; i++)
    {
        if(q[hh] < i - k + 1) hh ++;
        while(hh <= tt && a[q[tt]] >= a[i]) tt --;
        q[++ tt] = i;
        b[i] = a[q[hh]];
    }
}

//将最大值放到滑动窗口的最右边
void get_max(int a[], int b[], int tot)
{
    int hh = 0, tt = 0;
    for(int i = 1; i <= tot; i++)
    {
        if(q[hh] < i - k + 1) hh ++;
        while(hh <= tt && a[q[tt]] <= a[i]) tt --;
        q[++ tt] = i;
        b[i] = a[q[hh]];
    }
}

int main()
{
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> w[i][j];
    
    //枚举每一行
    for(int i = 1; i <= n; i++)
    {
        //将最值放到滑动窗口的最右边
        get_min(w[i], row_min[i], m);
        get_max(w[i], row_max[i], m);
    }
    
    //枚举每一列
    int a[N], b[N], c[N], res = INF;
    for(int i = k; i <= m; i++)
    {
        //将最值放到滑动窗口的最下边
        for(int j = 1; j <= n; j++)
            a[j] = row_min[j][i];
        get_min(a, b, n);
        for(int j = 1; j <= n; j++)
            a[j] = row_max[j][i];
        get_max(a, c, n);
        
        //k * k 的正方形的最值就在右下角
        for(int j = k; j <= n; j++)
            res = min(res, c[j] - b[j]);
    }
}
```



<div style="page-break-after:always;"></div>

# 斜率优化DP

### 斜率优化DP模板

1. 将初始状态入队
2. 每次使用一条和 $i$ 相关的直线 $f_i$ 去切维护的凸包, 找到最优决策, 更新 $dp_i$ 
3. 加入状态 $dp_i$ . 如果一个状态 (即凸包上的一个点) 在 $dp_i$ 加入后不再是凸包上的点, 需要在 $dp_i$ 加入之前剔除

> 斜率优化往往还要再套一层 单调队列/二分/CDQ/平衡树优化

<br>

---

### 引子 (线性DP + 费用提前计算思想)

[AcWing 300. 任务安排1](https://www.acwing.com/problem/content/description/302/)

**题目描述**

有 $n$ 个 **任务** 排成一个 **序列** ,  **顺序不得改变** , 其中第 $i$ 个 **任务** 的 **耗时** 为 $t_i$ ,  **费用系数** 为 $c_i$ 

现需要把该 $n$ 个 **任务** 分成 **若干批** 进行加工处理

每批次的 **段头** , 需要 **额外消耗**  $S$ 的时间启动机器. 每个任务的 **完成时间** 是所在 **批次** 的 **结束时间**

完成一个任务的 **费用** 为: 从 $0$  **时刻** 到该任务 **所在批次结束** 的时间 $t$ 乘以 该任务 **费用系数**  $c$ 

**分析**

对于该类序列, 考虑用 **动态规划** 进行子问题划分求解再合并集合

**如何进行状态表示:**

**状态表示-集合 $f_{i, j}$ :** 考虑前 $i$ 个 **任务** , 且当前第 $i$ 个 **任务** 是第 $j$ 个 **批次** 的 **最后一个任务** 的 **方案**

**状态表示-属性 $f_{i, j}$ :** 方案的贡献 **最小** $Min$ 

**转移方程:** $f_{i, j} = min ( f_{k, j - 1} + (S \times j + \sum\limits_{u = 1}^{i} t_u) \times \sum\limits_{u = k + 1}^{i} c_u)$ 

**两位状态** 套一个 **决策变量** , 时间复杂度为 $O(n^3)$ 

**经典的优化思想 :** **费用提前计算** 思想

题目中并没有说, 我们 **至多** 只能够把任务分成 $k$ 批次, 可是在 **DP** 中我们却人为的引入了参数 $j$ , 仅仅只是因为我们在计算 **当前状态** 时, 需要知道 $S$ 对于 **该批次** $j$ 的 **贡献** : $S_{cost_j} = S \times j$ 

然而, 比起 $j$ 对 $f_i$ 的 **影响** , 我们 **实际上** 关心的是 $S$ 对 $f_i$ 的 **影响**

> $j$ 是为了求出 $S$ 对 $f_i$ 的影响, 而被我们额外引入的参数

若当前为 $[l, r]$ 的 **任务** 开一个新 **批次** , 那么 **该批次** 机器的 **启动时间** $S$ 会 **影响** 的 **任务** 有 $[l, n]$ , 那么我们不妨用 **费用提前计算** 思想, 把该段 $[l, n]$ 的 $S$ **费用** 直接累加到 **当前状态** $f_i$ 上计算. 这样, 省掉了 **一维** 状态表示

**一维状态 + 一个决策变量** , 时间复杂度为 $O(n^2)$ 

$f_i = min ( f_j + S \times \sum\limits_{k = j + 1}^{n} c_k + \sum\limits_{k = 1}^{i} t_k \times \sum\limits_{k = j + 1}^{i} c_k)$ 

前缀和优化: $f_i = min ( f_j + S \times (sc_n - sc_j) + st_i \times (sc_i - sc_j))$ 

```c++
int n, S;
LL st[N], sc[N], dp[N];

int main()
{
    cin >> n >> S;
    for(int i = 1; i <= n; i++)
    {
        cin >> st[i] >> sc[i];
        st[i] += st[i - 1], sc[i] += sc[i - 1];
    }
    
    memset(dp, 0x3f, sizeof dp);
    dp[0] = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 0; j < i; j++)
            dp[i] = min(dp[i], dp[j] + S * (sc[n] - sc[j]) + st[i] * (sc[i] - sc[j]));
    
    cout << dp[n] << endl;
}
```

<br>

---

### 斜率优化DP (凸包优化DP)

[AcWing 301. 任务安排2](https://www.acwing.com/problem/content/description/303/)

朴素版的 **状态转移方程:**

$f_i = min ( f_j + S \times (sc_n - sc_j) + st_i \times (sc_i - sc_j))$ 

提出式子中 **含有单独 $i$ 的常量** : $f_i = st_i \times sc_i + S \times sc_n + min ( f_j - S \times sc_j - st_i \times sc_j)$ 

考察 $min$ 函数内部的 **多项式** : $f_j = sc_j \times (S + st_i)$ 

该式子中, 有 $i \times j$ 的项, 因此不能直接用 **滑动窗口** 来维护一个前缀的 **最值**

但是 **分析的思想** 可以继承, 我们知道含 $i$ 的项是一个 **常量** , 故该 **多项式** 就能够 **抽象** 成如下形式: $f_j - sc_j \times (S + st_i) = 变量1 - 变量2 \times (常量S + 常量i)$ 

**变量1** $f_j$ 是与 $j$ 有关的 **变量** , **变量2** $sc_j$ 也是与 $j$ 有关的 **变量**

因此, 不妨令 $f_j = y(j)$ , $sc_j = x(j)$ , $k = S + st_i$ , 则该函数可以化为 $y(j) - k \cdot x(j)$ 

求 $y - kx$ $(0 \le j < i)$ 函数的极值问题, 可以直观想到 **直线的斜截式方程** : $y = kx + b$ 

对 **直线的斜截式方程** 进行变形: $b = y - kx$ 

要求 $y - kx$ $(0 \le j < i)$ 函数的极值, 就是求一个点 $(x_j, y_j)$ 与当前 $k_i$ 构成的 **所有直线** 中, **y轴截距最小**

我们 **从下往上 (截距从小到大)** 去逼近当前 **所有的点** , 则 **第一个** 出现在直线上的点, 就是满足 $b_i = y_j - kx_j$ 的 **最小截距** $b_i$ , 即是当前阶段 **DP** 的 **最佳策略**

**那么, 如何有效的维护点集呢?**

这就是一个 **线性规划** 的问题了: 在 **点集** 中, 找到一个 **点** , 绘制 **固定斜率** 的直线, 使得 **截距最小**

由 **线性规划** 知识可知: 我们值用考虑 **点集** 中 **凸壳** 上的点即可

**几何直观** 上, 显然这题要维护的是 **下凸壳**

因此, 对于任意的 $f_i$ 来说, 我们只需去寻找 **下凸壳** 上的 **点** 构成 **直线** 的 **最小截距** 即可

这样 **时间复杂度** 在 **最坏** 的情况下, 还是 $O(n^2)$ (即 **所有点** 的 $(x, y)$ **单增** , **全部点** 构成一个 **下凸壳** )

**再看直线方程中, 各参数的性质**

由于 $t_i$ , $c_i$ 都是 **正整数** , 故他们的 **前缀和** $st_i$ , $sc_i$ 是 **单调递增的**

对应于 **直线方程的参数** : $x_j = sc_j$ 是 **单调递增** 的, $k_i = S + st_i$ 也是 **单调递增** 的

而 **下凸壳** 中 **相邻两点** 构成的直线 **斜率** 也是 **单调递增** 的

而 **下凸壳** 中第一个出现在 **直线** 上的点, 满足: $k_{j - 1, j} \le k_i < k_{j, j + 1}$ , 此时 **直线截距** $b_j$ 最小

而又由于 $k_i$ **单调递增** , 所以 $j$ **之前** 的 **点** 都不会是 **点集** 中出现在 **直线** 上的 **第一个点**

此时只需 **维护点集区间** $[j, i]$ 的 **点** 即可, 直到 $k_{j, j + 1} \le k < k_{j + 1, j + 2}$ 时, **维护点集区间** 变为 $[j + 1, i]$ 

根据上述所说, 就出现了 **滑动窗口模型** , 故可以直接利用 **单调队列** 来优化 **下凸壳中的有效点集** , 并用队头的 **两个元素** 维护 **大于当前斜率 $k_i$ 的最小斜率 $k_{q_{hh}, q_{hh + 1}}$** 

$k_{q_{hh}, q_{hh + 1}} > k_i \Longrightarrow \dfrac{y_{q_{hh + 1}} - y_{q_{hh}}}{x_{q_{hh + 1}} - x_{q_{hh}}} > k_i \Longrightarrow \dfrac{f_{q_{hh + 1}} - f_{q_{hh}}}{sc_{q_{hh + 1}} - sc_{q_{hh}}} > S + st_i$ 

把点插入 **单调队列** 前, 先要 **队列** 中 **至少有两个点** , 然后把 **满足** $k_{q_{tt - 1}, q_{tt}} \ge k_{q_{tt}, i}$ 的 **点** $q_{tt}$ **弹出**

即 **新加入的点** , 必须和 **原点集** 构成 **下凸壳** , 无效点要先删去

$k_{q_{tt - 1}, q_{tt}} < k_{q_{tt}, i} \Longrightarrow \dfrac{y_{q_{tt}} - y_{q_{tt - 1}}}{x_{q_{tt}} - x_{q_{tt - 1}}} < \dfrac{y_i - y_{q_{tt}}}{x_i - x_{q_{tt}}} \Longrightarrow \dfrac{f_{q_{tt}} - f_{q_{tt - 1}}}{sc_{q_{tt}} - sc_{q_{tt - 1}}} < \dfrac{f_i - f_{q_{tt}}}{sc_i - sc_{q_{tt}}}$ 

这样, **队列** 中 **相邻两点** 之间构成的直线 **斜率单增** , 也就是我们的 **有效下凸壳点集**

```c++
int n, S, q[N];
LL st[N], sc[N], dp[N];

int main()
{
    cin >> n >> S;
    for(int i = 1; i <= n; i++)
    {
        cin >> st[i] >> sc[i];
        st[i] += st[i - 1], sc[i] += sc[i - 1];
    } 
    
    int hh = 0, tt = 0;
    for(int i = 1; i <= n; i++)
    {
        while(hh < tt && (dp[q[hh + 1]] - dp[q[hh]]) <= (sc[q[hh + 1]] - sc[q[hh]]) * (st[i] + S)) hh ++;
        dp[i] = dp[q[hh]] + S * (sc[n] - sc[q[hh]]) + st[i] * (sc[i] - sc[q[hh]]);
        while(hh < tt && (dp[q[tt]] - dp[q[tt - 1]]) * (sc[i] - sc[q[tt]]) >= (dp[i] - dp[q[tt]]) * (sc[q[tt]] - sc[q[tt - 1]])) tt --;
        q[++ tt] = i;
    }
    
    cout << dp[n] << endl;
}
```

<br>

[AcWing 302. 任务安排3](https://www.acwing.com/problem/content/description/304/)

本题相较于上一题的不同之处是, $t_i$  的 **前缀和** $st_i$ 不再是 **单调递增** 的

在上题中, 斜率 $k(k_i = S + st_i)$ 也是 **单调递增** 的, 故可以用 **单调队列** 在 **队头** 维护 **大于 $k$** 的 **最小值**. 而本题中, $k_i$ 不具备 **单调性** , 因此不能再用 **单调队列** 优化了

不过, **下凸壳上的点集, 相邻两点构成的斜率依旧是单调递增的**

可以利用上 **单调性** , 维护一个 **下凸壳的点集** , 而对于 $k_i$ , **二分** 找到 **大于它的最小值**

```c++
int n, S, q[N];
LL st[N], sc[N], dp[N];

int main()
{
    cin >> n >> S;
    for(int i = 1; i <= n; i++)
    {
        cin >> st[i] >> sc[i];
        st[i] += st[i - 1], sc[i] += sc[i - 1];
    } 
    
    int hh = 0, tt = 0;
    for(int i = 1; i <= n; i++)
    {
        int l = hh, r = tt;
        while(l < r)
        {
            int mid = l + r >> 1;
            if(dp[q[mid + 1]] - dp[q[mid]] > (S + st[i]) * (sc[q[mid + 1]] - sc[q[mid]])) r = mid;
            else l = mid + 1;
        }
        
        dp[i] = dp[q[l]] + S * (sc[n] - sc[q[l]]) + st[i] * (sc[i] - sc[q[l]]);
        while(hh < tt && (double)(dp[q[tt]] - dp[q[tt - 1]]) * (sc[i] - sc[q[tt]]) >= (double)(dp[i] - dp[q[tt]]) * (sc[q[tt]] - sc[q[tt - 1]])) tt --;
        q[++ tt] = i;
    }
    
    cout << dp[n] << endl;
}
```

<br>

---

### 应用

[AcWing 303. 运输小猫](https://www.acwing.com/problem/content/description/305/)

**题目描述**

有 $n$ 座 **山** 和 $m$ 只 **猫** , $P$ 位 **饲养员** 

第 $i$ 座 **山** 和第 $i - 1$ 座 **山** 相隔 $D_i$ 的距离

第 $i$ 只 **猫** 会在第 $H_i$ 座 **山** 上玩耍, 直到 $T_i$ 时刻 **停止** , 并等待 **饲养员** 来接它

所有的 **饲养员** **初始** 都在第 $1$ 座山上, 现安排这些 **饲养员** 的 **出发时刻** (可以是 **负数** )

**饲养员** 以 **单位时间内行走1个单位长度** 的速度沿 **坐标轴** 出发, 接走经过的 **山** 上所有 **等待中** 的 **猫**

求一种 **饲养员** 的 **出发方案** , 使得所有 **猫** 的 **等待时间之和最少**

**分析**

首先用 **前缀和** $sd_i$ 表示第 $i$ 座 **山** 到 **起点** 第$1$ 座 **山** 的 **距离**

对于每只 **猫** **一经等待就恰好被接走** 的 **饲养员** **出发时间** 为: $t_i - sd_{h_i}$ (饲养员到达时刚好接走)

令 $a_i = t_i - sd_{h_i}$ 表示第 $i$ 只 **猫** 的 **最早接走的出发时刻**

那么对于第 $k$ 时刻 **出发** 的 **饲养员** , 他能接走的 **猫** 满足: $a_i \le k$ 

因此为了方便接下来 **动态规划** 的阶段划分, 我们不妨按 $a_i$ 对 **猫** 进行 **排序**

**状态表示-集合** $f_{i, j}$ : 已经派出 $i$ 名 **饲养员** , 且接走了前 $j$ 只 **猫** 的方案

**状态表示-属性** $f_{i, j}$ : 方案中, 每个 **猫** 的 **等待时间之和** 最小 $Min$ 

**状态计算** :

考虑 $i - 1$ 阶段 接走 $k(0 \le k < j)$ 只 **猫** , 为了让 $k + 1$ ~ $j$ 的猫 **等待时间之和最少**

可以列出如下式子: 设第 $i$ 名 **饲养员** 的 **出发时间** 为 $T$ 

$cost = \sum\limits_{u = k + 1}^{j} (a_u - T)$ 

根据 **贪心的思想** , 应让第 $i$ 名 **饲养员** 的 **出发时间** 为 $a_j$ 

对于第 $i$ 名 **饲养员** 带走连续一段的 $k + 1$ ~ $j$ 只 **猫** , 有如下 **转移方程** :

$f_{i, j} = min \{f_{i - 1, k} + \sum\limits_{u = k + 1}^{j} (a_j - a_u) \}$ $(0 \le k < j)$ 

$f_{i, j} = min \{f_{i - 1, k} + \sum\limits_{u = k + 1}^{j} a_j - \sum\limits_{u = k + 1}^{j} a_u \}$ $(0 \le k < j)$ 

预处理前缀和: $f_{i, j} = min \{f_{i - 1, k} + a_j \times (j - k) - (s_j - s_k) \}$ 

提出常量: $f_{i, j} = j \times a_j - s_j + min \{f_{i - 1, k} + s_k - a_j \times k \}$ 

出现 $j \times k$ 项, 考虑 **斜率优化** , 令 $x_k = k$ , $k_j = a_j$ , $y_k = f_{i - 1, k} + s_k$ , 则原式化为:

$f_{i, j} = j \times a_j - s_j + min \{y - kx \}$ 

维护 **下凸壳的点集** , 求 **第一个** 出现在 **直线** 上的 **点**

由于本题中的直线斜率 $a_j$ 我们事先进行了 **排序** , 故它是 **单调递增** 的, 就可以用 **单调队列** 在 **队头** 维护 **大于 $k$** 的 **最小斜率**

```c++
int n, m, p, q[N];
LL sd[N], a[N], s[N], dp[M][N];

LL y(int k ,int i)
{
    return dp[i - 1][k] + s[k];
}

int main()
{
    cin >> n >> m >> p;
    for(int i = 2; i <= n; i++)
    {
        cin >> sd[i];
        sd[i] += sd[i - 1];
    }
    for(int i = 1, h, t; i <= m; i++)
    {
        cin >> h >> t;
        a[i] = t - sd[h];
    }
    
    sort(a + 1, a + m + 1);
    for(int i = 1; i <= m; i++)
        s[i] = s[i - 1] + a[i];
    
    memset(dp, 0x3f, sizeof dp);
    for(int i = 0; i <= p; i++)
        dp[i][0] = 0;
    
    for(int i = 1; i <= p; i++)
    {
        int hh = 0, tt = 0;
        for(int j = 1; j <= m; j++)
        {
            while(hh < tt && y(q[hh + 1], i) - y(q[hh], i) <= a[j] * (q[hh + 1] - q[hh])) hh ++;
            dp[i][j] = j * a[j] - s[j] + y(q[hh], i) - a[j] * q[hh];
            while(hh < tt && (y(q[tt], i) - y(q[tt - 1], i)) * (j - q[tt]) >= (y(j, i) - y(q[tt], i)) * (q[tt] - q[tt - 1])) tt --;
            q[++ tt] = j;
        }
    }
    
    cout << dp[p][m] << endl;
}
```



<div style="page-break-after:always;"></div>

#  Flood Fill 算法

### 介绍

> + 基本作用: 可以在线性时间复杂度内, 找到某个点所在的连通块
> + 基本方法: BFS (不会爆栈) / DFS
> + 适用题目: 需要寻找若干连通块的题目
>
> 顾名思义, `Flood Fill 算法` 就是像洪水泛滥一样去寻找周围符合条件的区域, 采用 `BFS` 可以完成先从自身最近的点寻找随后逐步扩展

<br>

### 代码思路

> 1. 用函数寻找一个连通块
> 2. 传入坐标形参
> 3. 将形参坐标的状态改变, 表示已经访问过 (标记是为了避免重复遍历)
> 4. 创建队列存放坐标, 将形参坐标放入队列
> 5. 循环 (队列中有元素就一直循环)
> 6. 将队列队头的坐标取出
> 7. 判断当前坐标是否符合要求 (范围、标记状态、是否属于连通块)
> 8. 满足则加入到队尾, 并标记状态

<br>

### 模板

```c++
//bfs模板

bool 数组记录
while(q.size())	//队列不空
{
    //取出队头
    PII t=q.front();
    q.pop();
    
    //枚举4个方向(或8个方向)
    for(int i=0;i<4;i++)
    {
        int x=t.x+dx[i],y=t.y+dy[i];
        //判断是否在界内
        if(x>=1&&x<=n&&y>=1&&y<=m&&数组判重&&题目条件)
        {
            //题目的要求
            q.push({x,y});	//拓展队尾
        }
    }
}
```

<br>

```c++
//dfs模板

void dfs(int x,int y)
{
    //标记起始元素
    
    //枚举4个方向(或8个方向)
    for(int i=0;i<4;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a>=1&&a<=n&&b>=1&&b<=m&&判断条件)
            dfs(a,b);
    }
}
```

<br>

### 题目应用

> [AcWing 1097. 池塘计数](https://www.acwing.com/problem/content/description/1099/)
>
> `Flood Fill` 的简单应用, 直接套用即可
>
> 遍历地图上的点, 发现为 `W` 并未访问的点即调用 `BFS` 函数

> [AcWing 1098. 城堡问题](https://www.acwing.com/problem/content/description/1100/)
>
> 该题比较特殊, 每个空间的值代表周围是否有墙, 所以要用到二进制技巧
>
> `num>>x&1` , 可以判断 `num` 二进制的第 `x-1` 位是否为 `1`
>
> 由于还要找出最大的房间, 所以 `BFS` 函数要返回一个 `int` 值
>
> 我们在队列循环开始时就将空间大小加一即可

> [AcWing 1106. 山峰和山谷](https://www.acwing.com/problem/content/description/1108/)
>
> 该题不仅要找到连通块 (高度相同的坐标), 还要判断连通块与周围非连通块的大小关系
>
> 在搜索周围坐标时, 判断一下周围是否有不相同高度 (高/低) 坐标即可



<div style="page-break-after:always;"></div>

# 最短路模型

### 介绍

> + 基本作用: 求最短路径及最短距离
> + 基本方法: BFS
> + 适用题目: 需要求点到点的最短距离或最短路径, 边权大于零且相等

<br>

### 代码思路

> 1. 用一个函数寻找最短路径 (距离)
> 2. 初始化路径 (距离) 数组
> 3. 建立队列存放路径 (距离)
> 4. 将函数形参放入队列, 并改变该坐标的路径 (距离) 数组
> 5. 循环: 队列中有元素则一直循环
> 6. 遍历周围坐标, 遇到不符合的坐标就略过
> 7. 不符合的坐标包括: 越界、已被访问过 (路径 (距离) 数组已被改变的) 、不符合题目条件的
> 8. 对于符合条件的坐标, 加入队列, 并且根据前一个坐标改变它的路径 (距离) 数组

<br>

### 记录最短路径情况

> 方法1
>
> 新开一个数组 `pair <int,int> memory` , 记录每个点是从哪个点过来的, 比如 `memory[3][3] = {4,4}` , 即 `(4,4) ---> (3,3)` 
>
> 算法实现: 先从终点到起点跑一遍 `bfs` , 再从起点开始输出 `memory` 

> 方法2
>
> 依然借助 `memory` 数组记录每个点是从哪个点过来的
>
> 从起点到终点进行一次正常的 `bfs`
>
> 但此时输出的 `memory` 不仅需要从终点往起点走, 同时输出的结果也需要是从后往前反着的
>
> 因此, 借助栈 `stack <PII> p` , 最后输出就可以是正向的了

<br>

### 题目应用

> [AcWing 1076. 迷宫问题](https://www.acwing.com/problem/content/description/1078/)
>
> 该题是要求点 `(0,0)` 到点 `(n-1,n-1)` 的最短路径, 我们可以用一个 `pair` 数组来存储每一个点的前一个点的坐标
>
> 由于题目要求从 `(0,0)` 开始, 我们的数组又是记录的前一个坐标, 所以我们可以从终点开始遍历, 求出终点到起点的最短路径, 再从 `(0,0)` 开始输出, 依次输出前一个坐标即可达到题目要求 

> [AcWing 188. 武士风度的牛](https://www.acwing.com/problem/content/description/190/)
>
> 该题是求最短距离的, 我们用距离数组来存储起点到该点的距离即可
>
> 对于满足条件的点, 用 `dist[nx][ny] = dist[x][y] + 1` 更新
>
> 注意这里的每一步是类似于象棋中"马"的走法, 我们用位移数组操作即可

> [AcWing 1100. 抓住那头牛](https://www.acwing.com/problem/content/description/1102/)
>
> 该题是在一维条件下找起点到终点的最短距离, 和二维类似
>
> 注意一下范围即可



<div style="page-break-after:always;"></div>

# 多源BFS

### 介绍

> + 基本作用: 求若干个起点到若干个终点的最短距离 (路径)
> + 基本方法: BFS、添加一个虚拟原点 (虚拟原点到起点的边权为0)
> + 适用题目: 边权为正且都相同; 求若干个起点到终点的最短距离 (路径), 只保留一个最短的

<br>

### 整体思路

> 假设有一个虚拟原点, 虚拟原点到全部起点的边权为0
>
> 这样我们可以将原模型转化为单源BFS
>
> 也就是求虚拟原点到所有终点的最短距离
>
> 我们先设置起点的距离为0 (虚拟原点到全部起点的边权为0)
>
> 再将它们放入队列中
>
> 最后用单源BFS求最短路的方法即可

<br>

### 代码思路

> 1. 在 `BFS` 函数之前初始化数组
> 2. 遍历地图, 找到全部起点
> 3. 将起点坐标放入队列并设置距离为0
> 4. 最后求单源BFS即可

<br>

### 题目应用

> [AcWing 173. 矩阵距离](https://www.acwing.com/problem/content/description/175/)
>
> 将多源BFS通过初始化距离数组与队列转化为单源BFS



<div style="page-break-after:always;"></div>

# 最小步数模型

### 介绍

> + 与一般BFS求地图内部最短距离不同, 最小步数模型是要求图从开始状态经过状态改变到达最终状态的最小值
> + 往往要存储地图的状态, 一般都会采用哈希表

<br>

### 代码思路

> 1. 首先用哈希表存放到达某个状态的最短步数, 如果题目需要输出方案, 则还需一个哈希表记录每个状态的上一个状态
> 2. 利用 `bfs` 逐个进行状态改变, 某个状态如果 `dist` 为 `0` , 则说明未出现过, 我们进行一系列操作并将它放入队列
> 3. 如果状态改变到最终状态则直接 `return` 即可

<br>

### 题目应用

> [AcWing 1107. 魔板](https://www.acwing.com/problem/content/description/1109/)
>
> 题目要求按字典序最小, 那我们就按照 A, B, C 的顺序来进行状态改变, 经过BFS后就可以得到两个哈希表的信息
>
> 由于要输出方案, 所以我们需要从最终状态开始遍历, 不断获取前一个状态, 再将答案翻转



<div style="page-break-after:always;"></div>

# 双端队列广搜

### 介绍

> + 基本作用: 求最短距离
> + 基本方法: BFS、双端队列 (deque)
> + 适用题目: 需要求点到点的最短距离或最短路径, 并且边权只有0或1

<br>

### 代码思路

> 与基本的BFS很相似, 区别主要在于将元素放入队列时, 双端队列广搜是将权为0放到队头, 权为1放到队尾
>
> 1. 用一个函数寻找最短路径 (距离)
> 2. 初始化距离 (路径) 数组
> 3. 建立队列存放距离 (路径)
> 4. 将函数形参放入队列, 并改变该坐标的距离 (路径) 数组
> 5. 循环: 队列中有元素则一直循环
> 6. 遍历周围坐标, 遇到不符合的坐标就略过
> 7. 不符合的坐标包括: 越界、不符合题目条件的
>
> **注意: 一个点是有可能多次入队, 被多次更改的 (本质为 Dijkstra)**
>
> **不符合的坐标不包括已经访问过 (路径数组已被改变过) 的坐标**
>
> **每个点只有在出队时才能确定最短距离 (与一般BFS不同, 一般BFS在入队时就能确定最短距离)**
>
> 8. 对于符合条件的坐标, 权为0放到队头, 权为1放到队尾

<br>

### 题目应用

> [AcWing 175. 电路维修](https://www.acwing.com/problem/content/description/177/)
>
> 不改变电路就能到达的点权为0, 改变电路才能到达的点权为1



<div style="page-break-after:always;"></div>

# 双向广搜

### 介绍

> 双向广搜适用于从起始状态到目标状态中的过程中, 中间状态过多的搜索题, 其核心思想在于"空间换时间"
>
> 在求最短路模型时是没有区别的, 因为对于最短路模型, 都是在一个棋盘内部 (或在某个图的内部), 每个点只会遍历一次, 从起点搜索到终点的时间复杂度是线性的
>
> 对于某些把每个棋盘看作一个状态的题 (如魔板、八数码), 总共不同的状态数目非常之多, 方案数高达$k^{10}$ , 会 `TLE` 或 `MLE`

<br>

### 算法原理

> 双向广搜优化思想是从起点和终点同时扩展, 当相遇时即得到完整搜索路径
>
> 优化原理: bfs的每一层相比上一层数目指数增长. 若单向搜索, 最终状态个数为$k^{10}$, 而如果双向搜索, 平均下来两个方向只需搜索原层数的一半, 状态个数减少至$2×k^5$ 
>
> <br>
>
> 双向广搜队列扩展有两种方式:
>
> 1. 起点和终点依次各扩展一层
> 2. 每次选择扩展队列中状态较少的方向
>
> 采用第2种方式在平均意义上效果更好

<br>

### 代码思路

> 1. `da` 和 `db` 表示距离各自起点的步数
> 2. 每次取元素较少的队列来扩展
> 3. 每次扩展的都是这一层的元素, 如果 `qa` 扩展的元素在 `qb` 中出现过, 就 `return` 步数
> 4. 否则, 放入队列, 并更新距离起点的步数

<br>

### 题目应用

> [AcWing 190. 字串转换](https://www.acwing.com/problem/content/description/192/)

```c++
#include<bits/stdc++.h>

using namespace std;

const int N=6;

int n;	//变换规则数量
string A,B;		//起点、终点字符串
string a[N],b[N];	//存储变换规则

//扩展一层的元素
int extend (queue<string>&q,unordered_map<string,int>&da,unordered_map<string,int>&db,string a[],string b[])
{
    //取出这一层的距离起点的步数
    int d=da[q.front()];
    
    //如果队列空了或扩展的元素到达下一层了,就return
    while(q.size()&&d==da[q.front()])
    {
        //取出队头
        auto t=q.front();
        q.pop();
        
        //枚举所有起点
        for(int i=0;i<t.size();i++)
            
            //枚举所有规则
            for(int j=0;j<n;j++)
                if(t.substr(i,a[j].size())==a[j])
                {
                    //该元素新扩展出来的字符串
                    string state=t.substr(0,i)+b[j]+t.substr(i+a[j].size());
                    
                    //之前出现过
                    if(da.count(state))continue;
                    
                    //在db数组里出现过,直接return步数
                    if(db.count(state))return d[t]+1+db[state];
                    
                    //放入队列并更新步数
                    q.push(state);
                    da[state]=da[t]+1;
                }
    }
    
    return 11;
}

int bfs ()
{
    //两个字符串相等,直接return 0
	if(A==B)return 0;
    
    //初始化qa和qb两个队列
    queue<string>qa,qb;
    qa.push(A),qb.push(B);
    
    //初始化da和db两个距离各自起点的步数
    unordered_map<string,int>da,db;
    da[A]=0,db[B]=0;
    
    //记录走的步数,超过10步直接return -1
	int step=0;
    
    //如果一方状态扩展完毕还未相遇,表明从起点到终点并不连通,直接return -1
    while(qa.size()&&qb.size())
    {
        //取元素较少的队列来扩展
        int t;
        if(qa.size()<=qb.size())t=extend(qa,da,db,a,b);
        else t=extend(qb,db,da,b,a);	//从终点扩展时,状态转换规则需要反向应用
        
        //若两个字符串相遇,且步数不超过10,则返回步数
		if(t<=10)return t;
        
        //步数超10,直接return -1
        if(++step==10)return -1;
    }
    
    return -1;
}

int main()
{
    cin>>A>>B;
    
    while(cin>>a[n]>>b[n])n++;
    
    if(bfs()==-1)cout<<"NO ANSWER!"<<endl;
    else cout<<bfs()<<endl;
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# A\*算法

### 算法思想

> A\*算法在应用上与双向广搜相同——优化状态相对较多的最小步数模型
>
> 大致思路: 通过启发函数, 尽量只走最有可能是最短路的路径——通过预测每个点到终点路径的距离, 每次走预测路径最短的顶点, 这样做的好处是我们只走了距离较短的路径, 以减少遍历状态的数目

<br>

### 算法流程

> 1. 优先队列替换bfs的普通队列, 保存键值对 `<顶点v, (d(v)+f(v))>` 
>
>    其中, `d(v)` : 起点到顶点 `v` 路径的距离 (不一定是最短路径); `f(v)` : 顶点 `v` 到终点的估计距离
>
>    优先队列每次取 `d(v) + f(v)` 最小的顶点出队
>
> 2. `v` 出队后更新相邻顶点的 `d` 值, 更新与入队操作类似 `dijkstra算法`
> 3. 当终点第一次出队时 `break` , 算法结束

<br>

### 正确性证明

> ① 前提条件:
>
> 设对于顶点 `u` :
>
> `d(u)` : 当前路径起点到 `u` 的距离
>
> `g(u)` : 顶点 `u` 到终点的最短距离
>
> `f(u)` : 顶点 `u` 到终点的预测距离, 也就是启发函数
>
> 算法正确性前提: `0 ≤ f(u) ≤ g(u)` , 在此基础上 `f(u)` 越接近 `g(u)` 越好

> ② 证明: (反证法)
>
> 终点出队时算法结束, 找到起点到终点的最短路
>
> 假设终点出队时, 对应距离不是最短距离
>
> 由于出队时不是最短距离, `d出队 > d最优` 
>
> 对于最短路径上的某点 `u` :
>
> $\quad$ $\quad$ `d(u) + f(u) ≤ d(u) + g(u) = d最优 < d出队`
>
> 而优先队列按 `d+f` 的最小值出队, 即 `d出队 ≤ d最优`
>
> 二者矛盾

<br>

### 应用条件

> 1. 图中无负环即可. 不同于bfs, A\*可应用在权重为任意值的图上
> 2. 存在最短路, 即问题有解. 否则算法最终会遍历所有状态 (预测值都为 +$\infty$), 并且优先队列每次操作的时间复杂度为 `O(logn)` , 此时A*甚至比普通bfs时间性能还要差
>
> <br>
>
> A\*算法与dijkstra算法过程类似, dijkstra算法类似于所有顶点启发函数为0的A\*算法
>
> 不过A\*算法应用场景的顶点数较多, 且只关注起点到终点的最短距离, 而dijkstra算法考虑起点到其他任意顶点的最短路径
>
> <br>
>
> 简单比较几个算法的最小值确定时间:
>
> + bfs: 入队时确定顶点最短路径
> + dijkstra: 出队时确定顶点最短路径
> + A\*: 出队时确定终点的最短路径, 其他顶点无法保证
>
> <br>
>
> 最短距离的确定:
>
> A\*算法只能保证终点出队时最短, 其他顶点无法保证

<br>

### 常用启发函数

> 1. 建立反图, 用反图的 `dist` 作为估价函数
> 2. 曼哈顿距离、切比雪夫距离

<br>

### 题目应用

> [AcWing 179.八数码](https://www.acwing.com/problem/content/description/181/)

> 思路:
>
> 1. 此题有个性质: 如果逆序对数量是奇数, 就永远都无法到达, 故可提前判断
> 2. `dist` 数组: 记录到达该状态的距离
> 3. `pre` 数组: 记录到达该状态的操作和上一步状态
> 4. `heap` 小根堆: 记录从起点经该状态到终点的估价距离和该状态
> 5. 估价函数: 该状态的各个点和目标状态的曼哈顿距离之和
> 6. 每次取出堆顶元素: 从起点到达终点的估价距离最小
> 7. 注意: 取出的元素的状态只有终点才是最小距离
> 8. 枚举该状态可以到达的新状态, 如果该新状态未出现过或比之前到达该状态的距离更小, 就更新 `dist` , `pre` 和 `heap`
> 9. 最后回推路径并反转

```c++
#include<bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int,string> PIS;
typedef pair<char,string> PCS;

//从该状态到达目标状态的估价函数:各个点与目标状态的曼哈顿距离之和
int f (string state)
{
    int res=0;
    for(int i=0;i<9;i++)
        if(state[i]!='x')
        {
            int t=state[i]-'1';
            res+=abs(i/3-t/3)+abs(i%3+t%3);
        }
    
    return res;
}

string bfs (string start)
{
    //枚举四个方向的操作
    char op[5]="urdl";
    
    //目标字符串
    string end="12345678x";
    
    //枚举四个方向的方位
    int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
    
    //初始化dist数组,更新起点的距离
    unordered_map<string,int>dist;
    dist[start]=0;
    
    //记录到达此状态的操作和上一步状态
    unordered_map<string,PCS>pre;
    
    //初始化小根堆,第一元素:从起点到该状态的真实距离+该状态到目标状态的估价距离;第二元素:该状态
    priority_queue<PIS,vector<PIS>,greater<PIS>>heap;
    heap.push({f(start),start});
    
    while(heap.size())
    {
        //取出堆顶:从起点到终点的估计距离最小
        auto t=heap.top();
        heap.pop();
        
        //取出该状态
        string state=t.y;
        
        //到达目标字符串
        if(state==end)break;
        
        //求'x'的坐标
        int x,y;
        for(int i=0;i<9;i++)
            if(state[i]=='x')
            {
                x=i/3,y=i%3;
                break;
            }
        
        //提前存储该状态,需要反复用到
        string source=state;
        
        //枚举四个方向
        for(int i=0;i<4;i++)
        {
            int a=x+dx[i],b=y+dy[i];
            
            //超出边界
            if(a<0||a>=3||b<0||b>=3)continue;
            
            //原状态赋值
            state=source;
            
            //该状态扩展的新状态
            swap(state[x*3+y],state[a*3+b]);
            
            //该状态之前未出现过或此路径比之前到达该状态的距离更小
            if(!dist.count(state)||dist[source]+1<dist[state])
            {
                //更新扩展出来的新状态的距离
                dist[state]=dist[source]+1;
                
                //记录到达此状态的操作和上一步状态
                pre[state]={op[i],source};
                
                //放入队列,记录起点到终点的估价距离和新状态
                heap.push({dist[state]+f(state),state});
            }
        }
    }
    
    //回推路径
    string res;
    while(end!=start)
    {
        res+=pre[end].x;
        end=pre[end].y;
    }
    reverse(res.begin(),res.end());
    
    return res;
}

int main()
{
    string start,seq;
    char c;
    while(cin>>c)
    {
        start+=c;
        if(c!='x')seq+=c;
    }
    
    //计算逆序对数量,如果是奇数,就不可能到达
    int cnt=0;
    for(int i=0;i<7;i++)
        for(int j=i+1;j<8;j++)
            if(seq[i]>seq[j])
                cnt++;
    
    if(cnt&1)cout<<"unsolvable"<<endl;
    else cout<<bfs(start)<<endl;
    
    return 0;
}
```

<br>

> [AcWing 178. 第k短路](https://www.acwing.com/problem/content/description/180/)

> 思路:
>
> 1. 第k短路, 就是终点出队k次的距离. 注意: 当起点和终点一样时, `k++`
> 2. 若不能从 `S` 到达 `T` , 则一定不存在第k短路
> 3. 估价函数: 从该点到终点的最短距离, 即求一遍dijkstra, 大于等于0, 小于等于真实值
> 4. 取出堆顶, 记录出队次数, 把该点能枚举到的所有点都放入小根堆

```c++
#include<bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int,int> PII;
typedef pair<int,PII> PIII;

const int N=1010,M=20010;

int n,m,S,T,K;
int h[N],rh[N],e[M],ne[M],w[M],idx;
int dist[N],cnt[N];
bool st[N];

void add (int h[],int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

//从该点到终点的最短距离dist,不仅大于等于0,更是小于等于真实距离
void dijkstra()
{
    priority_queue<PII,vector<PII>,greater<PII>>heap;
    heap.push({0,T});
    
    memset(dist,0x3f,sizeof dist);
    dist[T]=0;
    
    while(heap.size())
    {
        auto t=heap.top();
        heap.pop();
        
        int ver=t.y;
        if(st[ver])continue;
        st[ver]=true;
        
        for(int i=rh[ver];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[ver]+w[i]<dist[j])
            {
                dist[j]=dist[ver]+w[i];
                heap.push({dist[j],j});
            }
        }
    }
}

int astar()
{
    //小根堆初始化,第一元素:从起点到终点的估价距离;第二元素:从起点到该点的真是距离;第三元素:该点
    priority_queue<PIII,vector<PIII>,greater<PIII>>heap;
    heap.push({dist[S],{0,S}});
    
    //说明从终点到起点是不连通的
    if(dist[S]==0x3f3f3f3f)return -1;
    
    while(heap.size())
    {
        //取出堆顶:从起点到终点的估价距离最小
        auto t=heap.top();
        heap.pop();
        
        int ver=t.y.y,distance=t.y.x;
        
        //记录该状态出队次数
        cnt[ver]++;
        if(cnt[T]==K)return distance;
        
        //枚举该点能够到达的所有点
        for(int i=h[ver];i!=-1;i=ne[i])
        {
            int j=e[i];
            
            //略过走不到终点的点
            if(dist[j]==0x3f3f3f3f)continue;
            heap.push({distance+w[i]+dist[j],{distance+w[i],j}});
        }
    }
    
    return -1;
}

int main()
{
    cin>>n>>m;
    
    //初始化
    memset(h,-1,sizeof h);
    memset(rh,-1,sizeof rh);
    
    //建立正向边和反向边
    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(h,a,b,c);
        add(rh,b,a,c);
    }
    
    cin>>S>>T>>K;
    
    //当起点和终点相同时,astar会直接return,故K++
    if(S==T)K++;
    
    dijkstra();
    
    cout<<astar()<<endl;
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 深度优先搜索 DFS

### 连通性模型与搜索顺序

> 深搜 (DFS) 分为两类
>
> 第一类是内部搜索, 所有点都在棋盘内部, 每个点都是一个状态并且都至多只会被搜索一次, 不需要恢复现场, 时间复杂度是线性的. 比如迷宫、红黑图等 Flood-Fill 算法
>
> 对于连通性模型, BFS和DFS都能用. DFS代码简单, 但容易爆栈, 且无法得到最短距离. BFS不会爆栈, 且能得到每个点的最短距离, 但代码复杂
>
> 第二类是外部搜索, 如果将整个棋盘当作一个状态, 每次进行新的搜索时要保证上一层都一样, 需要恢复现场, 时间复杂度时指数级别的. 比如在棋盘的格子里面填数, 第一个点填1, 这一轮搜索完之后, 第一个点想填2, 那么就要先把之前填写的1给去掉, 也就需要恢复现场. 又比如n皇后, 递归实现指数型枚举等, 都是把整个棋盘, 整个数字串当成一个状态, 通常可以看作一棵搜索树

<br>

> 外部搜索三大注意点:
>
> 1. 顺序: 找到一种搜索顺序, 能把各种情况都枚举出来 (一定要是全部方案); 问题通常是求最值或方案数
> 2. 回溯: 保证搜索树每次以一个相同状态进行向下扩展
> 3. 剪枝

<br>

---

### 剪枝与优化

> 1. 优化搜索顺序
>
>    大部分情况下, 我们应该优先搜索分支较少的节点
>
> 2. 排除等效冗余
>
>    在不需要考虑排序的情况下, 用组合的方式进行搜索
>
>    如前3个苹果中选2个, 选12和选21是等效的, 没必要重复搜索. 传入一个参数 `start` , 记录从第几个元素开始搜索
>
> 3. 可行性剪枝
>
>    如果发现当前分支再继续搜已经不会有合法结果, 如迷宫问题中的墙/ 边界等, 直接 `return`
>
> 4. 最优性剪枝
>
>    求最小值问题时, 当前值已经大于等于目前存的最小值, 则直接剪枝
>
>    如果当前答案为 `res` , 全局最优解为 `ans` , 那么当 `res ≥ ans` 时, 已经不会再更新 `ans` 了, 直接 `return`
>
> 5. 记忆化搜索 (DP)
>
> 6. 提前break机制
>
>    如果当前发现一组可行解, 直接 `return true` , 并沿路一直返回

<br>

---

### 迭代加深

> 当搜索层数较多, 但是答案只出现在低层次中, 就可以使用迭代加深优化
>
> 维护一个 `depth` 表示当前的深度, 每次递归当前深度, 如果有解, 则break, 否则继续加深深度
>
> 每一次迭代加深都要从头开始重新搜索判断, 一层一层的扩展搜索, 但由于树的深度是呈指数增加的, 前几层的所有节点可能都没有最后一层节点多, 所以迭代加深并不会延慢搜索

<br>

##### 迭代加深基本框架

```c++
bool dfs (int depth,int max_depth)
{
    if(depth>max_depth)return false;
    if(check())return true;
    
    //dfs下一层
    if(dfs(depth+1,max_depth))return true;
}

int depth=0;
while(!dfs(0,depth))depth++;
```

<br>

---

### 双向DFS

> 运用空间换时间的思想, 首先搜出一半并将它们存到数组里, 或者 `set` 之类的数据结构中, 然后排序并去重
>
> 然后搜索另一半, 之后对于另一半搜索出的答案, 直接在之前的数组中二分查找, 并做出判断即可

<br>

---

### IDA\*算法

> IDA\*实质上就是在迭代加深的基础上加了一个启发性剪枝

<br>

##### IDA\*基本框架

```c++
int f(){;}	//估价函数

bool dfs(int depth,int max_depth)
{
    if(depth+f()>max_depth)return false;
    
    if(f()==0)return true;	//这里的终止条件一般都是估价函数为0
    //因为估价函数是当前状态到末状态的距离,当等于0时就到了末状态了
    
    //爆搜枚举
    
    return false;
}

int main()
{
    int depth=0;
    while(!dfs(0,depth))depth++;
    
    cout<<depth<<endl;
}
```

<br>

##### 题目应用

> [AcWing 180. 排书](https://www.acwing.com/problem/content/description/182/)

> 思路:
>
> 1. 如果真实值 + 估价值 > 当前最大深度, 直接 `return`
> 2. 估价函数: [$\frac{后继数}{3}$], 即 (后继数 + 2) / 3
> 3. 做法: 枚举每一种长度, 对于每一种长度, 都有 `n-len+1` 种选择, 对于每一种选择又有 `n-len` 种插法
> 4. 恢复现场

```c++
#include<bits/stdc++.h>

using namespace std;

const int N=15;

int n;
int q[N];
int w[5][N];

//估价函数:由错误的后继数数量推出最少还要执行多少次,每次最多更正三个后继数
int f()
{
    int cnt=0;
    for(int i=0;i<n-1;i++)
        if(q[i+1]!=q[i]+1)
            cnt++;
    
    return (cnt+2)/3;
}

bool dfs (int u,int depth)
{
    //当前层+最少还要执行的估价层数
	if(u+f()>depth)return false;
    
    //判断是否还有后继数
    if(!f())return true;
    
    //枚举所有长度
    for(int len=1;len<n;len++)
        
        //枚举每一种长度的所有选择
        for(int l=0;l+len-1<n;l++)
        {
            int r=l+len-1;
            
            //枚举每一种选择可以放在哪里
            for(int k=r+1;k<n;k++)
            {
                //提前备份
                memcpy(w[u],q,sizeof q);
                
                int x,y;
                
                //把后一段[r+1,k]移到前面去
                for(x=r+1,y=l;x<=k;x++,y++)q[y]=w[u][x];
                
                //把前一段[l,r]移到后面去
                for(x=l;x<=r;x++,y++)q[y]=w[u][x];
                
                //恢复现场
                memcpy(q,w[u],sizeof q);
            }
        }
    
    return false;
}

int main()
{
    int t;
    cin>>t;
    
    while(t--)
    {
        cin>>n;
        
        for(int i=0;i<n;i++)cin>>q[i];
        
        int depth=0;
        while(depth<5&&!dfs(0,depth))depth++;
        
        if(depth==5)cout<<"5 or more"<<endl;
        else cout<<depth<<endl;
    }
    
    return 0;
}
```

<br>

> [AcWing 181. 回转游戏](https://www.acwing.com/problem/content/description/183/)

> 思路: 
>
> 1. 估价函数: 中间八个格子最少还要移几次
> 2. 枚举每一层操作, 该操作不能与上一层操作对立
> 3. 每层要记录该层是什么操作
> 4. 回溯的时候要恢复现场

```c++
//给每个格子及每种操作编号
/*
            A(0)   B(1)
              0     1
              2     3
  H(7)  4  5  6  7  8  9  10  C(2)
              11    12
  G(6)  13 14 15 16 17 18 19  D(3)
              20    21
              22    23
            F(5)    E(4)
*/
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N=24;

//每种操作所牵动的格子序号
int op[8][7]={
    {0,2,6,11,15,20,22},
    {1,3,8,12,17,21,23},
    {10,9,8,7,6,5,4},
    {19,18,17,16,15,14,13},
    {23,21,17,12,8,3,1},
    {22,20,15,11,6,2,0},
    {13,14,15,16,17,18,19},
    {4,5,6,7,8,9,10}
};

//该操作序号的对立序号
int opposite[8]={5,4,7,6,1,0,3,2};

//中间八个格子的序号
int center[8]={6,7,8,11,12,15,16,17};

int q[N];
int path[100];

// 估价函数:8 - 当前中间八个格子一样数字最多的个数
int f()
{
    static int sum[4];	//因为估价函数会被频繁调用,可以将里面的变量定义为静态变量
    memset(sum,0,sizeof sum);	//就不会每次重新分配空间

    for(int i=0;i<8;i++) sum[q[center[i]]]++;

    return 8-max(sum[1],max(sum[2],sum[3]));
}

//执行编号为 x 的操作
void operate(int x)
{
    int t=q[op[x][0]];
    for(int i=0;i<6;i++) q[op[x][i]]=q[op[x][i+1]];
    q[op[x][6]]=t;
}

//第 u 层操作，最大操作数为 depth，上一层操作的序号
bool dfs(int u,int depth,int last)
{
    //目前操作层+估价操作层
    if(u+f()>depth) return false;

    //达成要求
    if(!f()) return true;

    //枚举八种操作
    for(int i=0;i<8;i++)

        //该操作的对立面不能是上一层操作
        if(opposite[i]!=last)
        {
            //记录这一层的操作
            path[u]=i;

            //执行该操作
            operate(i);

            //递归搜索下一层
            if(dfs(u+1,depth,i)) return true;

            //恢复现场
            operate(opposite[i]);
        }

    return false;
}

int main()
{
    while(cin>>q[0],q[0])
    {
        for(int i=1;i<N;i++) cin>>q[i];

        int depth=0;
        while(!dfs(0,depth,-1)) depth++;

        if(!depth) cout<<"No moves needed";
        else for(int i=0;i<depth;i++) cout<<char(path[i]+'A');

        cout<<'\n'<<q[6]<<endl;
    }

    return 0;
}
```



<div style="page-break-after:always;"></div>

# 差分约束

> 差分约束系统用于求解一组特殊的 `N` 元一次不等式组. 它包含了 `N` 个变量 `x1` ~ `xn` 和 `M` 个约束条件, 其中每个约束条件形如:  $x_i \leqslant x_j + c_k$ (最短路) , $x_i \geqslant x_j +c_k$ (最长路)
>
> 约束条件 $x_i \leqslant x_j +c_k$ , 可转化为一条有向边 $j \stackrel{c_k}{\rightarrow} i$ , 最短路中有 `dist[i] <= dist[j] + ck`



> **差分约束**
>
> (1) 求不等式组的可行解
>
> $\quad$ **源点需要满足的条件: 从源点出发, 一定可以走到所有的边**
>
> $\quad$ 步骤:
>
> $\quad$ [1] 先找到每个不等式 $x_i \leqslant x_j + c_k$ 转化成一条从 `j` 走到 `i` , 长度为 `ck` 的边
>
> $\quad$ [2] 找到一个源点, 使得该源点一定可以遍历到所有边
>
> $\quad$ [3] 从源点求一遍单源最短路
>
> $\quad$ $\quad$ 结果1: 如果存在负环, 则原不等式组一定无解
>
> $\quad$ $\quad$ 结果2: 如果没有负环, 则 `dist[i]` 就是原不等式组的一个可行解
>
> (2) 如果求最大值或者最小值, 这里的最值指的是每个变量的最值
>
> $\quad$ **结论: 如果求的是最小值, 则应该求最长路; 如果求的是最大值, 则应该求最短路**
>
> $\quad$ 问题: 如何转化 $x_i \leqslant c$ , 其中 `c` 是一个常数, 这类的不等式
>
> $\quad$ 方法: 建立一个超级源点, `0` , 建立 $0 \stackrel{c}{\rightarrow} i$ 的边
>
> $\quad$ 求 `xi` 的最大值, 即求对 `xi` 的所有约束条件中的最小值/ 最小上界 (最短路)

> 求 `最小值` : `最长路` $\Longrightarrow$ `大于号` $\Longrightarrow$ $x_i \geqslant x_j + c_k$
>
> 求 `最大值` : `最短路` $\Longrightarrow$ `小于号` $\Longrightarrow$ $x_i \leqslant x_j + c_k$



> 当存在负环/ 正环时, `spfa` 用栈处理比用堆处理更快

```c++
//spfa判断是否有正环(栈实现)
//单源最长路,求最小值

bool spfa ()
{
    int hh=0,tt=1;
    memset(dist,-0x3f,sizeof dist);
    dist[0]=0;
    q[0]=0;
    st[0]=true;
    
    while(hh!=tt)
    {
        int t=q[--tt];
        st[t]=false;
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]<dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n+1)return true;	//包含源点0
                if(!st[j])
                {
                    q[tt++]=j;
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```

```c++
//spfa判断是否有负环(堆实现)
//单源最短路,求最大值

bool spfa ()
{
    int hh=0,tt=1;
    memset(dist,0x3f,sizeof dist);
    dist[0]=0;
    q[0]=0;
    st[0]=true;
    
    while(hh!=tt)
    {
        int t=q[hh++];
        if(hh==N)hh=0;
        st[t]=true;
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n+1)return true;	//包含源点0
                if(!st[j])
                {
                    q[tt++]=j;
                    if(tt==N)tt=0;
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```



<div style="page-break-after:always;"></div>

# 最近公共祖先

### 倍增求LCA

> ① 初始化: 通过 `bfs` 初始化两个数组 `depth[]` , `fa[]`
>
> $\quad$ $\quad$ `depth[n]` : 表示深度(到根节点的距离加1)
>
> $\quad$ $\quad$ `fa[i][j]` : 表示从 `i` 开始, 向上走 $2^j$ 步所能到的节点编号 ($0 \leqslant j \leqslant log_2n$)
>
> $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ `fa[i,0]` = `i` 的父节点
> $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ `fa[i,j]` = `fa[fa[i,j-1],j-1]`
>
> $\quad$ $\quad$ 哨兵: 如果从 `i` 开始跳 $2^j$ 步会跳过根节点, 那么 `fa[i,j] = 0` , `depth[0] = 0`
>
> ② 查询
>
> $\quad$ $\quad$ [1] 先将两个点跳到同一层
>
> $\quad$ $\quad$ [2] 让两个点同时往上跳, 一直跳到它们的最近公共祖先的下一层



```c++
//倍增法求最近公共祖先算法模板
int h[N],e[M],ne[M],idx;
int depth[N],fa[N][size];	//size取logn(n为节点数量)
int q[N];

//宽搜预处理depth和fa数组
void bfs (int root)
{
    memset(depth,0x3f,sizeof depth);
    depth[0]=0,depth[root]=1;
    int hh=0,tt=0;
    q[0]=root;
    
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                q[++tt]=j;
                fa[j][0]=t;
                for(int k=1;k<=size;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}

//查询节点a,b的最近公共祖先
int lca (int a,int b)
{
    if(depth[a]<depth[b])swap(a,b);
    for(int k=size;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b])
            a=fa[a][k];
    if(a==b)return a;
    
    for(int k=size;k>=0;k--)
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    return fa[a][0];
}
```





___

### Tarjan——离线求LCA

> 在深度优先遍历时, 将所有点分为三大类:
>
> (1) 已经遍历过且回溯过的点, 标记为2
>
> (2) 正在搜索的分支上的点, 标记为1
>
> (3) 还未搜索到的点, 标记为0

<img src="E:\个人博客\博客内容\算法竞赛\提高算法\图论\Tarjan.png" width ="50%">

> 如果当前正在搜索上图中的点 `x` , 则找一下所有和这个点 `x` 相关的询问, 假设询问 `x` 和 `y` 的最近公共祖先, 如果点 `y` 在绿色圈中, 则可以得到 `x` 和 `y` 的 `LCA` 是图中对应的红色实心点; 如果 `y` 还没被搜索到, 则直接忽略即可, 后面的遍历过程中遍历到点 `y` 时, 就会处理这个询问

> 因此我们可以使用并查集将所有标记为 `2` 的点合并到它们对应的红色实心节点中, 当我们需要查看 `x` 和某个绿色圈中的点 `y` 的 `LCA` 时, 只需要查看一下点 `y` 合并到了哪个点中即可



```c++
//Tarjan离线求LCA算法模板
int n,m;	//n为节点数,m为询问数量
int h[N],e[M],ne[M],w[M],idx;
int p[N];
int ans[M];		//ans[i]记录第i个询问的LCA的值
int st[N];		//标记每个节点的状态0/1/2

vector<pair<int,int>> query[M];	//记录询问,first存查询的另外一个点,second存查询编号

//并查集操作
int find (int x)
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

//tarjan操作求每个询问
void tarjan (int u)
{
    st[u]=1;	//正在搜索分支上的点,标记为1
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            tarjan(j);
            p[j]=u;
        }
    }
    
    for(auto item: query[u])	//遍历所有和这个点有关的询问
    {
        int y=item.first,id=item.second;
        if(st[y]==2)ans[id]=find(y);
    }
    
    st[u]=2;	//已经遍历过且回溯过的点,标记为2
}

//主函数,记录所有询问到query[][]中
int main()
{
    for(int i=0;i<m;i++)
    {
        int a,b;
        cin>>a>>b;
        query[a].push_back({b,i});
        query[b].push_back({a,i});
    }
    
    for(int i=1;i<=n;i++)p[i]=i;
    tarjan(1);	//随便选其中一个节点作为根节点均可
    
    for(int i=0;i<m;i++)cout<<ans[i]<<' ';
    return 0;
}
```





---

### 树上差分

> **点权差分**
>
> `f[i]` 表示点 `i` 的点权, `w[i]` 表示 `i` 及其子树权值之和
>
> 若给 `[x,y]` 两点之间路径上所有点的权值 `+d` , 点差分因为需要加上 `LCA` 点, 但左右起点到终点时会加两次, 所有在此点及其父节点各减一份 `f[x] += d` , `f[y] += d` , `f[lca(x,y)] -= d` , `f[fa[lca(x,y)]] -= d`

> **边权差分**
>
> `f[i]` 表示点 `i` 到其父节点的边权, `w[i]` 表示 `i` 的子树权值之和
>
> 若给 `[x,y]` 两点之间路径上的所有边的权值 `+d` , 边差分由于边数等于点数减一, 不计 `LCA` 点, 所以在此点减两份 `f[x] += d` , `f[y] += d` , `f[lca(x,y)] -= d*2`

> 最后 `DFS` 由底向上统计更新即可



```c++
//树上遍历dfs(由下往上)
void dfs (int u,int fa)
{
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j==fa)continue;
        dfs(j,u);
        f[u]+=f[j];
    }
}
```



<div style="page-break-after:always;"></div>

# 有向图的强连通分量

### 强联通分量 Strongly Connected Components, SCC

<br>

##### 什么是强联通分量

> + 联通分量: 有向图中, 对一个联通分量中的任意两点 $u$ , $v$ ($u$ 可能等于 $v$ ), 一定存在 $u \to v$ 和 $v \to u$ 的路径
> + 强联通分量: "极大" 联通分量——如果在某个联通分量中加入任意不在该联通分量的一个顶点后, 该分量不再联通, 则称这个联通分量为强联通分量

<br>

##### SCC的应用

> 对于任意一个强联通分量, 对于其中任意两点 $u$ , $v$ 存在路径 $u \to v$ 与 $v \to u$ , 存在至少一个环. 而强联通分量之间不存在环, 否则可以合成一个联通分量. 因此如果我们对每个强联通分量进行缩点操作, 则新图一定是一个有向无环图 (DAG, 也称拓扑图).
>
> 有向图拥有更简单的结构, 对某些问题可以用相对简单的算法求解.
>
> 缩点操作: 同一强联通分量内的顶点视为一个顶点, 只保留不同强联通分量之间的边.

<br>

##### Tarjan求强联通分量

> **dfs中的4类边**
>
> 如果我们在图中按dfs的顺序建立一棵树 (深度搜索树), 这棵树存在4类边:
>
> 1. 树枝边: 树(深度搜索树) 边.
> 2. 前向边: $u$ 指向自己子孙 $v$ 的边. 树枝边可以认为是前向边的一种特殊情况.
> 3. 后向边: $v$ 指向自己祖先 $u$ 的边, 是图中存在联通分量的关键.
> 4. 横叉边: $u$ 指向左边分支节点 $v$ . 不存在指向右边, 否则其顺序恰好是dfs遍历顺序, 即树枝边.

> **Tarjan算法思想**
>
> 在有向图中如何形成一个联通分量:
>
> 1. 顶点 $u$ 存在后向边
> 2. 顶点 $u$ 存在横叉边指向 $v$ , 而 $v$ 的后续边指向 $u$ 的祖先节点

> **Tarjan算法具体实现**
>
> 引入时间戳概念, 对每个顶点记录两个时间戳:
>
> + $dfn(u)$ : dfs执行过程中, 顶点 $u$ 被访问的时间.
> + $low(u)$ : 顶点 $u$ 经过后续节点可以到达的最小时间点.
>
> 此外通过栈保存: 已经被dfs访问且还未找到对应SCC的顶点.
>
> 判断SCC: 对于顶点 $u$ , 若 $dfn(u) == low(u)$ , 则从栈顶到 $u$ 的顶点均属于同一SCC. 
>
> + $dfn(u) == low(u)$ 可以理解为从 $u$ 出发经过某些环最后到达自身, 且不能到达其他祖先节点.
> + 从栈顶到 $u$ 均属于同一SCC: 假设存在顶点 $v$ 在栈中且不属于当前SCC, 设顶点 $v$ 对应强联通分量代表节点为 $v^,$ (即 $dfn(v^,) == low(v^,)$ ), 则dfs顺序只能是 $u \to v^, \to v$ , 算法保证当回溯至 $v^,$ 时, 会将 $v$ 出栈, 所以假设不成立.

> **算法细节**
>
> + 在 $low(u)$ 更新过程中, 不考虑已经遍历且出栈的节点 $v$ : 已出栈说明节点 $v$ 属于其他强连通分量, 与 $u$ 独立.
> + 在 $low(u)$ 更新过程中, 对于已遍历且仍在栈中的节点 $v$ , 用 $low(v)$ 还是 $dfn(v)$ 更新? 都可以, 算法在节点回溯时才会更新对应 $low$ 值, 对于节点 $v$ 还没回溯, $low(v)$ 还未更新, 所以此时 $dfn(v) == low(v)$ . 

<br>

---

### Tarjan算法求强联通分量

##### Tarjan算法基于DFS

<br>

##### 几个数组和变量

> 1. 时间戳: 记录搜索到每个点的时间. 即对每个点根据搜索顺序进行标号排序.
> 2. $dfn$数组: 记录每个点的时间戳. (同时具有判重数组作用)
> 3. $low$数组: 记录每个点向上走所能达到的最高点 (即时间戳最小点).
> 4. $stk$栈: 记录当前强联通分量内的点.
> 5. $id$数组: 记录每个点所在的联通分量.
> 6. $scc\_cnt$: 强联通分量个数.

<br>

##### 模板

```c++
int timecnt;		//时间戳
int dfn[N];			//每个点的时间戳
int low[N];			//low[u]:u所在的子树中所有点中所能向上走到的时间戳最小的点
int scc_cnt;		//强联通分量的数量
int id[N];			//id[i]:表示i号点所在的强联通分量的编号
stack<int> stk;		//存储当前强联通分量里的所有点
int sizes[N];		//强联通分量的结点数量
bool in_stk[N];		//记录该点是否在栈中

void tarjan(int u)
{
    low[u] = dfn[u] = ++timecnt;
    stk.push(u);
    in_stk[u] = true;
    
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        
        if(!dfn[j])		//j点没有被遍历过,j点一定是在子树中
        {
            tarjan(j);		//遍历j
            low[u] = min(low[u], low[j]);
            //遍历过后的j的low可能已经找到一个更高的结点,所以要去更新u
        }
        
        else if(in_stk[j])	
        //j在栈中,则j和u之间一定是一条横叉边或前向边,即j的时间戳一点比u小
            low[u] = min(low[u], dfn[j]);
    }
    
    if(low[u] == dfn[u])	
    //到此处,u的所有边已经遍历完,如果low[u]==dfn[u]:得到了一个强联通分量
    {
        scc_cnt++;
        int y;		//此时该强连通分量的点全在栈中,全部取出
        do
        {
            y = stk.top();
            stk.pop();
            in_stk[y] = false;
            id[y] = scc_cnt;
            sizes[scc_cnt]++;
        }while (y != u);
    }
}
```



<div style="page-break-after:always;"></div>

# 无向图的双连通分量

### 边双连通分量 e-DCC

> ##### 定义
>
> 桥: 对于一个无向连通图来说, 如果删除一条边之后, 图变得不再连通了, 那么就称这条边为桥.
>
> 边的双连通分量: 一个极大的不包含桥的连通块.
>
> ##### 性质
>
> + 对于一个边双连通分量来说, 我们不管删除连通分量的哪一条边, 它都是连通的.
> + 对于一个边双连通分量来说, 任意两点之间至少包含两条不相交的路径.

<br>

> ##### tarjan算法求边双连通分量
>
> + 无向图不存在横叉边
>
> + 时间戳
>
>   dfn[u]: 遍历到当前节点的编号
>
>   low[u]: 不经过走过来的那条边(父边) 能走到的最小编号节点
>
> + 判断桥:
>
>   对于x, y之间的一条边, 如果low[y]能到x的祖先节点, 那么就不是桥, 若low[y] = y, 即是桥.
>
>   $dfn[x] < low[y]$ (严格小于)
>
> + 如果找到所有边的双连通分量:
>   1. 将所有的桥删掉, 剩下的都是边联通分量
>   2. 用栈存储搜到的所有点, 当搜到一个点的 $dfn[x] == low[x]$ , 即这个点上面的一条边就为桥, 将栈中所有点标记即可

<br>

##### tarjan算法求e-dcc代码模板

```c++
void tarjan (int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk.push(u);
    
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if(dfn[u] < low[j])	//说明这条边是桥
                is_bridge[i] = is_bridge[i ^ 1] = true;	//i^1表示i的反向边
        }
        else if(i != (from ^ 1))
            low[u] = min(low[u], dfn[j]);
    }
    
    if(dfn[u] == low[u])
    {
        dcc_cnt ++;
        int y;
        do
        {
            y = stk.top();
            stk.pop();
            id[y] = dcc_cnt;
        }while(y != u);
    }
}
```

<br>

---

### 点双连通分量 v-DCC

> ##### 定义
>
> 割点: 对于一个无向连通图来说, 如果删除某个点之后, 该连通图不连通了, 那么就称其为该连通图的割点.
>
> 点双连通分量: 一个极大的不包含割点的连通块.
>
> ##### 性质
>
> + 对于一个点双连通分量来说, 每一个割点至少属于两个联通分量.

<br>

##### tarjan算法求v-dcc代码模板

```c++
//dcc_cnt:联通分量的数量,不等于割点数量
void tarjan (int u)
{
    dfn[u] = low[u] = ++timestamp;
    stk.push(u);
    
    //只有一个点
    if(u == root && h[u] == -1)
    {
        dcc_cnt ++;
        dcc[dcc_cnt].push_back(u);
        return;
    }
    
    int cnt = 0;	//删除该点后得到的新的连通块个数
    for(int i = h[u]; i != -1; i = -1)
    {
        int j = e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            
            if(dfn[u] <= low[j])
            {
                cnt++;
                
                //不是根节点或这删除该点后连通块个数大于等于2,符合割点条件
                if(u != root || cnt > 1) cut[u] = true;
                
                dcc_cnt ++;
                int y;
                do
                {
                    y = stk.top();
                    stk.pop();
                    dcc[dcc_cnt].push_back(y);
                }while(y != j);
                
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}

for(root = 1; root <= n; root++)
    if(!dfn[root])
        tarjan(root);
```



<div style="page-break-after:always;"></div>

# 欧拉回路和欧拉路径

> **哥尼斯堡七桥问题**
>
> 七桥问题时18世纪著名古典数学问题之一. 在哥尼斯堡的一个公园里, 有七座桥将河中两个岛及岛与河岸连接起来, 问是否可能从这四块陆地中任一块出发, 恰好通过每座桥一次, 再回到起点
>
> 欧拉于1736年研究并解决了此问题, 并因此开创了数学的一个新的分支——图论与几何拓扑



> **欧拉回路和欧拉路径**
>
> ① 对于无向图, 所有边都是联通的
>
> $\quad$ (1) 存在欧拉路径的充要条件: 度数为奇数的点只能有0或2个
>
> $\quad$ (2) 存在欧拉回路的充要条件: 度数为奇数的点只能有0个
>
> ② 对于有向图, 所有边都是联通的
>
> $\quad$ (1) 存在欧拉路径的充要条件: 要么所有点的出度均等于入度; 要么除了两个点之外, 其余所有点的出度等于入度, 剩余的两个点: 一个满足出度比入度多1(起点), 另一个满足入度比出度多1(终点)
>
> $\quad$ (2) 存在欧拉回路的充要条件: 所有点的出度均等于入度



```c++
//dfs暴搜欧拉路径
void dfs (int u)
{
    for(int i=1;i<=n;i++)
        if(g[u][i])
        {
            g[u][i]--,g[i][u]--;
            dfs(i);
        }
    ans[++cnt]=u;
}

//ans数组逆序存储路径,需要倒序输出
for(int i=cnt;i;i--)cout<<ans[i]<<' ';
```



<div style="page-break-after:always;"></div>

# 并查集

### 并查集

> 操作:
>
> 1. 合并两个集合
> 2. 查询某元素祖宗节点

<br>

> 优化:
>
> 1. 路径压缩
> 2. 按秩合并
>
> 若只加一种优化, 两种操作的时间复杂度都为 $O(logn)$ , 但常数很小. 加上两种优化, 复杂度为 $O(\alpha(n))$ , 近似常数

<br>

> 扩展:
>
> 1. 维护集合大小. 对于集合中的每个元素, 其所在集合的大小是相同的, 因此只需绑定到根节点
> 2. 维护每个点到根节点的距离. 由于每个点到根的距离不同, 因此要绑定到每个点上
>
> 扩展二通常用于处理分类问题, 若把每对关系看成边, 能用并查集处理的前提是边无向, 且关系具有传递性. 若是有向边, 只能用传递闭包
>
> 解决分类问题除了用带 (边) 权 (到根的距离) 并查集, 还可用扩展域并查集. 前者的思想是维护相对关系, 即要知道两个元素的关系, 只要知道它们和根的关系. 后者的思想是枚举, 即考虑问题的所有情况, 每种情况下都要成立. 扩展域并查集的空间复杂度是 $O(kn)$ , 其中k是元素的种类, 可能会超内存; 时间复杂度和带权一致, 但常数会增大

<br>

```c++
int find (int x)
{
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
}
```

<br>

---

### 二维并查集

> [AcWing 1250. 格子游戏](https://www.acwing.com/problem/content/1252/)

> 将二维坐标映射成一维坐标, 转化为一维并查集

<br>

```c++
//把二维坐标映射成一维坐标,x,y下标从0开始
int get (int x,int y)
{
    return x*n + y;
}
```

<br>

---

### 并查集求连通块大小 + 01背包

> [AcWing 1252. 搭配购买](https://www.acwing.com/problem/content/1254/)

> 连通块可用并查集维护, 对于块内所有点, 其所在块的总价格相同, 总体积也相同, 只需绑定到根节点, DP时也只需遍历根节点, 即 `p[x] = x` 的点

<br>

```c++
//并查集维护集合大小,将集合a合并到集合b中
a = find(a), b = find(b);
if(a != b)
{
    v[b] += v[a];	//只需绑定到根节点
    w[b] += w[a];
    p[a] = b;
}

//01背包
for(int i = 1;i <= n;i++)
    if(p[i] == i)	//dp只需遍历根节点
        for(int j = m;j >= v[i];j--)
            dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
```

<br>

---

### 并查集 + 离散化

> [AcWing 237. 程序自动分析](https://www.acwing.com/problem/content/239/)

> 离散化通常分两种:
>
> 1. 保序$\quad$ 用 `vector` 存储, 排序、去重、二分
> 2. 无需保序 $\quad$ 直接用 `map` 或 `unordered_map`

<br>

```c++
//离散化
unordered_map <int,int> s;
int get (int x)
{
    if(!s.count(x)) s[x] = ++idx, p[s[x]] = s[x];
    return s[x];
}

//并查集合并两个集合
a = get(a), b = get(b);
a = find(a), b = find(b);
if(a != b)p[a] = b;
```

<br>

---

### 带权并查集

> [AcWing 238. 银河英雄传说](https://www.acwing.com/problem/content/240/)

> 若只问两艘战舰是否在同一列, 只需用并查集维护连通块. 现在问同一列中, 两艘战舰的间隔是多少. 若维护两两关系, 则复杂度为 $O(n^2)$ . 可利用前缀和思想, 维护战舰到队头的距离
>
> 1. 让队头作为并查集的根节点
> 2. 合并时, 让 `d[pa] = sz[pb]` , `sz[pb] += sz[pa]`
>
> `sz` 相加是显然的. 对于 `d[x]` , 它表示 `x` 到父节点的距离, 路径压缩回溯时, 让它加上父节点到根的距离. 假设 `pb` 是队头, 将 `a` 合并到 `b` 时, `b` 集合内元素的距离不用改变, `a` 集合内元素的距离都要加上 `sz[pb]` . 由于路径压缩的存在, 只要让 `d[pa]` 加即可, 它的初始值是 `0` 

<br>

```c++
//初始化
for(int i = 1;i < N;i++)
    p[i] = i, sz[i] = 1, d[i] = 0;

//返回x的队头 + 路径压缩
int find (int x)
{
    if(x != p[x])
    {
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    }
    return p[x];
}

//将集合x合并到集合y中
int px = find(x), py = find(y);
if(px != py)
{
    d[px] = sz[py];
    sz[py] += sz[px];
    p[px] = py;
}
```

<br>

> [AcWing 239. 奇偶游戏](https://www.acwing.com/problem/content/241/)

> 前缀和思想: 记 $S_i = \textstyle \sum_{j=0}^{i} a_j$ , 则 a[l ~ r] 有奇数个1等价于 $S_r - S_{l-1}$ 是奇数, 等价于 $S_r$ 和 $S_{l-1}$ 奇偶性不同. 同理, 有偶数个1等价于它们的奇偶性相同
>
> 考虑奇偶性无矛盾是否等价于原问题无矛盾. 若奇偶性矛盾, 则原问题有矛盾. 反之, 若无矛盾, 即存在合法的 S[0 ~ n] , 可构造 $a_i = | S_i - S_{i-1}|$ , 原问题也无矛盾
>
> 问题等价于存在两类数字, 给定若干类别陈述, 判定分类是否正确. 数字的个数最多 $10^4$ , 但数字的范围是 $[0, 10^9]$ , 需要先离散化

<br>

> 维护"相对"关系, 如果知道 `x` 和 `y` 与根是否是同类, 就能知道 `x` 和 `y` 是否同类, 即关系是无向的, 且具有传递性. 记 `d[x]` 为 `x` 与 `p[x]` 的关系, `0` 表示同类, `1` 表示异类, 则 `x` 与 `y` 的关系是 `d[x] ^ d[y]`
>
> 对给定 `x` , `y` , `type`
>
> 1. 若它们不在同一集合, 则至少有一个数在之前未出现过, 此时不会有矛盾, 将它们合并. 若将 `x` 合并到 `y` , 则令 `p[px] = py` . 又 `d[x] ^ d[px] ^ d[y] = type` , 则 `d[dx] = type ^ d[x] ^ d[y]`
> 2. 若在相同集合, 则判定之前类别是否与当前陈述一致, 不一致则矛盾, 即 `d[x] ^ d[y] == type` 是否成立

<br>

```c++
//返回x的根 + 路径压缩
int find (int x)
{
    if(x != p[x])
    {
        int root = find(p[x]);
        d[x] ^= d[p[x]];
        p[x] = root;
    }
    return p[x];
}

//将集合a合并到集合b中
int pa = find(a), pb = find(b);
if(pa != pb)
{
    p[pa] = pb;
    d[pa] = d[a] ^ d[b] ^ type;
}
```

<br>

---

### 扩展域并查集

> [AcWing 239. 奇偶游戏](https://www.acwing.com/problem/content/241/)

> 枚举思想: 考虑所有情况, 每种情况都要成立. 每个数只能是奇数或偶数, 让 `x` 代表 `x是奇数` , `x+n` 代表 `x是偶数` . **此时并查集内的元素不再是数字本身, 而是条件**, 并且两种条件要同时成立

<br>

> ① 若 `x` , `y` 是同类
>
> 1. 若 `x是奇数` , 则 `y是奇数`
> 2. 若 `x是偶数` , 则 `y是偶数`
> 3. 同时合并 `(x+n, y+n)` , `(x, y)`
> 4. 判断矛盾: `find(x) == find(y+n)` 或 `find(x+n) == find(y)` 均可, 因为只要一个成立, 另一个一定成立
>
> ② 若 `x` , `y` 是异类
>
> 1. 若 `x是奇数` , 则 `y是偶数`
> 2. 若 `x是偶数` , 则 `y是奇数`
> 3. 同时合并 `(x, y+n)` , `(x+n, y)`
> 4. 判断矛盾: `find(x) == find(y)` 或 `find(x+n) == find(y+n)` 均可, 因为只要一个成立, 另一个一定成立

<br>

> 注意: 对于分为三类的扩展域并查集
>
> 若 `find(x) == find(y)` 是正确要求, 则判断矛盾的语句应该是 `find(x) == find(y+n) || find(x) == find(y+n*2)` , 而不是 `find(x) != find(y)`
>
> 维护类别更多的扩展域并查集同理



<div style="page-break-after:always;"></div>

# 树状数组

> 树状数组, 可以高效地计算数列前缀和, 它的查询(求前缀和) 和更新(修改) 操作都可以在 `O(logn)` 的时间完成



> `tr[i]` 存储以 `i` 为终点, 长度为 `lowbit(i)` 的区间
>
> 修改: `for( int i = x ; i <= n ; i += lowbit(i) ) tr[i] += c`
>
> 查询: `for( int  i = x ; i ; i -= lowbit(i) ) sum += tr[i]`



```c++
//树状数组操作

//返回非负整数x在二进制表示下最低位1及其后面的0构成的数值
int lowbit (int x)
{
    return x&-x;
}

//将序列中第x个数加上k
void add (int x,int k)
{
    for(int i=x;i<=n;i+=lowbit(i))tr[i]+=k;
}

//查询序列前x个数的和
int ask (int x)
{
    int sum=0;
    for(int i=x;i;i-=lowbit(i))sum+=tr[i];
    return sum;
}

//O(n)的建树方法
void build ()
{
    for(int x=1;x<=n;x++)
    {
        tr[x]=a[x];
        for(int i=x-1;i>=x-lowbit(x)+1;i-=lowbit(i))
            tr[x]+=tr[i];
    }
}
```





___

### 树状数组的应用

> **① 点更新, 区间查询**

> **② 区间更新, 点查询**
>
> 使用差分, 维护差分数组 `d[i] = a[i] - a[i-1]`
>
> 区间更新变成了 `[l,r]` 两端 `l` 和 `r` 的更新, 点查询也就变成了 `[1,x]` 的区间查询

> **③ 区间更新, 区间查询**
>
> 使用差分, 维护差分数组 `c[i] = a[i] - a[i-1]`
>
> 区间更新变成了 `[l,r]` 两端 `l` 和 `r` 的更新
>
> 对于求解一个 `S = a[1,x]` 的前缀和, 有:
>
> `S` = `a[1]` + `a[2]` + $\cdots$ + `a[x]`
>
> $\quad$= `c[1]` + `(c[1] + c[2])` + $\cdots$ + `(c[1] + c[2] + ... + c[x])`
>
> $\quad$= `x*c[1]` + `(x-1)*c[2]` + $\cdots$ + `1*c[x]`
>
> $\quad$= `(x+1)` * `(c[1] + c[2] + ... + c[x])` - `(1*c[1] + 2*c[2] + ... + x*c[x])`
>
> 因此可以使用另一个辅助数组 `D` 来维护 `d[i] = i*c[i]` 的前缀和



```c++
//区间更新,区间查询模板

int n;
int a[N],tr1[N],tr2[N];
//a[]存储原数组,b[i]=a[i]-a[i-1]为a的差分数组,tr1[i]维护b[i]的前缀和,tr2[i]维护i*b[i]的前缀和

int lowbit (int x)
{
    return x&-x;
}

void add (int tr[],int x,int c)
{
    for(int i=x;i<=n;i+=lowbit(i))tr[i]+=c;
}

int sum (int tr[],int x)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))res+=tr[i];
    return res;
}

int prefix_sum (int x)	//求a[1,x]的前缀和
{
    return sum(tr1,x)*(x+1)-sum(tr2,x);
}

int main()
{
    for(int i=1;i<=n;i++)
    {
        int b=a[i]-a[i-1];	//差分数组b[i]=a[i]-a[i-1]
        add(tr1,i,b);		//tr1[]维护b[i]的前缀和
        add(tr2,i,b*i);		//tr2[]维护i*b[i]的前缀和
    }
}
```



<div style="page-break-after:always;"></div>

# 线段树

> 线段树又称区间树, 是一种基于分治思想的二叉树结构, 每个节点代表一段区间



> 线段树的每个节点代表一个区间
>
> 对于每个内部节点 `[l,r]` , 它的左儿子是 `[l,mid]` , 右儿子是 `[mid+1,r]`
>
> 用一维数组存整棵树
> $$
> 对于编号为x的节点
> \begin{cases}
> 父节点: [\dfrac{x}{2}] \quad\quad\quad\quad\, x\gg1 \\[1.5ex]
> 左儿子: 2x \quad\quad\quad\quad\,\,\,\, x\ll1\\[1.5ex]
> 右儿子: 2x+1 \quad\quad\quad x\ll1|1\\[1.5ex]
> \end{cases}
> $$
> **对于一个长度为 `n` 的区间, 需要建立大小为 `4n` 的数组维护**
>
> 每个节点表示该节点表示区间的某种属性



```c++
//线段树操作模板(以维护区间最大值为例)

//结构体存储整棵线段树
struct Node
{
    int l,r;
    int v;	//区间[l,r]的最大值
}tr[N*4]; //空间大小开区间长度四倍

//建树操作
void build (int u,int l,int r)	//构建节点u,其维护的区间是[l,r]
{
    tr[u]={l,r};
    if(l==r)return;	//已经是叶子节点
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);	//递归构建左右子区间
}

//push_up操作,用子节点信息来更新父节点信息(以维护区间最大值为例)
void push_up (int u)
{
    tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}

//query操作,用来查询某一段区间内的信息(以最大值为例)
int query (int u,int l,int r)	//从节点u开始查询,[l,r]表示需要查询的目标区间
{
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u].v;
    //说明当前节点维护的区间已经被查询区间完全包含,不需要继续向下递归
    
    int res=-0x3f3f3f3f;
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid)res=max(res,query(u<<1,l,r));	//递归左子区间
    if(r>mid)res=max(res,query(u<<1|1,l,r));	//递归右子区间
    return res;
}

//modify操作,用来修改某一叶子节点并更新其所有父节点
void modify (int u,int x,int v)	//从节点u开始递归查找,将第x个点的值修改为v
{
    if(tr[u].l==x&&tr[u].r==x)tr[u].v=v;
    else
    {
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid)modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        push_up(u);
    }
}
```



> **懒标记**
>
> 在进行区间修改时, 可以先需要修改的区间打上标记, 等查询到该区间时再将标记传递
>
> 借助懒标记, 可以节省大量的时间, 将区间修改的时间复杂度降至 `O(logn)`

```c++
//带懒标记的线段树模板(以区间修改,区间和查询为例)

struct Node
{
    int l,r;
    long long sum,add;	//add即为懒标记,储存子节点需要加上的数(不包括父节点)
}tr[N*4];

void pushup (int u)
{
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}

void pushdown (int u)	//向下传递懒标记
{
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    if(root.add)
    {
        left.add+=root.add;
        left.sum+=(long long)(left.r-left.l+1)*root.add;
        right.add+=root.add;
        right.sum+=(long long)(right.r-right.l+1)*root.add;
        root.add=0;
    }
}

void build (int u,int l,int r)
{
    if(l==r)tr[u]={l,r,w[r],0};
    else
    {
        tr[u]={l,r};
        int mid=l+r>>1;
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);
        pushup(u);
    }
}

void modify (int u,int l,int r,int d)	//给[l,r]内每个数加上d
{
    if(tr[u].l>=l&&tr[u].r<=r)
    {
        tr[u].sum+=(long long)(tr[u].r-tr[u].l+1)*d;
        tr[u].add+=d;
    }
    else	//左右子区间要分裂
    {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if(l<=mid)modify(u<<1,l,r,d);
        if(r>mid)modify(u<<1|1,l,r,d);
        pushup(u);
    }
}

long long query (int u,int l,int r)	//查询区间[l,r]的和
{
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;
    
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    long long sum=0;
    if(l<=mid)sum=query(u<<1,l,r);
    if(r>mid)sum+=query(u<<1|1,l,r);
    return sum;
}
```

<br>

> ##### 同时维护加法和乘法操作的带懒标记的线段树
>
> 需要两个懒标记, 一个存储加法, 一个存储乘法.
>
> 同时维护加法和乘法, 先乘法后加法: $(x \times a + b) \times c + d = x \times a \times c + b \times c + d = x \times (a \times c) + (b \times c + d)$ .

```c++
//同时维护加法和乘法操作的带懒标记的线段树模板

struct Node
{
    int l, r;
    int sum;
    int add;	//加法的懒标记
    int mul;	//乘法的懒标记
}tr[N*4];

void pushup (int u)
{
    tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum) % p;
}

//(x * a + b) * c + d = x * (a * c) + (b * c + d)
void eval (Node &t, int add, int mul)
{
    t.sum = ((LL)t.sum * mul + (LL)(t.r-t.l+1) * add) % p;
    t.add = ((LL)t.add * mul + add) % p;
    t.mul = (LL)t.mul * mul % p;
}

void pushdown (int u)
{
    eval(tr[u<<1], tr[u].add, tr[u].mul);
    eval(tr[u<<1|1], tr[u].add, tr[u].mul);
    
    tr[u].add = 0, tr[u].mul = 1;
}

void build (int u, int l, int r)
{
    if(l == r) tr[u] = {l, r, a[l], 0, 1};
    else 
    {
        tr[u] = {l, r, 0, 0, 1};
        
        int mid = (l + r) >> 1;
        build(u<<1, l, mid), build(u<<1|1, mid+1, r);
        
        pushup(u);
    }
}

void modify (int u, int l, int r, int add, int mul);
{
    if(tr[u].l >= l && tr[u].r <= r) eval(tr[u], add, mul);
    else
    {
        pushdown(u);
        
        int mid = (tr[u].l + tr[u].r) >> 1;
        if(l <= mid) modify(u<<1, l, r, add, mul);
        if(r > mid) modify(u<<1|1, l, r, add, mul);
        
        pushup(u);
    }
}

int query (int u, int l, int r)
{
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    
    pushdown(u);
    
    int mid = (tr[u].l + tr[u].r) >> 1, sum = 0;
    if(l <= mid) sum = query(u<<1, l, r);
    if(r > mid) sum = (sum + query(u<<1|1, l, r)) % p;
    
    return sum;
}

//乘法操作,给[l,r]内所有数乘上d
//a * d = (a + 0) * d
modify(1, l, r, 0, d);

//加法操作,给[l,r]内所有数加上d
//a + d = (a + d) * 1
modify(1, l, r, d, 1);
```


<div style="page-break-after:always;"></div>

#  可持久化数据结构

> 通常的数据结构, 一旦进行了CRUD操作, 那么数据或状态将发生变化. 因此, 就能够保存当前数据集的最新状态
>
> 如果想要记录数据的历史版本, 那么最朴素的方式就是将每一个版本都做完全备份. 这样做显然会增加时间和空间的开销, 而且通常在进行一次操作后, 发生变化的数据只占原数据集的一小部分. 因此, 自然的想法就是: 将未改变的部分直接继承, 然后多保存增量部分
>
> 可持久化数据结构就是完成了上述想法, 提升了空间效率. 可持久化数据结构实现的核心是: 将不变部分的指针交给新版本, 增量部分开辟新内存空间, 同一内存空间被多个版本数据结构通过指针访问. 这种方式有点类似于浅拷贝, 在创建新副本时, 不变部分只是多了些指针引用而已, 指针的内存就太小了, 因此可以大大减少内存开销

<br>

> 可持久化的前提: 在修改的过程中, 数据结构本身的拓扑结构不会发生改变
>
> 可持久化的数据结构例子: trie树, 线段树——主席树, 堆, 树状数组
>
> 不可持久化的数据结构例子: 平衡树 (左旋右旋后, 拓扑结构会发生改变)
>
> 可持久化数据结构解决的问题: 我们希望把每次修改的版本都记录下来 (类似git工具), 可以存下来数据结构的所有历史版本
>
> 核心思想: 只会记录每一个版本与前一个版本不一样的节点

<br>

---

### 可持久化字典树

![可持久化Trie](E:\个人博客\博客内容\算法竞赛\提高算法\高级数据结构\可持久化Trie.jpeg)

<br>

##### 如何理解当前版本与上一版本之间的区别

> 每一个版本只是比较与它上一个版本的区别
>
> 类似于git的操作: 对于节点的克隆 (裂开) (该路径有修改, 就克隆, 然后再在克隆的基础上修改) 和直接指向 (该路径无修改, 就直接指向)
>
> 如何克隆节点的克隆和直接指向

<br>

> 这一个版本与上一个版本的区别在于新加入的这一个数
>
> 一些特点: 因为每个新版本都要新加信息, 所以根节点每次都要从上一个版本克隆
>
> 一般每次都只会新增一个分支
>
> 每次当前的链都是新建一个节点, 前面一个点如果有的话, 就把它完全copy过来; 每次生成当前路径的新的一个点, 然后继续同时往下走

<br>

> 注意: `idx++` 和 `++idx` 要统一
>
> 并且, 如果是 `idx++` , `idx` 要初始化为 `1` ; 如果是 `++idx` , `idx` 要初始化为 `0`

<br>

```c++
p--->表示根节点, root[]--->表示版本号
p = root[i-1];			//上一个版本的根节点的指针,用p来表示(初始时,p指向上个版本的根节点)
q = root[i] = idx++;	//新的版本开一个新的节点指针,用q来表示(初始时,q指向当前版本的根节点)
if(p) tr[q] = tr[p];   //如果p是空的,说明是全新的节点,不用管;如果非空p和q是对应的,q应是p的克隆
tr[q][si] = idx++;		//假设当前的指针对应的儿子的节点是si,就应该给它开辟一个新的点(空间)
p = tr[p][si], q = tr[q][si];
```

<br>

### 01 Trie树

> [AcWing 256. 最大异或和](https://www.acwing.com/problem/content/description/258/)

> 思路:
>
> 1. 初始化前缀和 `s[i] = a[1] ^ a[2] ^ … ^ a[i]` 
> 2.  `a[p] ^ a[p+1] ^ … ^ a[n] ^ x == s[p-1] ^ s[n] ^ x`
> 3. 设 `C = s[n] ^ x` , 故只需要求在 `l <= p <= r` 中, `s[p-1] ^ C` 最大即可
> 4. 用二进制来表示 `s[i]` , `max_id[i]` 表示这个数在前缀和 `s[i]` 是第几个数
> 5. 怎么使 `s[p-1] ^ C` 最大, 可以使高位尽量取与 `C` 相异的数字

<br>

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 6e5 + 10, M = N * 24;
int n,m;
int root[M];	//记录版本号
int tr[M][2],idx=1;		//trie树
int max_id[M];		//记录每个trie树节点对应的子树中的最大版本号
int s[N];	//前缀和

//从左往右四个参数:当前版本,这个数的第几位,前一个版本对应的节点,当前版本的被处理的这个父节点
void insert (int i,int k,int p,int q)
{
    if(k < 0)
    {
        max_id[q] = i;
        return;
    }
    
    int v = s[i] >> k & 1;
    if(p) tr[q][v^1] = tr[p][v^1];	//如果前一个版本中,另一面存在(v^1指和v相反的一侧),
    //那么把这一整块copy到当前版本的这个父节点下,v这一侧为新增的路径,需要新开辟
    tr[q][v] = idx++;
    
    insert(i,k-1,tr[p][v],tr[q][v]);
    
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

//从左往右三个参数:当前版本,最后需要异或的常数,版本id限制(需要>=L)
int quert (int root,int C,int L)
{
    int p = root;
    for(int i = 23;i >= 0;i--)
    {
        int v = C >> i & 1;
        if(max_id[tr[p][v^1]] >= L) p = tr[p][v^1];
        else p = tr[p][v];
    }
    
    //最后找下来的叶节点的版本是多少,说明目标数即为第几次插入的那个数
    return C ^ s[max_id[p]];	
}

int main()
{
    cin>>n>>m;
    
    max_id[0] = -1;	//初始是最小的版本号
	root[0] = idx++;
    insert(0,23,0,root[0]);
    
    for(int i = 1;i <= n;i++)
    {
        int x;
        cin>>x;
        s[i] = s[i-1] ^ x;
        root[i] = idx++;
        insert(i,23,root[i-1],root[i]);
    }
    
    char op[2];
    int l,r,x;
    
    while(m--)
    {
        cin>>op;
        if(*op == 'A')
        {
            cin>>x;
            n++;
            s[n] = s[n-1] ^ x;
            root[n] = idx++;
            insert(n,23,root[n-1],root[n]);
        }
        else
        {
            cin>>l>>r>>x;
            cout<<query(root[r-1],s[n]^x,l-1)<<'\n';	//l-1 <= p-1 <= r-1
        }
    }
    
    return 0;
}
```

<br>

---

### 可持久化线段树——主席树

##### 可持久化线段树简介

> 可持久化线段树, 就是保留历史的线段树

<br>

##### 可持久化线段树的基本概念

> 可持久化线段树, 就是在线段树的每次操作中保留历史记录, 并且从第i个线段树的根开始访问第i个历史版本的线段树, 其中初始版本的编号为0

<br>

##### 可持久化线段树的存储方法

> 可持久化线段树无法使用普通线段树的堆式存储法, 所以要采用动态开点法. 即和trie树一样的方法. 为了好写, 我们把每一个节点表示的区间放到函数的参数内部, 这样可以有效减少空间和代码实现难度
>
> 每次修改会多出 $log_2n$ 个节点, 所以一共要开 $4×n + m×log_2n$ 个点

<br>

```c++
struct segment_tree_node
{
    int l,r,sum,add;	//左子节点,右子节点,要维护的信息和懒标记
}tr[4*N + M*MAX_LOG];	//空间要开足

int root[M],idx;	//每次操作的根,当前分配到哪个点了

void push_up (int u)
{
    tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum;
}

void push_down (int u,int l,int r)
{
    auto &root = tr[u], &left = tr[tr[u].l], &right = tr[tr[u].r];
    int mid = l + r >> 1;
    if(root.add)
    {
        left.add += root.add, left.sum += (mid-l+1)*root.add;
        right.add += root.add, right.sum += (r-(mid+1)+1)*root.add;
        root.add = 0;
    }
}
```

<br>

##### 建立可持久化线段树

> 动态开点的线段树建立和普通线段树建立类似, 只是变为动态开点了

<br>

```c++
int build (int l,int r)	//返回[l,r]区间所组成线段树的编号
{
    int u = ++idx;	//动态开点
    if(l == r) return u;
    int mid = l + r >> 1;
    tr[u] = {build(l,mid), build(mid+1,r), 0};	//存下左儿子和右儿子的编号
    return u;
}
```

<br>

##### 单点修改

> 我们一开始先从要修改的位置, 假设是从第v次操作的根( $root_v$ )开始修改, 每次我们先拷贝下当前节点在 $root_v$ 中的位置的节点(一模一样拷贝), 然后把要修改的位置(左儿子或右儿子)递归修改即可

<br>

```c++
//当前已经复制到v,要把第x个数加上d,当前的区间是[l,r]
int insert (int v,int l,int r,int x,int d)
{
    int u = ++idx;	//动态开点
    tr[u] = tr[v];	//拷贝节点
    if(l == r)
    {
        tr[u].sum += d;
        return u;
    }
    push_down(u,l,r);
    int mid = l + r >>1;
    if(x <= mid) tr[u].l = insert(tr[v].l,l,mid,x,d);	//修改左子树
    else tr[u].r = insert(tr[v].r,mid+q,r,x,d);		//修改右子树
    push_up(u);
    return u;
}
```

<br>

##### 区间修改

> 类似线段树的区间修改, 就是在单点修改的基础上加上了懒标记

<br>

```c++
//当前已经复制到v,要在[L,R]加上d,当前的区间是[l,r]
int insert (int v,int l,int r,int L,int R,int d)
{
    int u = ++idx;	//动态开点
    tr[u] = tr[v];	//拷贝节点
    if(L <= l && r <= R)
    {
        tr[u].sum += (r-l+1)*d;
        tr[u].add += d;
        return u;
    }
    push_down(u,l,r);
    int mid = l + r >> 1;
    if(L <= mid) tr[u].l = insert(tr[v].l,l,mid,L,R,d);
    if(R >= mid+1) tr[u].r = insert(tr[v].r,mid+1,r,L,R,d);
    push_up(u);
    return u;
}
```

<br>

##### 单点查询

> 类似单点修改, 返回时返回要查询的答案

<br>

```c++
int query (int u,int l,int r,int x)	//从第u个历史版本查询,当前区间是[l,r],查询x的值
{
    if(l == r) return tr[u].sum;
    push_down(u);
    int mid = l + r >> 1;
    if(x <= mid) return query(tr[u].l,l,mid,x);
    else return query(tr[u].r,mid+1,r,x);
}
```

<br>

##### 区间查询

> 类似区间修改, 返回时返回要查询的答案

<br>

```c++
int query (int u,int l,int r,int L,int R)	//从第u个历史版本查询,当前区间是[l,r],查询[L,R]的值
{
    if(L <= l && r <= R) return tr[u].sum;
    push_down(u);
    int mid = l + r >> 1;
    int ans = 0;
    if(L <= mid) ans += query(tr[u].l,l,mid,L,R);
    if(R >= mid+1) ans +=query(tr[u].r,mid+1,r,L,R);
    return ans;
}
```



<div style="page-break-after:always;"></div>

# 平衡树 —— Treap

### 平衡树分类

> + treap (BST + heap(大根堆))
> + 红黑树
> + splay
> + sbt
> + AVL

<br>

---

### BST(二叉搜索树)

> + 定义: 二叉搜索树 (Binary Search Tree), 简称 BST, 是满足某些条件的特殊二叉树. 任何一个节点的左子树上的点, 都严格小于当前节点, 任何一个节点的右子树上的点, 都严格大于当前节点. 任何一棵子树, 也都满足上面的条件. 另外二叉搜索树中, 是不存在重复节点的.
> + 性质
>   + 将任意一个点看作根节点, 则这个点的左右子树都是 BST
>   + BST 中的最小节点, 一定是整棵树最左下的叶子节点, BST 中的最大节点, 一定是整棵树最右下的叶子节点
>   + BST 的中序遍历是一个单调递增序列
> + 本质: 动态维护一个有序序列 (有序集合)
> + 基本操作
>   + 插入
>   + 删除
>   + 找前驱/ 后继
>   + 找最大值/ 最小值
>   + 求某个数在平衡树中的序号
>   + 求平衡树中序号为 $k$ 的数
>   + 求比某个值大的最小节点的值 (这个值不一定在平衡树中)
>   + 求比某个值小的最大节点的值 (这个值不一定在平衡树中)

<br>

---

### Treap

> ###### 基本操作
>
> 1. 插入数值 $x$ 
> 2. 删除数值 $x$ 
> 3. 查询数值 $x$ 的排名
> 4. 查询排名为 $x$ 的数值
> 5. 求数值 $x$ 的前驱 (前驱定义为小于 $x$ 的最大的数)
> 6. 求数值 $x$ 的后继 (后继定义为大于 $x$ 的最小的数)

<br>

##### 算法模板

```c++
int root, idx;

struct Node
{
    int l, r;
    int key, val;
    int cnt, size;
}tr[N];

void pushup (int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

//开辟新的节点
int get_node (int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

//右旋
void zig (int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

//左旋
void zag (int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

//建树
void build()
{
    get_node(-INF), get_node(INF);	//哨兵
    root = 1, tr[1].r = 2;
    pushup(root);
    
    if(tr[1].val < tr[2].val) zag(root);
}

//插入一个数 key
void insert (int &p, int key)
{
    if(!p) p = get_node(key);
    else if(tr[p].key == key) tr[p].cnt ++ ;
    else if(tr[p].key > key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if(tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}

//删除一个数 key
void remove (int &p, int key)
{
    if(!p) return;
    if(tr[p].key == key)
    {
        if(tr[p].cnt > 1) tr[p].cnt -- ;
        else if(tr[p].l || tr[p].r)
        {
            if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                zig(p);
                remove(tr[p].r, key);
            }
            else
            {
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if(tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);
    
    pushup(p);
}

//通过数值找排名
int get_rank_by_key (int p, int key)
{
    if(!p) return 0;
    if(tr[p].key == key) return tr[tr[p].l].size + 1;
    if(tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

//通过排名找数值
int get_key_by_rank (int p, int rank)
{
    if(!p) return INF;
    if(tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l, rank);
    if(tr[tr[p].l].size + tr[p].cnt >= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

//找到严格小于 key 的数
int get_prev (int p, int key)
{
    if(!p) return -INF;
    if(tr[p].key >= key) return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

//找到严格大于 key 的数
int get_next (int p, int key)
{
    if(!p) return INF;
    if(tr[p].key <= key) return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}
```



<div style="page-break-after:always;"></div>

# AC自动机

### AC自动机简介

> AC自动机, 不是会自动AC的机器, 而是由 $Alfred.V.Aho$ 和 $Margaret.J.Corasick$ 发明的 $Aho - Corasick$ 自动机, 它能解决多模式串的匹配问题, 相当于多模式串的 $KMP$ .

<br>

---

### AC自动机的基本概念

> AC自动机 = $Trie$ + $KMP$ 
>
> 所以AC自动机的本质是 $Trie$ 树, 但加了 $KMP$ 的失配边, 使得AC自动机的效率和 $KMP$ 几乎一样快.

<br>

---

### AC自动机的存储方法

> AC自动机直接用 $Trie$ 树的存储方法, 还要再加一个 $KMP$ 的失配边数组.
>
> $Trie$ 树一般要开字符串总个数 × 字符串最大长度, AC自动机也是如此.

<br>

---

### 建立AC自动机

##### 思路1

> 读入所有的字符串, 把他们全部扔进 $Trie$ 中, 这里重点讲一下怎么建失配边.
>
> 首先拿出 $KMP$ 求 $fail$  指针的代码 (也可以把失配指针取成 $next$ )

```c++
void get_fail()
{
    for(int i = 2, j = 0; i <= m; i++)
    {
        //j = fail[i - 1]; 这里其实是由这一句的,但是j是循环变量,会直接传递,可以省略
        //但是在AC自动机不能省略,因为它是广搜,不能传递这种信息
        while(j && p[i] != p[j + 1]) j = fail[j];
        if(p[i] == p[j + 1]) j++;
        fail[i] = j;
    }
}
```

> 我们对应过来就是某一个字符串的第 $i$ 个字符, 就是AC自动机中的第 $i$ 层. ( $Trie$ 中字符串的第几个字母就在第几层)
>
> 我们不难发现, 每次 $KMP$ 中算 $fail$ 指针, 都是用前一个字母的 $fail$ 值计算出来的, 对应到AC自动机上就是每层的 $fail$ 值, 都是由上一层节点的 $fail$ 值算出来的. 所以要一层一层地搜, 我们很容易想到 $BFS$ .
>
> 因为算 $fail$ 指针是从第2层开始算的, 所以我们就把所有第1层的所有点, 扔到队列里, 这样扩展出来的所有点就是第2层及以下更下层.
>
> 这里解释一下, 如果 $fail[i] = j$ , 假设从根节点到 $j$ 的字符串的长度是 $w$ , 则从根节点到 $j$ 的字符串和从 $i$ 往上走的第 $w$ 个父亲到 $i$ 的字符串相等.
>
> 如图所示, 虚线是失配边.

![AC自动机](E:\个人博客\博客内容\算法竞赛\提高算法\高级数据结构\AC自动机.png)

##### 代码1

```c++
const int N = 10010, S = 55, M = 1000010;
//N是最大的字符串个数,S是字符串的最大长度,M是要匹配的字符串的最大长度

int tr[N * S][26], cnt[N * S], idx;	//Trie树数组
int fail[N * S], q[N * S];	//fail数组和用来求fail数组的手写队列
char str[M];

void insert (char s[N])	//Trie树的基本插入操作
{
    int p = 0;
    for(int i = 0; s[i]; i++)
    {
        int t = s[i] - 'a';	
        if(!tr[p][t]) tr[p][t] = ++idx;
        p = tr[p][t];
    }
    cnt[p] ++;
}

void get_fail()	//建立失配指针
{
    for(int i = 0; i < 26; i++)	//遍历所有根节点的儿子,即深度为1的节点
        if(tr[0][i]) q[++tt] = tr[0][i];
    
    while(hh <= tt)
    {
        int t = q[hh++];	//取出头节点
        for(int i = 0; i < 26; i++)	//遍历下一层
        {
            int p = tr[t][i];
            if(p)
            {
                int j = fail[t];	//对应着KMP中的j = ne[i - 1]
                while(j && !tr[j][i]) j = fail[j];	//字母不匹配,跳转到失配边
                //对应while(j && p[i] != p[j + 1]) j = fail[j]
                if(tr[j][i]) j = tr[j][i];
                //对应if(p[i] == p[j + 1]) j++
                fail[p] = j;
                q[++tt] = p;
            }
        }
    }
}
```

<br>

##### 思路2

> 现在有一种比较好些的AC自动机叫 $Trie$ 图, 它原本是 $Trie$ 树, 但加了一些边后就失去了 $DAG$ 性质, 就像一个图一样.

##### 代码2

```c++
void get_fail()
{
    int hh = 0, tt = -1;
    for(int i = 0; i < 26; i++)
        if(tr[0][i]) q[++tt] = tr[0][i];
    
    while(hh <= tt)
    {
        int t = q[hh++];
        for(int i = 0; i < 26; i++)
        {
            int p = tr[t][i];
            if(!p) tr[t][i] = tr[fail[t]][i];
            //Trie树变化的部分,可以当成并查集中的路径压缩来理解
            else
            {
                fail[p] = tr[fail[t]][i];	//直接指向父节点的fail指针的第i个儿子
                q[++tt] = p;
            }
        }
    }
}
```

<br>

---

### 长文本串匹配

##### 思路1

> 直接将 $KMP$ 思路对应过来的方法.

##### 代码1

```c++
void query (char s[M])
{
    for(int i = 0, j = 0; s[i]; i++)
    {
        int t = s[i] - 'a';
        while(j && !tr[j][t]) j = fail[j];
        if(tr[j][t]) j = tr[j][t];
        int p = j;
        while(p)	//这里主要是防止漏掉aba,ba这种有包含关系的情况
        {
            ans += cnt[p];
            cnt[p] = 0;
            p = fail[p];
        }
    }
}
```

<br>

##### 思路2

> Trie图的思路.

##### 代码2

```c++
void query (char s[M])
{
    for(int i = 0, j = 0; str[i]; i++)
    {
        int t = str[i] - 'a';
        int p = j = tr[j][t];
        while(p)	//这里主要是防止漏掉aba,ba这种有包含关系的情况
        {
            ans += cnt[p];
            cnt[p] = 0;
            p = fail[p];
        }
    }
}
```

<br>

---

### AC自动机算法模板

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 500010, M = 1000010;

int n;
int tr[N][26], cnt[N], idx;
int ne[N];
char str[M];

//建立Trie树
void insert ()
{
    int p = 0;
    for(int i = 0; str[i]; i++)
    {
        int t = str[i] - 'a';
        if(!tr[p][t]) tr[p][t] = ++idx;
        p = tr[p][t];
    }
    cnt[p] ++;
}

//求ne数组
void build ()
{
    queue<int> q;
    //将第一层的所有点加入队列
    for(int i = 0; i < 26; i++)
        if(tr[0][i])
            q.push(tr[0][i]);
    
    while(q.size())
    {
        //取出队头
        int t = q.front();
        q.pop();
        
        //枚举下一层
        for(int i = 0; i < 26; i++)
        {
            int p = tr[t][i];
            if(!p) tr[t][i] = tr[ne[t]][i];
            else 
            {
                //让当前点指向它的父节点所指向的儿子节点
                ne[p] = tr[ne[t]][i];
                q.push(p);
            }
        }
    }
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> str;
        insert();
    }
    
    build();
    
    cin >> str;
    
    int res = 0;
    for(int i = 0, j = 0; str[i]; i++)
    {
        j = tr[j][str[i] - 'a'];
        int p = j;
        while(p)
        {
            res += cnt[p];
            cnt[p] = 0;
            p = ne[p];
        }
    }
    
    cout << res << endl;
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 同余 - 中国剩余定理

若 $m_1, m_2, \dots , m_n$ 满足两两互质, $M = \prod\limits_{i = n}^{n} m_i$  , $M_i = \dfrac{M}{m_i}$ , $t_i$ 满足 $t_i \cdot M_i \equiv 1 (mod \  m_i)$ . 对于任意的 $n$ 个整数 $a_1, a_2, \dots , a_n$ 方程组:
$$
\left\{\begin{matrix} 
  x \equiv a_1 \ (mod \ m_1) \\  
  x \equiv a_2 \ (mod \ m_2) \\  
  \cdots \\
  x \equiv a_n \ (mod \ m_n) \\  
\end{matrix}\right.
$$
必有整数解, 其中一个解为 $x = \sum\limits_{i = 1}^{n} a_iM_it_i$ , 且在模 $M$ 的意义下有唯一解

```c++
int n;
int a[N], m[N];

void exgcd(LL a, LL b, LL &x, LL &y)
{
    if(!b) x = 1, y = 0;
    else
    {
        exgcd(b, a % b, y, x);
        y -= a / b * x;
    }
}

int main()
{
    cin >> n;
    LL M = 1;
    for(int i = 1; i <= n; i++)
    {
        cin >> m[i] >> a[i];
        M *= m[i];
    }
    
    LL x = 0;
    for(int i = 1; i <= n; i++)
    {
        LL Mi = M / m[i];
        LL ti, y;
        
        //这一步是求逆元, 根据逆元公式的衍生公式可以得到 ti * Mi + y * mi = 1
        exgcd(Mi, m[i], ti, y);
        x += a[i] * Mi * ti;
    }
    
    x = (x % M + M) % M;	//最小正整数解
}
```



<div style="page-break-after:always;"></div>

# 矩阵乘法

### [斐波那契前 n 项和](https://www.acwing.com/problem/content/1305/)

##### 题目概述

> 求 $Fibonacci$ 数列 $f_n$ 的前 $n$ 项和 $S_n \ mod \ m$ 
>
> 数据范围: $n \in [1, 2 \times 10^9]$ 

<br>

##### 解题思路

> 矩阵乘法 + 快速幂
>
> 设 $F_n  = [f_n \quad f_{n + 1} \quad S_n]$ ,  $F_n \times A = F_{n + 1}$ , $A = \begin{bmatrix}
> 0 & 1 & 0 \\
> 1 & 1 & 1 \\
> 0 & 0 & 1
> \end{bmatrix}$ 
>
> 则 $F_n = F_1 \times A^{n - 1}$ 

<br>

##### 算法模板

```c++
//1 * 3 矩阵与 3 * 3 矩阵相乘, 答案存储在 c[] 中
void mul (int c[], int a[], int b[][3])
{
    int temp[3] = {0};
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < 3; j++)
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % mod;
    memcpy(c, temp, sizeof temp);
}

//3 * 3 矩阵与 3 * 3 矩阵相乘, 答案存储在 c[][3] 中
void mul (int c[][3], int a[][3], int b[][3])
{
    int temp[3][3] = {0};
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < 3; j++)
            for(int k = 0; k < 3; k++)
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % mod;
    memcpy(c, temp, sizeof temp);
}

int main()
{
    cin >> n >> mod;
    
    int f[3] = {1, 1, 1};
    int a[3][3] = {
        {0, 1, 0}, 
        {1, 1, 1}, 
        {0, 0, 1}
    };
    
    n --;
    while(n)	//矩阵快速幂
    {
        if(n & 1) mul(f, f, a);
        mul(a, a, a);
        n >>= 1;
    }
    
    cout << f[2] << endl;
}
```

<br>

---

### [佳佳的斐波那契](https://www.acwing.com/problem/content/1306/)

##### 题目概述

> 设 $Fibonacci$ 数列第 $i$ 项为 $f_i$ 
>
> 求 $T(n) = (f_1 + 2f_2 + 3f_3 + \cdots + nf_n) \  mod \ m$ 

<br>

##### 解题思路

> **推导:**
>
> $T_n = f_1 + 2f_2 + 3f_3 + \cdots + nf_n$ , $S_n = f_1 + f_2 + f_3 + \cdots + f_n$ 
>
> 令 $P_n = n \times S_n - T_n = (n - 1)f_1 + (n - 2)f_2 + \cdots + f_{n - 1}$ 
>
> $P_{n + 1} = (n + 1) \times S_{n + 1} - T_{n + 1} = nf_1 + (n - 1)f_2 + \cdots + f_n$ 
>
> $P_{n + 1} - P_n = S_n$ 

> **总结:**
>
> $f_n = f_{n - 1} + f_{n - 2}$ 
>
> $S_n = S_{n - 1} + f_n$ 
>
> $P_n = P_{n - 1} + S_{n - 1}$ 
>
> $T_n = n \times S_n - P_n$ 

> **综上:**
>
> 设 $F_n = [f_n \quad f_{n + 1} \quad S_n \quad P_n]$ , $F_n \times A = F_{n + 1}$ , $A = \begin{bmatrix}
> 0 & 1 & 0 & 0 \\
> 1 & 1 & 1 & 0 \\
> 0 & 0 & 1 & 1 \\
> 0 & 0 & 0 & 1
> \end{bmatrix}$ 
>
> 则 $F_n = F_1 \times A^{n - 1}$ 

<br>

##### 算法模板

```c++
//1 * 4 矩阵与 4 * 4 矩阵相乘, 答案存储在 c[] 中
void mul (int c[], int a[], int b[][4])
{
    int temp[4] = {0};
    for(int i = 0; i < 4; i++)
        for(int j = 0; j < 4; j++)
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % mod;
    memcpy(c, temp, sizeof temp);
}

//4 * 4 矩阵与 4 * 4 矩阵相乘, 答案存储在 c[][4] 中
void mul (int c[][4], int a[][4], int b[][4])
{
    int temp[4][4] = {0};
    for(int i = 0; i < 4; i++)
        for(int j = 0; j < 4; j++)
            for(int k = 0; k < 4; k++)
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % mod;
    memcpy(c, temp, sizeof temp);
}

void solve()
{
    cin >> n >> mod;

    int f[4] = {1, 1, 1, 0};
    int a[4][4] = {
        {0, 1, 0, 0},
        {1, 1, 1, 0},
        {0, 0, 1, 1}, 
        {0, 0, 0, 1}
    };

    int k = n - 1;
    while(k)	//矩阵快速幂
    {
        if(k & 1) mul(f, f, a);
        mul(a, a, a);
        k >>= 1;
    }

    cout << (((LL)n * f[2] - f[3]) % mod + mod) % mod << endl;
}
```



<div style="page-break-after:always;"></div>

# 位运算 - 龟速乘

考虑将 $b$ 进行二进制拆分: $b = 2^{a_1} + 2^{a_2} + 2^{a_3} + \dots$ 

$a \times b \ mod \ p = (a \times 2^{a_1} \ mod \ p) + (a \times 2^{a_2} \ mod \ p) + \dots$ 

```c++
LL mul(LL a, LL b, LL p)
{
    LL res = 0;
    while(b)
    {
        if(b & 1) res = (res + a) % p;
        a = (a << 1) % p;
        b >>= 1;
    }
    return res;
}
```



<div style="page-break-after:always;"></div>

# 网络流的基本概念

### 最大流知识点梳理

```c++
1. 基本概念
    1.1 流网络，不考虑反向边
    1.2 可行流，不考虑反向边
        1.2.1 两个条件：容量限制、流量守恒
        1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量
        1.2.3 最大流是指最大可行流
    1.3 残留网络，考虑反向边，残留网络的可行流f' + 原图的可行流f = 原题的另一个可行流
        (1) |f' + f| = |f'| + |f|
        (2) |f'| 可能是负数
    1.4 增广路径
    1.5 割
        1.5.1 割的定义
        1.5.2 割的容量，不考虑反向边，“最小割”是指容量最小的割。
        1.5.3 割的流量，考虑反向边，f(S, T) <= c(S, T)
        1.5.4 对于任意可行流f，任意割[S, T]，|f| = f(S, T)
        1.5.5 对于任意可行流f，任意割[S, T]，|f| <= c(S, T)
        1.5.6 最大流最小割定理
            (1) 可以流f是最大流
            (2) 可行流f的残留网络中不存在增广路
            (3) 存在某个割[S, T]，|f| = c(S, T)
    1.6. 算法
        1.6.1 EK O(nm^2)
        1.6.2 Dinic O(n^2m)
    1.7 应用
        1.7.1 二分图
            (1) 二分图匹配
            (2) 二分图多重匹配
        1.7.2 上下界网络流
            (1) 无源汇上下界可行流
            (2) 有源汇上下界最大流
            (3) 有源汇上下界最小流
        1.7.3 多源汇最大流
```

<br>

---

### 网络流的基本概念

**流网络 **是由一些点和有向边组成的可以有环的图. 记作: $G = (V, E)$ $(V$ 表示点集, $E$ 表示边集$)$ . 流网络中有两个特殊的点, **源点** 和 **汇点** . 

**流网络** 里的每一条边都有一个属性, 记录该边的 容量 (该边每秒最多能流过的单位流量), 一般用 $c$ 表示. 

**源点** 拥有源源不断的流量可以流出去, **汇点** 可以容纳无穷多的流量. 

**注意:** 在讨论流网络时为例简化讨论, 默认不存在反向边. 因为就算存在反向边, 也可以在反向边中间加上一个点, 这样就从两个点之间的双向边变成了三个点之间的环. 并且如果有一条边不存在, 就定义它的容量为 $0$ . 

如下图, 为一个流网络, 有一个源点和一个汇点, 每条边上都有对应的容量. 

![1](E:\个人博客\博客内容\算法竞赛\进阶算法\图论\网络流的基本概念\1.png)

---

**可行流:** 对于任意满足以下两个条件的流, 被称为 **可行流** , 记作: $f$ 

1. 容量限制, $0 \le f(u, v) \le c(u, v)$ 
2. 流量守恒, $\forall x \in V / \{s, t \} , {\textstyle \sum_{(v, x) \in E}^{}} f(v, x) = {\textstyle \sum_{(x, v) \in E}^{}} f(x, v)$ 

**注意:** 到此为止都不需要考虑反向边

**可行流的流量值:** 我们将每秒从源点流出的流量 (每秒流入汇点的流量) 作为可行流的流量, 记作: $|f| = {\textstyle \sum_{(s, v) \in E}^{}} f(s, v) - {\textstyle \sum_{(v, s) \in E}^{}} f(v, s)$ 

如下图, 为上文中的流网络对应的一个可行流, 每条边的红字容量为该边在可行流中的容量.

![2](E:\个人博客\博客内容\算法竞赛\进阶算法\图论\网络流的基本概念\2.png)

**最大流:** 流网络中流量值最大的一个 **可行流** 被称为该流网络的 **最大流** , 因此又称为 **最大可行流** .

**残量网络:** 对于任意一个流网络 $G$ 中的任意一个可行流 $f$ , 都能对应一个残量网络, 记作 $G_f$ .

对于定义一个可行流的残量网络, $V_f = V$ , $E_f = E$ 和 $E$ 中的所有反向边. 当 $(u, b) \in E$ , $c'(u, v) = c(u, v) - f(u, v)$ . 当 $(v, u) \in E$ 时, $c'(u, v) = f(v, u)$ 

如下图, 为上文中的可行流对应的残量网络, 蓝边为正向边, 红边为反向边, 每条边上都有对应的容量.

![3](E:\个人博客\博客内容\算法竞赛\进阶算法\图论\网络流的基本概念\3.png)

---

**割:** 对于流网络 $G = (V, E)$ , 将点集 $V$ 分成两个子集 $S$ , $T$ (子集中的节点不需要连通) , 保证 $S\cup T = V$ , $S \cap T = \emptyset$ , 且 $s \in S$ , $t \in T$ , 像这样的一种将点集划分的结果, 就称为 **割** . 

**割的容量:** 所有从 $S$ 指向 $T$ 的边的容量之和, 即 $c(S, T) = {\textstyle \sum_{u \in S}^{}} {\textstyle \sum_{v \in T}^{}} c(u, v)$ 

**最小割:** 从流网络中割的所有划分方案中找出割的容量的最小值, 被称为该流网络的 **最小割** , 又叫 **最小割的容量** . $n$ 个节点的流网络中存在 $2^{n - 2}$ 种割的划分方案.

**割的流量:** 流网络中所有从 $S$ 流到 $T$ 的流量, 减去所有从 $T$ 流到 $S$ 的流量, 即 $f(S, T) = {\textstyle \sum_{u \in S}^{}} {\textstyle \sum_{v \in T}^{}} f(u, v) - {\textstyle \sum_{u \in T}^{}} {\textstyle \sum_{v \in S}^{}} f(u, v)$ 

**性质1:** 对于 $\forall [S, T] $ , $\forall f$ 都有 $f(S, T) \le c(S, T)$ 

**性质2:** 对于 $\forall [S, T]$ , $\forall f$ 都有 $f(S, T) = |f|$ 

**性质3:** $f(X, Y) = -f(Y, X)$ 

**性质4:** $f(Z, X \cup Y) = f(Z, X) + f(Z, Y)$ 

**性质5:** $f(X, X) = 0$ 

**推论:** 对于 $\forall [S, T]$ , $\forall f$ , 都有 $|f| \le c(S, T)$ , 所以就有 **最大流** $\le$ **最小割**

---

**最大流最小割定理**

对于任意一个流网络 $G = (V, E)$ 都满足:

$(1)$ 可行流 $f$ 是最大流 $\Longleftrightarrow$ $(2)$ 可行流 $f$ 的残量网络中不存在增广路径 $\Longleftrightarrow$ $(3)$ 存在某个割 $[S, T]$ , $|f| = c(S, T)$ 

---

**原网络 $G$ 的可行流 $f$ 和残量网络 $G_f$ 的可行流 $f'$ 的关系**

$f + f'$ 也是 $G$ 的一个可行流

$|f + f'| = |f| + |f'|$ 

**作用:**

通过以上特性, 任何一个在残量网络里面发现的流量 $> 0$ 的可行流, 都能用来增加原网络的可行流.

同时得到一个推论, 如果残量网络中存在任何一个流量 $> 0$ 的可行流, 那么原网络里的可行流就一定不是最大的可行流.

对于最大流来说反过来也是正确的, 即如果残量网络中不存在任何一个流量 $> 0$ 的可行流, 那么原网络里的可行流就一定是最大的可行流. 这个反命题可以通过 **最大流最小割定理** 得出.

---

**增广路径:** 在残量网络中从源点出发, 沿着容量 $> 0$ 的边, 存在一条路径能走到汇点, 这条路径被称为 **增广路径** .

**注意:** 增广路径一般指没有环的简单路径.

---

**费用:** 对于任意一个可行流 $f$ , 每条边 $(u, v)$ 都有流量 $f(u, v)$ 和费用 $w(u, v)$ , 该可行流的费用为 $\sum f(u, v) \cdot w(u, v)$ 

**最大费用流:** 所有最大可行流中费用最大的流称为最大费用最大流

**最小费用流:** 所有最大可行流中费用最小的流称为最小费用最大流

**注意:** 一张图 $G$ 有最大流, 那么就一定有最小费用最大流, 但是存在一些特殊的图, 图中存在一个从源点无法到达的闭环, 闭环中的费用是负的, 这时最小费用流可能比求出来的更小, 因此求费用流的做法存在局限性, 并不一定能求出最小费用最大流.

**如何求最小费用最大流:**

最小费用最大流是基于 EK 算法来求的, 只需要把 EK 算法中找增广路径的 bfs 算法换成找最短路的 spfa 算法就可以求最小费用最大流了.

**注意:** 由于 spfa 算法遇到负权回路会进入死循环, 所有常规的求最小费用最大流的算法并不能处理有负权回路的网络. 如果网络中存在负权回路, 就需要用消圈法来做.



<div style="page-break-after:always;"></div>

# 最大流之算法模板

### EK求最大流 $O(nm^2)$ 

##### 算法步骤

用 `while` 循环不断判断残量网络中是否存在增广路径

对于循环中:

1. 找到增广路径
2. 更新残量网络
3. 累加最大流量

循环结束, 得到最大流

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;	//邻接表, f[] 存储这条边的容量
int q[N], d[N], pre[N];
//q[] 表示队列
//d[i] 表示从 S 能传输到 i 的最大流量
//pre[i] 表示 i 的前驱边
//st[i] 表示 i 是否被遍历过
bool st[N];

//维护的是残量网络
void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;	//正向边
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;	//反向边
}

bool bfs()	//判断是否存在增广路径
{
    int hh = 0, tt = 0;
    memset(st, false, sizeof st);
    q[0] = S, st[S] = true, d[S] = INF;
    while(hh <= tt)
    {
        int t = q[hh ++ ];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(!st[ver] && f[i])
            {
                st[ver] = true;
                d[ver] = min(d[t], f[i]);
                pre[ver] = i;
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int EK()
{
    int r = 0;
    while(bfs())
    {
        r += d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
            f[pre[i]] -= d[T], f[pre[i] ^ 1] += d[T];
    }
    return r;
}

int main()
{
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    //Edmond-Karp 算法
    cout << EK() << endl;
    return 0;
}
```

<br>

---

### Dinic / ISAP求最大流 $O(n^2m)$ 

##### 算法步骤

Dinic 算法其实是 EK 算法的一个暴力的优化, EK 算法每次只能搜索一条增广路径, Dinic 算法每次都用爆搜的形式尽可能多的搜索增广路径.

而图中可能存在环, 为了保证爆搜的过程中不会造成死循环, 这里可以使用分层图, 这样每次都是一层一层往下搜索, 就不会出现死循环.

1. bfs 建立分层图
2. dfs 找出所有能增广的路径
3. 累加最大流量

**注意:** Dinic 算法对于优化非常敏感, 如果优化的不好就可能直接 TLE

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;	//邻接表维护残量网络
int q[N], d[N], cur[N];
//d[] 记录每个节点到起点的距离, 分层图
//cur[] 当前弧: cur[i] 记录 h[i] 指向的链表中指针的位置, 即节点 i 当前枚举到的边

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()	//建立分层图, 并判断是否存在增广路径
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++ ];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

//搜索从 u 节点往终点传输的最大流量, flow 表示当前传输到 u 节点的流量
int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        //当前弧优化:枚举到第i条边,说明h[u]中在第i条边前面的边都已经传输完流量,不需要再枚举
        
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    cout << dinic() << endl;
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 最大流之二分图匹配

### [飞行员配对方案问题](https://www.acwing.com/problem/content/2177/)[$^{24}$](https://www.luogu.com.cn/problem/P2756)  二分图最大匹配  最大流

##### 解题思路

> 每个外籍飞行员都能和若干个英国飞行员匹配, 要求找出一个匹配数量最多的配对方案
>
> 其实就是一个二分图匹配问题, 可以用最大流来解决
>
> 首先要建立一个流网络, 一个流网络有一个源点一个汇点, 加上 $m$ 个外籍飞行员和 $n - m$ 个英国飞行员
>
> 每一个外籍飞行员都只能出现在一个匹配里, 也就是每一个外籍飞行员只能用一次, 这就提示我们连一条从源点到每个外籍飞行员的容量是 $1$  的边, 同理每个英国飞行员也只能用一次, 就从每个英国飞行员向汇点连一条容量是 $1$ 的边
>
> 然后每个外籍飞行员都可以匹配指定的一些英国飞行员, 由于每个外籍飞行员和英国飞行员都只能用一次, 因此每条边都只能用一次, 所以可以从每个外籍飞行员向他匹配的所有英国飞行员连一条容量为 $1$ 的边
>
> 综上, 就建立了整个流网络, 并且可以根据任意一种匹配方案构造出一个流, 对于这样一个流, 每个节点如果被选中, 那么流入 $1$ , 流出也是 $1$ , 因此流量守恒, 并且每条边的容量限制都是 $1$ , 同样满足容量限制. 因此每个流都是一个可行流, 所以任意一种匹配方案都能对应一个可行流
>
> 由此得出原问题的任何一个可行解都能对应到流网络的任何一个整数可行流, 所以只要知道流网络的整数可行流的最大值, 就能知道原问题的最大可行解

<br>

##### 算法模板

```c++
int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> m >> n;
    S = 0, T = n + 1;
   	memset(h, -1, sizeof h);
    for(int i = 1; i <= m; i++) add(S, i, 1);
    for(int i = m + 1; i <= n; i++) add(i, T, 1);
    
    int a, b;
    while(cin >> a >> b, a != -1) add(a, b, 1);
    
    cout << dinic() << endl;
    for(int i = 0; i  < idx; i += 2)
        if(e[i] > m && e[i] <= n && !f[i])
            cout << e[i ^ 1] << ' ' << e[i] << endl;
}
```

<br>

---

### [圆桌问题](https://www.acwing.com/problem/content/2181/)[$^{24}$](https://www.luogu.com.cn/problem/P3254)  二分图多重匹配  最大流

##### 解题思路

> 这题也是一个二分图, 左部分节点是 $m$ 个单位, 右部分节点是 $n$ 个圆桌, 每个单位都能向所有圆桌连一条边, 代表每个单位的代表可以坐到任意一个圆桌内
>
> 但这里和普通的二分图有一个区别, 就是每个单位都可以派出若干个代表, 说明每个单位都使用不止一次, 对于匹配来说就是每个单位可以在多个匹配边中. 同理, 每个圆桌可以容纳多个单位代表, 说明每个圆桌也可以出现在多个匹配边中
>
> 这就是一个经典的二分图多重匹配问题, 可以用最大流来完成
>
> 首先按照最大流问题的解题思路, 需要建立一个流网络. 一个源点, 一个汇点, $m$ 个单位节点, $n$ 个圆桌节点
>
> 对于任意单位, 假设这个单位能派出 $i$ 个代表, 那么就可以从源点向该单位节点连一条容量为 $i$ 的边. 同理, 对于任意圆桌, 假设这个圆桌可以容纳 $j$ 个代表, 那么就可以从该圆桌节点向汇点连一条容量为 $j$ 的边
>
> 然后对于任意单位能向任意圆桌派出一个代表, 就可以从任意单位向任意圆桌连一条容量为 $1$ 的边
>
> 对于任意一个可行流, 可以发现, 每个单位和每个圆桌之间的边容量都是 $1$ , 因此每个单位最多向每个圆桌派一个代表, 保证了每个圆桌不会存在两个同一单位的代表. 并且每个单位的容量就是能容纳的人数, 因此每个圆桌的人数不会超过能容纳的人数. 所以任意一个可行流都能构造一个原问题的可行解
>
> 本题求的是任意一个能让所有代表都有地方坐的合法方案, 每个圆桌不一定坐满, 但是所有代表都必须有地方坐, 意味着所有从源点出发的边都一定要是满流量的. 因此要想知道是否存在一个方案使得所有代表都有地方坐, 就等价于看这个最大流中所有从源点出去的边是不是满流量, 等价于问这个最大流是不是等于总人数

<br>

##### 算法模板

```c++
int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

int add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> m >> n;
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    
    int tot = 0;
    for(int i = 1; i <= m; i++)
    {
        int c;
        cin >> c;
        add(S, i, c);
        tot += c;
    }
    for(int i = 1; i <= n; i++)
    {
        int c;
        cin >> c;
        add(i + m, T, c);
    }
    for(int i = 1; i <= m; i++)
        for(int j = 1; j <= n; j++)
            add(i, j + m, 1);
    
    if(dinic() != tot) cout << 0 << endl;
    else
    {
        cout << 1 << endl;
        for(int i = 1; i <= m; i++)
        {
            for(int j = h[i]; j != -1; j = ne[j])
                if(e[j] > m && e[j] <= m + n && !f[j])
                    cout << e[j] - m << ' ';
            cout << endl;
        }
    }
}
```



<div style="page-break-after:always;"></div>

# 最大流之上下界可行流

### 无源汇上下界可行流

> 给定一个包含 $n$ 个点 $m$ 条边的有向图, 每条边都有一个流量下界和流量上界
>
> 求一种可行方案使得在所有点满足流量平衡条件的前提下, 所有边满足流量限制

<br>

##### 解题思路

> 按照最大流问题的基本解题思路, 同样需要构建一个流网络
>
> 这个流网络中的可行流需要满足流量守恒和容量限制, 其中容量限制不再只有一个上界, 还加了一个下界限制
>
> 假设有一个流网络 $G$ , 存在任意一个可行流 $f$ , 不存在源点和汇点, 需要将它转化成一个新的流网络 $G'$ , 存在任意一个新的可行流 $f'$ , $G'$ 中存在源点和汇点, 且只有上界没有下界
>
> 对于流网络 $G$ 的可行流 $f$ 中的某一条边 $(u, v)$ , 容量上界记为 $C_u(u, v)$ , 容量下界记为 $C_l(u, v)$ , 当前流量记为 $f(u, v)$ . 当前满足 $C_l(u, v) \le f(u, v) \le C_u(u, v)$ 
>
> 现在需要将 $G$ 转化成 $G'$ , 使得可行流 $f'$ 中任意一条边 $(u, v)$ 满足 $0 \le f'(u, v) \le C'(u, v)$ 
>
> 这里可以想到一个直观的方法, 就是把原等式的每一项都减去 $C_l(u, v)$ , 那么原等式就变成 $0 \le f(u, v) - C_l(u, v) \le C_u(u, v) - C_l(u, v)$ . 这就是转化后的新流网络里可行流的容量限制, 且满足只有上界没有下界的要求
>
> 因此转化成新流网络的步骤就是, 设置新流网络中边的容量 $C'(u, v)$ 为 $C_u(u, v) - C_l(u, v)$ , 而 $f(u, v) - C_l(u, v)$ 就是原流网络中的可行流变到新流网络之后, 新可行流中边的流量. 根据转化, 它是必然满足容量限制的
>
> 虽然新可行流满足容量限制, 但是不一定满足流量守恒, 因为对于某一个点 $x$ , 对于进入点 $x$ 的每条边的流量, 都需要减去 $C_l(u, v)$ , 因此所有进入点 $x$ 的总流量相比原流网络会少 $ {\textstyle \sum_{v \in V}^{}} (v, x)$ , 记为 $C_{入}$ , 那么新的进入点 $x$ 的总流量就是原总流量 $-C_{入}$ . 对于从点 $x$ 出去的每条边的流量, 同样需要减去 $C_l(u, v)$ , 因此所有从点 $x$ 出去的总流量相比原网络会少 $ {\textstyle \sum_{v \in V}^{}} (x, v)$ , 记为 $C_{出}$ , 那么新的从点 $x$ 出去的总流量就是总流量 $-C_{出}$ 
>
> 对于原流网络, 点 $x$ 是一定满足进来的流量等于出去的流量的. 但是由于新流网络中每条边都需要减去一个固定的量, 假设进入点 $x$ 的边有 $a$ 条, 从点 $x$ 出去的边有 $b$ 条, 如果 $a > b$ , 那么就会导致 $C_{入} > C_{出}$ , 就不满足流量守恒了
>
> 怎么解决流量不守恒的问题. 可以发现现在进入的流量比出去的流量少 $C_{入} - C_{出}$ , 需要把少进入的流量补上, 只需要从源点向点 $x$ 连一条容量为 $C_{入} - C_{出}$ 的边. 反之如果 $C_{入} < C_{出}$ , 则需要从点 $x$ 向汇点连一条容量为 $C_{出} - C_{入}$ 的边
>
> 还有一点需要注意, 补完流量守恒之后, 必须要保证这些补进来的边都是满流, 才是流量守恒
>
> 综上, 得出原流网络中可行流的集合与新流网络中最大流的集合是一一对应的. 那么原流网络中是否存在可行流就等价于新流网络中是否存在最大流, 即判断从源点出去的边是否满流
>
> 如果新图中存在最大流, 说明原图中存在可行流, 只需要将新图的最大流通过逆操作转化回原图的可行流即可, 转化方式就是每条边的流量加上 $C_l(u, v)$ 

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], l[M], ne[M], idx;	//l[]存储正向边的流量下界
int q[N], d[N], cur[N], A[N];
//A[i] 表示点 i 所有入边的容量下界之和 - 点 i 所有出边的容量下界之和

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d);
        A[a] -= c, A[b] += c;
    }
    
    int tot = 0;
    for(int i = 1; i <= n; i++)
        if(A[i] > 0) add(S, i, 0, A[i]), tot += A[i];
    	else if(A[i] < 0) add(i, T, 0, -A[i]);
    
    if(dinic() != tot) cout << "NO" << endl;
    else
    {
        cout << "YES" << endl;
        for(int i = 0; i < m * 2; i += 2)
            cout << f[i ^ 1] + l[i] << endl;
        	//原图边的流量等于 正向边流量(残量网络反向边的容量) + 容量下界
    }
}
```

<br>

---

### 有源汇上下界最大流

> 给定一个包含 $n$ 个点 $m$ 条边的有向图, 每条边都有一个流量下界和流量下界
>
> 给定源点 $S$ 和汇点 $T$ , 求源点到汇点的最大流

<br>

##### 解题思路

> 本题求的是有源汇上下界最大流
>
> 前面已经知道了如何求无源汇上下界可行流, 如果要求有源汇上下界可行流, 方法是和无源汇上下界可行流一样的. 唯一的区别就在于此无源汇的图多了源点和汇点, 且源点和汇点不是流量守恒的
>
> 因此只需要将有源汇的图转化成一个所有点都是流量守恒的图, 可以发现, 从源点流出的流量应该等于流向汇点的流量, 因此这里有一个非常巧妙的方法, 就是从汇点向源点连一条容量是 $+ \infty$ 的边. 这样从源点流出去的流量就等于汇点从这条边流过来的流量, 这样就能让源点和汇点也满足流量守恒
>
> 通过以上方法, 用一条流量为 $+\infty$ 的边就能将一个有源汇的流网络变成一个无源汇的流网络, 然后就可以使用求无源汇上下界可行流的方法来求有源汇上下界可行流
>
> 但是本题不止要求可行流, 还要求原来的源点和汇点之间的最大流
>
> 首先, 对于原图 $G$ 存在任意的上下界可行流 $f_0$ , 然后在无源汇上下界可行流问题中, 能将原图 $G$ 转化成一个新图 $G'$ 存在任意的满流 $f'_0$ 
>
> 然后求一下新图对于 $f'_0$ 的残量网络 $G'_{f_0'}$ , 在这个残量网络中从 $S$ 到 $T$ 的一个满流就是 $f'_0$ , 其中有一部分就是从 $s$ 到 $t$ 流过去的, 而这一部分的流量其实就是之前加的 $t -> s$ 的虚边的流量, 记作 $f'_{0 \ s -> t}$ 
>
> 现在需要证明 $G'_{f'_0}$ 中所有的从 $s$ 到 $t$ 的可行流 $f'_{0 \ s -> t}$ 能和原图的所有可行流 $f_0$ 一一对应, 即从 $f'_{0 \ s -> t}$ 中任取一个可行流 $f'_{s -> t}$ 都能和 $f_0$ 中的任意一个可行流 $f$ 对应上
>
> 我们取 $G'_{f'_0}$ 中从 $s$ 到 $t$ 的任意一个可行流 $f'_{s -> t}$ , 可以发现由于 $G'_{f'_0}$ 是满流的状态, 所以所有从 $S$ 出去的边都是满流的, 同样所有流向 $T$ 的边也都是满流的, 这就保证 $f'_{s -> t}$ 一定和 $S$ , $T$ 没有关系, 只会经过除这两个点外的所有点
>
> 观察 $f'_{s -> t} + f'_0$ , 首先两个流相加一定是满足容量限制的, 只需要考虑流量守恒即可. 由于 $f'_{s -> t}$ 是一个从 $s$ 到 $t$ 的一个可行流, 所以中间除了 $s$ 和 $t$ 的所有点都是满足流量守恒的 (中间节点不包括 $S$ 和 $T$ ) , 再加上 $f'_0$ 这个流量守恒的流, 所以除了 $s$ 和 $t$ 的所有点都是满足流量守恒的. 但是从 $s$ 到 $t$ 的流量不一定守恒, 假设从 $s$ 到 $t$ 留了 $x$ 的流量, 可以从 $t$ 到 $s$ 连一条容量为 $x$ 的边, 使得 $s$ , $t$ 也是满足流量守恒的
>
> 综上所述可以发现, 从 $s$ 到 $t$ 的任意一个可行流加上 $f_0$ 仍然是 $G'$ 的一个满流, 仍然是原图 $G$ 的一个可行流. 因此对于 $G'_{f'_0}$ 的任意一个从 $s$ 到 $t$ 的可行流 $f'_{s -> t}$ 加上 $f'_0$ 都能对应到原图的一个可行流 $f$ 
>
> 接下来, 还需要证明, 对于原图的任意一个可行流 $f_0$ , 能否在 $G'_{f'_0}$ 中找到一个对应的 $f'_{s -> t}$ 
>
> 首先可行流 $f_0$ 可以变到 $G'$ 的一个满流 $f'$ , 然后观察 $f' - f'_0$ , 这里存在一个很重要的性质. 由于 $f$ 和 $f'_0$ 中从 $S$ 出发的边和流向 $T$ 的边都是满流, 因此 $f - f'_0$ 中从 $S$ 出发的边和流向 $T$ 的边的流量都会相减变成 $0$ . 所以减完之后所有的流量都一定是在中间这部分 (不包括 $S$ 和 $T$ ) . 原本图中就只有 $S$ 和 $T$ 不满足流量守恒, 减完之后不会经过 $S$ 和 $T$ 了, 经过的所有点就满足流量守恒了. $f'$ 是 $S$ 到 $T$ 的可行流, $f'_0$ 也是 $S$ 到 $T$ 的可行流, 相减之后就会发现 $f' - f'_0$ 不仅是 $S$ 到 $T$ 的可行流, 也是 $s$ 到 $t$ 的可行流
>
> 综上所述, 对于 $G$ 中任意一个可行流 $f$ , 都能在 $G'_{f'_0}$ 中找到一个对应的可行流 $f' - f'_0$ , 即 $f'_{s -> t}$ , 就能反推出 $f' = f'_{s -> t} + f'_0$ 
>
> $f'_0$ 中有一部分是从 $s$ 到 $t$ 的可行流, 即 $f'_{0 \ s -> t}$ , 再加上 $f'_{s -> t}$ 就是最终从 $s$ 到 $t$ 的流量, 已知原图的任意一个可行流 $f$ 都能对应到一个 $f'_{0 \ s -> t} + f'_{s -> t}$ , 要求 $f$ 的最大流, 就是求 $f'_{0 \ s -> t} + f'_{s -> t}$ 的最大流, 要分别使 $f'_{0 \ s -> t}$ 和 $f'_{s -> t}$ 各自的流量最大, 而 $f'_{0 \ s -> t}$ 是一个选定的满流, 流量是固定的, 因此要让 $f'_{s -> t}$ 尽可能大, 这里可以在残量网络里从 $s$ 到 $t$ 求一个最大流. 两个流量加在一起, 就能得到原可行流中的最大流
>
> 以上就是有源汇上下界最大流的解法, 有源汇上下界最小流也可以用同样的方法. 区别就是要让 $f'_{0 \ s -> t} + f'_{s -> t}$ 最小, 即 $f'_{s -> t}$ 尽可能小, 就是要让从 $s$ 到 $t$ 的流量尽可能少, 等价于从 $t$ 到 $s$ 的流量尽可能多, 因此从 $t$ 到 $s$ 求一个最大流, 就能得出从 $s$ 到 $t$ 的最小流量, 从而得出原可行流中的最小流
>
> 注意: 由于还需要求从 $s$ 到 $t$ 的最大流, 因此需要将之前加入的从 $t$ 到 $s$ 的容量为 $+ \infty$ 的虚边去掉, 否则可能会出现回流, 导致结果不是最大流
>
> 总结步骤就是, 先建出 $G'$ , 然后在 $G'$ 中求一遍满流, 在这个满流的残量网络中先将之前加入的 $t$ 到 $s$ 的虚边删掉, 再求一下从 $s$ 到 $t$  的最大流, 将求出的最大流的流量加上 $f'_{0 \ s -> t}$ 的流量就是最终的最大流, 而 $f'_{0 \ s -> t}$ 的流量就是之前加入到从 $t$ 到 $s$ 的虚边的流量

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    cin >> n >> m >> s >> t;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }
    
    int tot = 0;
    for(int i = 1; i <= n; i++)
        if(A[i] > 0) add(S, i, A[i]), tot += A[i];
    	else if(A[i] < 0) add(i, T, -A[i]);
    
    add(t, s, INF);
    if(dinic() < tot) puts("No Solution");
    else
    {	//原图最大流 = s 到 t 的流量 + s 到 t 的最大流
        
        int res = f[idx - 1];	//s 到 t 的流量 = 反向边的容量
        
        S = s, T = t;	//求从 s 到 t 的最大流
        f[idx - 1] = f[idx - 2] = 0;	//将之前加入的从 t 到 s 的虚边删掉
        cout << res + dinic() << endl;	
    }
}
```

<br>

---

### 有源汇上下界最小流

> 给定一个包含 $n$ 个点 $m$ 条边的有向图, 每条边都有一个流量下界和流量上界
>
> 给定源点 $S$ 和汇点 $T$ , 求源点到汇点的最小流

<br>

##### 解题思路

> 将 $f$ 和 $f'_{0 \ s -> t} + f'_{s -> t}$ 对应起来, 而 $f$ 的最小流就是 $f'_{0 \ s -> t} + f'_{s -> t}$ 的最小流, 由于 $f'_{0 \ s -> t}$ 的流量固定, 所以要让 $f'_{s -> t}$ 尽可能小, 对应的就是让从 $t$ 到 $s$ 的流量尽可能大, 因此求出从 $t$ 到 $s$ 的最大流, 就能求出从 $s$ 到 $t$ 的最小流. 由于 $f'_{s, t} = - f'_{t, s}$ , 所以 $\min f'_{s, t} = - \max f'_{t, s}$ , 最终得出原图的最小流为 $f'_{0 \ s -> t} - f'_{t -> s}$ 

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    cin >> n >> m >> s >> t;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }
    
    int tot = 0;
    for(int i = 1; i <= n; i++)
        if(A[i] > 0) add(S, i, A[i]), tot += A[i];
    	else if(A[i] < 0) add(i, T, -A[i]);
    
    add(t, s, INF);
    if(dinic() < tot) puts("No Solution");
    else
    {	/*原图最小流 = s 到 t 的流量 + s 到 t 的最小流
                   = s 到 t 的流量 - s 到 t 的最大流 */
        
        int res = f[idx - 1];	//s 到 t 的流量 = 反向边的容量
        
        S = t, T = s;	//求从 t 到 s 的最大流
        f[idx - 1] = f[idx - 2] = 0;	//将之前加入的从 t 到 s 的虚边删掉
        cout << res - dinic() << endl;	
    }
}
```



<div style="page-break-after:always;"></div>

# 最大流之多源汇最大流

> 创建一个虚拟源点和一个虚拟汇点, 虚拟源点向所有源点连一条容量为 $+\infty$ 的边, 所有汇点向虚拟汇点连一条容量为 $+\infty$ 的边. 从虚拟源点到虚拟汇点的最大流就是原图的最大流

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[dix] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int sc, tc;
    cin >> n >> m >> sc >> tc;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    
    while(sc --)
    {
        int c;
        cin >> c;
        add(S, c, INF);
    }
    while(tc --)
    {
        int c;
        cin >> c;
        add(c, T, INF);
    }
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    cout << dinic() << endl;
}
```



<div style="page-break-after:always;"></div>

# 最大流之关键边

> $n$ 个点 $m$ 条边的流网络, 给定源点 $S$ 和汇点 $T$ , 对于这样的边: 只给其扩大容量后整个流网络的最大流能够增大, 这样的边被称为 **关键边** 

<br>

##### 解题思路

> 先求一个最大可行流 $f$ , 可以发现, 如果某条边本身就满足 $f(u, v) < c(u, v)$ , 即没有满流, 那么这条边即使再增加容量也不会使整个流网络的最大流增大, 因此不是满流的边不可能是关键边, 只有满流的边才有可能是关键边
>
> 对于一条满流边 $(u, v)$ 是关键边的必要条件, 如果在给该边 $(u, v)$ 增加容量之前, 从 $S$ 到 $u$ 存在增广路径, 从 $v$ 到 $T$ 存在增广路径, 那么该边增加容量后, 就会存在一条从 $S$ 到 $T$ 的增广路径, 那么该边就是一条关键边
>
> 综上, 先求一遍最大流, 然后在残量网络中求从源点经过容量 $> 0$ 的边能到的点, 再求所有经过容量 $> 0$ 的边能到达汇点的点. 枚举所有的边, 判断一下这条边是不是满流, 同时判断这条边的两个点 $u$ , $v$ , $u$ 能不能从源点走到, 能不能从 $v$ 走到汇点. 如果都满足则说明这条边就是一条关键边

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
//vis_s[i] 记录残量网络中 S 经过容量 > 0 的边能否到达 i
//vis_t[i] 记录残量网络中 i 经过容量 > 0 的边能否到达 T
bool vis_s[N], vis_t[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

//t = 0 表示当前走的是正向边, t = 1 表示当前走的是反向边
void dfs (int u, bool st[], int t)
{
    st[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = i ^ t, ver = e[i];
        if(f[j] && !st[ver])
            dfs(ver, st, t);
    }
}

int main()
{
    cin >> n >> m;
    S = 0, T = n - 1;
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    dinic();
    dfs(S, vis_s, 0);
    dfs(T, vis_t, 1);
    
    int res = 0;
    for(int i = 0; i < idx; i += 2)
        if(!f[i] && vis_s[e[i ^ 1]] && vis_t[e[i]])
            res ++;
    cout << res << endl;
}
```



<div style="page-break-after:always;"></div>

# 最大流之最大流判定

### 秘密挤奶机

##### 解题思路

> 给定一个无向图, 需要从 $1$ 走到 $n$ 走 $T$ 次, 且每条边只能走一次, 求出经过的所有边中最大的边的最小值
>
> 凡是问最大值最小的问题一般都可以考虑二分, 所以需要看一下本题是否具有单调性或二段性
>
> 每条边的长度范围在 $[1, 10^6]$ 以内, 这就是二分的范围, 假设有 $T$ 次后最大边的最小值是 $res$ , 说明用长度在 $[1, res]$ 之内的边是能从 $1$ 走到 $n$ 走 $T$ 次的
>
> 综上所述, 可以使用二分来找出最大边的最小值, 具体思路就是每次从范围中取一个中间值 $mid$ , 如果用长度在 $[1, mid]$ 范围内的所有边无法走 $T$ 次, 说明 $mid$ 处于左半区间, 则 $res > mid$ , 需要二分右区间, 反之, 如果用长度在 $[1, mid]$ 范围内的所有边能够走 $T$ 次, 说明 $mid$ 处于右半区间, 则 $res \le mid$ , 需要二分左区间

<br>

##### 算法模板

```c++
int n, m, K, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INT)) r += flow;
    return r;
}

bool check (int mid)
{
    for(int i = 0; i < idx; i++)
        if(w[i] > mid) f[i] = 0;
    	else f[i] = 1;
}

int main()
{
    cin >> n >> m >> K;
    S = 1, T = n;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    int l = 1, r = 1e6;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    
    cout << l << endl;
}
```

<br>

---

### [星际转移问题](https://www.acwing.com/problem/content/2189/)[$^{24}$](https://www.luogu.com.cn/problem/P2754)  分层图转移  最大流

##### 解题思路

> 本题的主要题意就是, 在 $0$ 号点和 $n + 1$ 号点之间有 $n$ 个中间点, 有 $m$ 个太空船在所有点之间不断的循环走各自的路线, 每个公交车走到下一个站点都需要 $1$ 天的时间, 问最短需要几天时间能将 $k$ 个人从 $0$ 号点送到 $n + 1$ 号点
>
> 首先判断题目是否有解, 即判断 $0$ 号点和 $n + 1$ 号点是否连通, 可以用并查集来判断
>
> 如果有解, 那么应该如何求最少需要的天数 ?
>
> 需要判断多少天能将所有人运到  $n + 1$ 号点, 即判断用 $day$ 天能否将人运到 $n + 1$ 号点. 由于网络流中只有流量的概念, 并没有距离 (天数) 的概念, 因此需要引入分层图, 使得网络流中加入一个距离 (天数) 的概念
>
> 可以从第 $0$ 天开始将整个流网络分成 $day + 1$ 天. 由于最终一定要到达某个空间站, 所以可以将所有空间站作为点, 把所有太空船作为边来建图, 每个状态 $(i, j)$ 表示第 $j$ 天的第 $i$ 个空间站的状态 (共 $n + 2$ 个空间站)
>
> 对应的某些状态之间存在转移方式, 也就是空间站之间的边, 直接根据能走的合法的移动路线来建边即可
>
> 流网络还需要一个源点和一个汇点. 最开始所有人都在第 $0$ 天第 $0$ 个空间站, 所以从源点只能向 $(0, 0)$ 连一条容量为 $k$ 的边. 而汇点则是每一天的第 $n + 1$ 个空间站都能到达汇点, 从每一天的第 $n + 1$ 个空间站, 即 $(n + 1, x)$ 向汇点连一条容量为 $+ \infty$ 的边
>
> 对于合法的移动方式, 一种是通过坐太空船, 从一个站点到另一个站点, 那么就可以根据每辆公交车的路线来建图, 容量都是这个公交车的人数上限. 另一种方式就是每个人都可以待在空间站里不走, 因此每一天的每个空间站都可以向后一天的同一个空间站连一条容量为 $+ \infty$ 的边
>
> 关于如何枚举 $day$ , 首先是可以二分枚举的, 但是本题比较特殊, 可以发现站点的数量和 $day$ 是成正比的, $day$ 每增加 $1$ , 就会多一排站点. 并且随着 $day$ 的增加, 网络只会不断变多而不会减少. 并且最大流算法是可以在当前网络上继续增广, 因此本题中从小到大枚举 $day$ 其实是比二分更好的

<br>

##### 算法模板

```c++
int n, m, k, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int p[30];	//并查集

struct Ship
{
    int h, r, id[30];	//人数上限, 停靠站点数, 停靠的站点
}ships[30];	//存储所有太空船

int find (int x)
{
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int get (int i, int day)	//第 day 天第 i 个空间站这一节点的编号
{
    return day * (n + 2) + i;
}

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m >> k;
    S = N - 2, T = N - 1;
    memset(h, -1, sizeof h);
    for(int i = 0; i < 30; i++) p[i] = i;
    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        ships[i] = {a, b};
        for(int j = 0; j < b; j++)
        {
            int id;
            cin >> id;
            if(id == -1) id = n + 1;	//终点: 月球
            ships[i].id[j] = id;
            if(j)
            {
                int x = ships[i].id[j - 1];
                p[find(x)] = find(id);
            }
        }
    }
    
    //地球和月球不连通, 无解
    if(find(0) != find(n + 1)) puts("0");
    else 
    {
        add(S, get(0, 0), k);
        add(get(n + 1, 0), T, INF);
        
        int day = 1, res = 0;
        while(true)
        {
            //第 day 天的月球向汇点连一条边
            add(get(n + 1, day), T, INF);
            //每一个点的前一天向当前天连一条容量为 INF 的边
            for(int i = 0; i <= n + 1; i++)
                add(get(i, day - 1), get(i, day), INF);
            //枚举每辆太空船的线路
            for(int i = 0; i < m; i++)
            {
                int r = ships[i].r;
                int a = ships[i].id[(day - 1) % r], b = ships[i].id[day % r];
                add(get(a, day - 1), get(b, day), ships[i].h);
            }
            res += dinic();
            if(res >= k) break;
            day ++;
        }
        cout << day << endl;
    }
}
```



<div style="page-break-after:always;"></div>

# 最大流之拆点

### 餐饮问题

##### 解题思路

> 本题是要求每头牛, 每瓶饮料, 每个食物都只能用一次, 且每组配对包含一头牛和它喜好的饮料, 食物, 求最大匹配数
>
> 可以发现本题很像二分图匹配, 但本题有三个种类, 因此说是三分图匹配更合适
>
> 一种显然的建图方式就是用类似二分图匹配的方法来建图, 即从每个食物向喜欢它的牛连一条容量为 $1$ 的边, 从每头牛向它喜欢的饮料连一条容量为 $1$ 的边
>
> 以上方式建出来的图实际上并不能和原问题的可行解对应起来. 因为每头牛可能喜欢 $2$ 个及以上的食物和饮料, 那么这是按照流量的角度来看, 这两个食物可以各自经过这同一头牛再分别经过两个饮料到达汇点, 导致一头牛产生 $2$ 个及以上的匹配, 这与题意要求的每头牛只能用一次不符
>
> 因此可以发现这样建图的问题在于牛的使用次数不好控制, 但是食物和饮料的使用次数都被限制为 $1$ 次. 这里可以用一个非常经典的拆点技巧, 把每头牛拆成一个入点和一个出点, 原先连向它的边变成连向入点的边, 原先从它连出去的边变成从出点连出去的边. 然后从入点向出点连一条容量为 $1$ 的边, 保证再多的流量流向这头牛, 在经过中间这条容量为 $1$ 的边之后, 也只能走出来一组匹配, 通过一个通道完美的限制了牛的使用次数
>
> 总结网络流建图的重要技巧: 如果对边有限制, 直接对边的容量进行限制即可. 如果对点有限制, 可以将点拆成入点和出点, 然后在入点和出点之间的通道上进行容量限制

<br>

##### 算法模板

```c++
int n, F, D, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cut[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> F >> D;
    S = 0, T = n * 2 + F + D + 1;
    memset(h, -1, sizeof h);
    
    //牛的入点编号 1 ~ n, 牛的出点编号 n + 1 ~ n * 2
    //食物编号 n * 2 + 1 ~ n * 2 + F
    //饮料编号 n * 2 + F + 1 ~ n * 2 + F + D
    for(int i = 1; i <= F; i++) add(S, n * 2 + i, 1);
    for(int i = 1; i <= D; i++) add(n * 2 + F + i, T, 1);
    for(int i = 1; i <= n; i++)
    {
        add(i, n + i, 1);
        int a, b, t;
        cin >> a >> b;
        while(a --)
        {
            cin >> t;
            add(n * 2 + t, i, 1);
        }
        while(b --)
        {
            cin >> t;
            add(i + n, n * 2 + F + t, 1);
        }
    }
    
    cout << dinic() << endl;
}
```

<br>

---

### [最长递增子序列问题](https://www.acwing.com/problem/content/2182/)[$^{24}$](https://www.luogu.com.cn/problem/P2766)  限制性带权路径  最大流

##### 解题思路

> 本题有三问, 第一问是简单的线性 $dp$ , 求最长递增子序列长度
>
> 第二问是每个数只能用一次, 问最多能取出来多少个最长递增子序列 (长度为 $s$ ) , 这里可以用网络流来解决. 对于 $dp[i]$ 如果能从 $dp[j]$ 转移过来, 那么就从第 $j$ 个节点向第 $i$ 个节点连一条边, 这样就能得到一个有向图. 对于图中的每一条从 $dp$ 值为 $1$ 到 $dp$ 值为 $s$ 的完整路径, 都是一个合法的最长递增子序列. 由于题目要求每个点只能用一次, 对点有限制可以用拆点技巧, 将所有点都拆成入点和出点, 入点向出点连一条容量为 $1$ 的边, 就可以保证每个点只被用一次. 另外流网络中还有源点和汇点, 由于要找的所有长度为 $s$ 的路径, 意味着起点是所有 $dp$ 值是 $1$ 的点, 终点必须是 $dp$ 值是 $s$ 的点, 因此用源点向所有起点连一条边, 从所有终点向汇点连一条边
>
> 第三问是在第二问的基础上, 第 $1$ 个点和第 $n$ 个点可以被重复使用, 只需要放开这两个点的限制即可. 需要特判最长上升子序列长度为 $1$ 的情况

<br>

##### 算法模板

```c++
int n, S, T;
int a[N], dp[N];	//原序列, dp数组
int h[N], e[N], ne[N], f[N], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
	e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
	e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
	int hh = 0, tt = 0;
	memset(d, -1, sizeof d);
	q[0] = S, d[S] = 0, cur[S] = h[S];

	while(hh <= tt)
	{
		int t = q[hh ++];
		for(int i = h[t]; i != -1; i = ne[i])
		{
			int ver = e[i];
			if(d[ver] == -1 && f[i])
			{
				d[ver] = d[t] + 1;
				cur[ver] = h[ver];
				if(ver == T) return true;
				q[ ++ tt] = ver;
			}
		}
	}
	return false;
}

int find (int u, int limit)
{
	if(u == T) return limit;
	int flow = 0;
	for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
	{
		cur[u] = i;
		int ver = e[i];
		if(d[ver] == d[u] + 1 && f[i])
		{
			int t = find(ver, min(f[i], limit - flow));
			if(!t) d[ver] = -1;
			f[i] -= t, f[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

int dinic()
{
	int r = 0, flow;
	while(bfs()) while(flow = find(S, INF)) r += flow;
	return r;
}

int main()
{
	cin >> n; 
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	int s = 0;
	for(int i = 1; i <= n; i++)
	{
		dp[i] = 1;
		for(int j = 1; j < i; j++)
			if(a[j] <= a[i]) dp[i] = max(dp[i], dp[j] + 1);
		s = max(s, dp[i]);
	}
	cout << s << endl;

    //特判最长递增子序列长度为 1 的情况
	if(s == 1)
	{
		cout << n << endl;
		cout << n << endl;
		return 0;
	}

	memset(h, -1, sizeof h);
	S = 0, T = n * 2 + 1;
	for(int i = 1; i <= n; i++)
	{
		add(i, n + i, 1);
		if(dp[i] == 1) add(S, i, 1);
		if(dp[i] == s) add(n + i, T, 1);
		for(int j = 1; j < i; j++)
			if(dp[j] + 1 == dp[i] && a[j] <= a[i]) add(n + j, i, 1);
	}
	int res = dinic();
	cout << res << endl;

    //放开对第 1 个点和第 n 个点的限制
	for(int i = 0; i < idx; i += 2)
	{
		int a = e[i ^ 1], b = e[i];
		if(a == S && b == 1) f[i] = INF;
		if(a == 1 && b == n + 1) f[i] = INF;
		if(a == n + n && b == T) f[i] = INF;
		if(a == n && b == n + n) f[i] = INF;
	}
	res += dinic();	//增广流量累加
	cout << res << endl;
}
```



<div style="page-break-after:always;"></div>

# 最小割之算法模板

### Dinic 求最小割 $O(n^2m)$ 

##### 算法描述

对于 $n$ 个节点, $m$ 条边的流网络, 可以在 $O(n^2m)$ 的时间复杂度内求出该流网络的 **最小割**

Dinic 算法其实是求最大流的重要算法, 这里同样能用来求最小割, 原因是在任何一个流网络中 **最大流 = 最小割**

<br>

##### 算法步骤

Dinic 算法其实是 EK 算法的一个暴力的优化, EK 算法每次只能搜索一条增广路径, Dinic 算法每次都用爆搜的形式尽可能多的搜索增广路径.

而图中可能存在环, 为了保证爆搜的过程中不会造成死循环, 这里可以使用分层图, 这样每次都是一层一层往下搜索, 就不会出现死循环.

1. bfs 建立分层图
2. dfs 找出所有能增广的路径
3. 累加最大流量

**注意:** Dinic 算法对于优化非常敏感, 如果优化的不好就可能直接 TLE

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;	//邻接表维护残量网络
int q[N], d[N], cur[N];
//d[] 记录每个节点到起点的距离, 分层图
//cur[] 当前弧: cur[i] 记录 h[i] 指向的链表中指针的位置, 即节点 i 当前枚举到的边

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()	//建立分层图, 并判断是否存在增广路径
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while(hh <= tt)
    {
        int t = q[hh ++ ];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

//搜索从 u 节点往终点传输的最大流量, flow 表示当前传输到 u 节点的流量
int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        //当前弧优化:枚举到第i条边,说明h[u]中在第i条边前面的边都已经传输完流量,不需要再枚举
        
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    
    cout << dinic() << endl;
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 最小割之最大权闭合图

### 最大权闭合子图的相关概念

**闭合子图:** 给定一个有向图 $G(V, E)$ , 图中的某一点集, 这个点集满足内部的所有边不能从点集里面指向点集外面, 则将这个点集和点集里面的边统称为原图的 **闭合子图**

---

**最大权闭合子图:** 给定一个有向图 $G(V, E)$ , 每个点上都有一个权值, 图中存在若干个闭合子图, 若其中一个闭合子图的点集权值和最大, 则称这个闭合子图为 **最大权闭合子图**

---

**如何求最大权闭合子图:**

求最大权闭合子图是最小割问题的一个应用, 因此只需要证明原问题的任意一个闭合子图都能对应到流网络中任意一个割的集合. 这样求原问题的最值问题就能对应去求割的最值

首先需要将原问题的有向图变成一个流网络, 假设原问题的有向图是 $G = (V, E)$ , 转化成的流网络是 $G_N = (V_N, E_N)$ 

流网络需要一个源点一个汇点, 还需要表示出每个点的权值. 每个点的权值有正有负, 可以从源点向所有权值为正的点连一条边, 容量是点的权值, 从所有权值为负的点向汇点连一条边, 容量是点的权值的绝对值, 原图中的所有边都不变, 容量是 $+ \infty$ 

通过以上的方式, 构造出了一个流网络 $G_N = (V_N, E_N)$ , $V_N = V + \{s, t\}$ , $E_N = \{(s, u), w_u > 0\} \cup \{(u, t), w_u < 0\} \cup E$ 

然后需要证明对应关系, 我们设定一个特殊的割, 将所有割边和源点或汇点相连的割称为简单割, 显然, 简单割是所有割的一个子集

可以发现, 最小割一定是一个简单割, 因为最小割就是最大流, 而从源点出发的所有边都是有限容量, 所以最大流是有限值, 对应的最小割也是有限值, 因此最小割一定不包含中间那些容量是 $+ \infty$ 的边, 所以最小割一定是简单割

接下来要证明原问题的闭合子图能和所有简单割一一对应

对于原图的任何一个闭合子图的点集 $V'$ , 构造一个割集 $[S, T]$ , 由于构造的割集只需要满足源点在 $S$ , 汇点在 $T$ 即可, 因此规定 $S = V' + \{s\}$ , $T = V_N - S$ . 那么构造出的这个割集一定是一个简单割. 可以发现 $S$ 中除了源点, 其他所有点构成一个闭合子图, 因此这些点都不可能走到汇点, 且这些点和其他子图外的点之间都不存在边, 所以就能保证这样割集中的割边只可能是和源点或汇点相连的割边, 因此这就是一个简单割

反过来, 对于任意一个简单割 $[S, T]$ , 构造一个闭合子图 $G'$ , 这个闭合子图的点集 $V' = S - \{s\}$ , 由于简单割保证了两个集合之间不存在相连的边, 所以从 $S$ 的任何一个点出发, 都必然会走回到 $S$ , 不可能走到 $T$ , 因此 $V'$ 就是一个闭合点集, $G'$ 就是一个闭合子图

综上所述, 证明了原问题的任何一个闭合点集和流网络中的任何一个简单割都是一一对应的

由于求的是闭合子图的最大权值, 所以还需要确定它们之间的数量关系. 对于流网络的任何一个简单割 $[S, T]$ , 对应的闭合子图的点集是 $V' = S - \{s\}$ , 规定 $V'' = V - V'$ , 可以发现, 这个割的左集合中是 $V'$ , $\{s\}$ , 右集合中是 $V''$ , $\{t\}$ , 所有割边只可能是左边两部分和右边两部分之间的边, 而 $V'$ 和 $V''$ 之间不存在边, $\{s\}$ 和 $\{t\}$ 之间也不存在边, 因此这个简单割的容量就是 $C[S, T] = C[V', \{t\}] + C[\{s\}, V''] = \sum_{v \in V''} w_v + \sum_{v \in V'} -w_v$ 

若设定 $V^+$ 是 $V$ 中所有权值为正的点, $V^-$ 是 $V$ 中所有权值为负的点. 因此进一步具体 $C[S, T] = \sum_{v \in V''^+} w_v + \sum_{v \in V'^-} (-w_v)$ , 而闭合子图的权值和 $w(V') = \sum_{v \in V'^+} w_v + \sum_{v \in V'^-} w_v = \sum_{v \in V'^+} w_v - \sum_{v \in V'^-} (-w_v)$ , 可以发现 $C[S, T] + w(V') = w(V^+)$ , 所以要求的最大权闭合子图 $w(V') = w(V^+) - C[S, T]$ , $w(V^+)$ 是固定值, 所以要让 $C[S, T]$ 最小, 即最小简单割的容量, 而流网络的最小割就是简单割, 因此等价于流网络的最小割, 再用所有正权值的点的权值和减去最小割的容量就是最大闭合子图的权值和

<br>

---

### 最大获利问题

##### 解题思路

> 有若干个中转站, 建立每个中转站都需要花费对应的成本. 还有若干个用户群, 每个用户群连接两个中转站, 要想满足某个用户群的需求, 就必须建立对应的两个中转站, 因此可以从用户群向对应的两个中转站分别连一条有向边, 表示如果想满足这个用户群的需求就必须要将两个中转站建立起来, 而满足每个用户群的需求都能获得对应的收益
>
> 本题要求最大获利, 获利就是总收益减去总成本. 可以发现成本都是要减去的, 收益都是要增加的. 因此如果将所有中转站和用户群看作节点, 那么所有中转站的权值就是负的, 所有用户群的权值就是正的, 选取任何一个用户群, 都要算上对应的两个中转站, 即从用户群出发能到的所有点都需要选上, 因此在选点的时候其实就是在选闭合点集, 而目标是使选的所有点的权值和最大, 其实就是求整张图的最大权闭合子图
>
> 因此本题只需要按照求最大权闭合子图的步骤去求即可. 首先是建图, 从源点向所有正权点连边, 容量就是权值; 从所有负权点向汇点连边, 容量就是权值的绝对值; 所有用户群向需要建造的中转站连边, 容量是 $+ \infty$ . 然后求一下最小割, 最大权值和就是正权点的权值和减去最小割的容量

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m;
    S = 0, T = n + m + 1;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++)
    {
        int p;
        cin >> p;
        add(m + i, T, p);	//所有负权点向汇点连一条边, 容量为权值的绝对值
    }
    
    int tot = 0;	//统计正权点的权值和
    for(int i = 1; i <= m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(S, i, c);	//源点向所有正权点连一条边, 容量为权值
        add(i, m + a, INF);	//原图中的边保持不变, 容量为 INF
        add(i, m + b, INF);
        tot += c;
    }
    
    //最大权值和 = 正权点的权值和 - 最小割
    cout << tot - dinic() << endl;
}
```



<div style="page-break-after:always;"></div>

# 最小割之最大密度子图

### 最大密度子图的相关概念

**密度子图:** 给定一个无向图 $G(V, E)$ , 图中的某一个点集 $V'$ 和某一个边集 $E'$ , 这个边集中的任意一条边 $(a, b)$ 都满足 $a$ 和 $b$ 都在 $V'$ 中, 则将这个点集和边集统称为原图的 密度子图****

---

**最大密度子图:** 给定一个无向图 $G(V, E)$ , 图中存在若干个密度子图, 若其中一个密度子图的密度最大 (密度为边的数量除以点的数量, 即 $\dfrac{|E'|}{|V'|}$ ) , 则这个密度子图称为 **最大密度子图**

---

**如何求最大密度子图:**

设原图为 $G = (V, E)$ , 密度子图为 $G' = (V', E')$ 

可以发现 $\dfrac{|E'|}{|V'|}$ 是一个分数, 求这个分数的最大值可以用 01 分数规划

假设当前密度子图的密度是 $g$ , 即 $\dfrac{|E'|}{|V'|} = g$ , 可以进一步得到一个新的关系, $|E'| - g \cdot |V'| = 0$ 

若现在 $\dfrac{|E'|}{|V'|}$ 是最大密度子图的密度, $g$ 是二分的中间值, 如果 $|E'| - g \cdot |V'| > 0$ , 则 $\dfrac{|E'|}{|V'|} > g$ , 说明最大密度子图的密度为 $g$ 大, 因此此时需要二分右区间. 如果 $|E'| - g \cdot |V'| < 0$ , 则 $\dfrac{|E'|}{|V'|} < g$ , 说明最大密度子图的密度比 $g$ 小, 因此此时需要二分左区间. 最终得到一个固定值, 就是 $\dfrac{|E'|}{|V'|}$ 的真实值

现在的问题是需要在每次二分的过程中, 求出当前 $|E'| - g \cdot |V'|$ 的具体数值, 才能通过判断它和 $0$ 的关系来进一步二分

那么如何求出最大密度子图中 $|E'| - g \cdot |V'|$ 的具体数值呢, 首先密度子图有一个特性, 若选一条边 $(a, b)$ , 就必须选 $a$ 和 $b$ 这两个点, 因此可以把边也看成点, 从该边向对应的两个点连一条有向边, 表示如果选这条边就必须选对应的两个点, 这样就将密度子图的限制转化成了闭合子图的限制了

那么接下来问题就变成了求一个最大化 $|E'| - g \cdot |V'|$ 的闭合点集. 这时设所有边转化成的点的权值是 $1$ , 所有点的权值是 $-g$ , 那么这就可以用最大权闭合子图的做法直接来求. 但是用这样的思路来做的话图中的边数有 $3E + V$ , 边数非常多, 因此可以再考虑进行一些优化

刚才分析出来的做法其实是一种一般化的做法, 没有运用一些性质, 所以效率比较低. 这里有一个性质, 如果已经确定了当前的点集, 那么这个点集的诱导子图一定是最优的 (点集内部的所有边全选得出的子图称为诱导子图) 

要想求最大化的 $|E'| - g \cdot |V'|$ , 等价于求最小化的 $g \cdot |V'| - |E'|$ , 网络流中求最小值可以想到和最小割产生联系. 如果直接求密度子图里面边的数量不是很好求, 要尽量把它和割联系起来, 所以可以用一个补集的思想, 可以用密度子图的点集相关的所有边的数量减去密度子图和其他点的割边的数量,  就是密度子图中边的数量. 由于每条边都连向两个点, 可以将每条边一分为二, 分别连向两个点, 即每条边都让对应的两个点度数 $+1$ , 这样点集相关的所有边的数量就是点集的总度数, 再减去割边的数量就是密度子图中边的数量, 但是每条边已经一分为二, 所以求出来的数量还需要除以 $2$ , 因此最终密度子图中边的数量就是 $\dfrac{\sum_{v \in V'} d_v - C[V', V - V']}{2}$ 

则最小化 $|E'| - g \cdot |V'| = \sum_{v \in V'} g - \dfrac{\sum_{v \in V'} d_v - C[V', V - V']}{2} $ $= \sum_{v \in V'} g - (\dfrac{\sum_{v \in V'}d_v}{2} - \dfrac{C[V', V - V']}{2}) = \sum_{v \in V'} (g - \dfrac{d_v}{2}) + \dfrac{C[V', V - V']}{2}$ 

通过以上的转化, 将原本求的最小化 $|E'| - g \cdot |V'|$ 和割对应起来了, 但是这里还不太一样, 除了割以外还多了一项, 我们希望再进一步简化成只剩割, 那么最终只需要求最小割即可

所以还需要进一步推公式 $\sum_{v \in V'} (g - \dfrac{d_v}{2}) + \dfrac{C[V', V - V']}{2} = \dfrac{1}{2} \cdot (\sum_{v \in V'} (2g - d_v) + C[V', V - V'])$ , 然后尝试将 $\sum_{v \in V'} (2g - d_v)$ 融入到 $C[V', V - V']$ 中, 只需要将所有点向汇点连一条容量是 $2g - d_v$ 的边即可, 这里 $2g - d_v$ 可能是负数, 可以加上一个大数 $U$ , 对应的源点向所有点连一条容量是 $U$ 的边, 而原图中所有点之间的边容量是 $1$ 

为什么加上一个大数 $U$ 还是不影响最终答案呢, 这里可以看一下原问题和割的关系, 假设 $V' = S - \{s\}$ , 割的容量 $C[S, T]$ 就是 $V'$ 和 $s$ 到 $V - V'$ 和 $t$ 的边的容量和, 而 $s$ 到 $t$ 的边不存在, 还剩三种边, 所以 $C[S, T] = \sum_{v \in V - V'} U + \sum_{u \in V'} (U - 2g - d_u) + \sum_{u \in V'}\sum_{v \in V - V'} C_{u, v} = \sum_{v \in V - V'} U + \sum_{u \in V'} (U + 2g - d_u + \sum_{v \in V - V'} C_{u, v}) $ $= \sum_{v \in V - V'} U + \sum_{u \in V'} (U + 2g - (d_u - \sum_{v \in V - V'} C_{u, v})) = \sum_{v \in V - V'} U + \sum_{u \in V'} (U + 2g - \sum_{v \in V'} C_{u, v}) $ $= \sum_{v \in V} U + \sum_{u \in V'} 2g - \sum_{u \in V'}\sum_{v \in V'} C{u, v} = U \cdot n + 2g \cdot |V'| - 2 \cdot |E'|$ 

我们要让 $|E'| - g \cdot |V'| $ 最大, 就是让 $g \cdot |V'| - |E'|$ 最小, 就是让 $U \cdot n + 2g \cdot |V'| - 2 \cdot |E'|$ 最小, $U \cdot n$ 是个定值, 所以就是要让 $2g \cdot |V'| - 2 \cdot |E'|$ 最小, 等价于让 $C[S, T]$ 最小, 所以割和密度子图是存在单调关系的, 且是一一对应的, 所以求一下最小割即可, 答案就是 $\dfrac{U \cdot n - C[S, T]}{2}$ 

---

**扩展**

**在图中加入边权:** 在原图中每条边的容量其实是 $1$ , 这里其实就是将每条边的容量设置成权值, 因此必须要求边权 $\ge 0$ , 这样一来上述的证明需要稍微变动, $|E'|$ 的定义要改为所有选择的边的权值和. 那么在算密度子图内部的边的权值之和时就是将每条边的权值一分为二, 每条边的权值在对应的两个点上都算一次, 那么 $d_v$ 就不再记录每个点的度数, 改成所有从当前点出发的边的权值和. 将两个定义一改, 就可以完全套用上述的证明, 答案依然是 $\dfrac{U \cdot n - C[S, T]}{2}$ 

**在图中同时加入边权和点权:** 假定每个点的权值是 $p_i$ , 那么最终要求的目标值应该是 $\dfrac{|E'| + |V'|}{|V'|}$ , 然后再去寻找它和 $g$ 的关系, 处理应该是要最大化 $|E'| + |V'| - g \cdot |V'|$ , 等价于最小化 $g \cdot |V'| - |V'| - |E'|$ , 这个式子具体表示出来就是 $\dfrac{1}{2} \cdot (\sum_{v \in V'} (2g - 2p_v - d_v) + C[V', V - V'])$ , 相比原表达式这里等于是多减去一个点权, 那么所有点向汇点连的边的容量就改成 $2g - 2p_v - d_v + U$ , 最后讨论数值关系时也变成 $C[S, T] = U \cdot n + 2g \cdot |V'| - 2 \cdot |E'| - 2 \cdot |V'|$ , 最终答案还是 $\dfrac{U \cdot n - C[S, T]}{2}$ , 可以发现最终结果的式子是不变的, 区别在于过程中的一些变动

<br>

---

### 生活的艰辛问题

##### 解题思路

> 本题就是密度子图的一个应用, 给定 $n$ 个点, $m$ 条边, 要求最大密度子图. 本题需要输出方案, 由于已经证明过密度子图和割一一对应, 且 $V' = S - \{s\}$ , 所以只要找出任意一个割, 再把源点删掉, 剩下的点集就是一个合法方案. 怎么找出一个割呢, 从源点出发沿着容量 $> 0$ 的边走, 凡是走的到的点都属于 $S$ , 反之属于 $T$ 

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], ne[M], idx;
double f[M];

int q[N], d[N], cur[N];
int dg[N];	//存储每个点的度数

struct Edge
{
    int a, b;
}edges[M];

int ans;	//记录选中的总人数
bool st[N];		//记录每个点是否被遍历过

void add (int a, int b, double c1, double c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++;
}

void build (double g)
{
    memset(h, -1, sizeof h);
    idx = 0;
    
    for(int i = 0; i < m; i++)
        add(edges[i].a, edges[i].b, 1, 1);
    for(int i = 1; i <= n; i++)
    {
        add(S, i, m, 0);	//从源点向每个点连一条容量是 U 的边
        add(i, T, m + g * 2 - dg[i], 0);	
        //从每个点向汇点连一条容量是 U + 2g - deg[i] 的边
    }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find (int u, double limit)
{
    if(u == T) return limit;
    double flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if(t <= 0) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic (double g)
{	
    build(g);	//根据每次二分的值重新建图
    
    double r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

void dfs (int u)	//深搜找出最小割
{
    st[u] = true;
    if(u != S) ans ++;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int ver = e[i];
        if(!st[ver] && f[i] > 0)
            dfs(ver);
    }
}

int main()
{
    cin >> n >> m;
    S = 0, T = n + 1;
    
    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        dg[a] ++, dg[b] ++;
        edges[i] = {a, b};
    }
    
    //本题设置 U 为 m, 保证 2g - deg[i] + U > 0
    double l = 0, r = m;
    while(r - l > eps)
    {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if(m * n - t > 0) l = mid;	// (U * n - C[S, T]) / 2 > 0, 二分右区间
        else r = mid;	// (U * n - C[S, T]) / 2 < 0, 二分左区间
    }
    
    dinic(l);
    dfs(S);
    
    if(!ans) cout << 1 << endl << 1 << endl;
    else
    {
        cout << ans << endl;
        for(int i = 1; i <= n; i++)
            if(!st[i]) cout << i << endl;
    }
}
```

<br>

---

### 最大获利问题

##### 解题思路

> 本题除了最大权闭合子图的一般性做法, 还能用最大密度子图进行优化
>
> 之前将每个用户群看作一个点连向两个中转站, 表示满足每个用户群都需要建造对应的两个中转站, 这样使得本题和最大权闭合子图产生联系
>
> 现在要将本题和最大密度子图产生联系, 由于密度子图的限制要求要想选某条边就必须要选该边对应的两个点, 因此可以将用户群看作边, 要想选某条边就必须选上这条边的两个点
>
> 这就变成了一个密度子图的问题, 然后本题是带点权和边权的, 点权是负的, 边权是正的, 这里需要最大化一个 $|E'| + |V'|$ , 而在证明时求的是最大化 $|E'| + |V'| - g \cdot |V'|$ , 只需要让 $g = 0$ , 就能求出本题的答案. 所以用证明时的建图方式跑一遍最小割, 答案就是 $\dfrac{U \cdot n - C[S, T]}{2}$ , 由于本题的 $g$ 是固定的, 是一种特殊情况, 具体的说可以算是一个局部最大密度子图, 因此少一步二分, 实现起来相对简单一点

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int dg[N];	//记录从每个点出发的边的权值之和
int p[N];	//记录每个点的权值

void add (int a, int b, int c1, int c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    
    for(int i = 1; i <= n; i++)
        cin >> p[i], p[i] *= -1;	//点权是要减去的, 是负的
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c, c);
        dg[a] += c, dg[b] += c;
    }
    
    int U = 0;
    //保证 U + 2g - 2p[i] - dg[i] >= 0, 本题 g = 0, U - 2p[i] - dg[i] >= 0
    for(int i = 1; i <= n; i++)
        U = max(U, 2 * p[i] + dg[i]);
    
    for(int i = 1; i <= n; i++)
    {
        add(S, i, U, 0);	//从源点向每个点连一条容量是 U 的边
        add(i, T, U - 2 * p[i] - dg[i], 0);		//从每个点向汇点连一条容量是 U - 2g - 2p[i] - dg[i] 的边
    }
    
    cout << (U * n - dinic()) / 2 << endl;
}
```



<div style="page-break-after:always;"></div>

# 最小割之最小点权覆盖集

### 最小权点覆盖集的相关概念

**点覆盖集:** 给定一个有 / 无向图 $G(V, E)$ , 选择图中的某一个点集, 使得每条边都至少有一个端点在被选的点集中, 则将这样的点集称为原图的 **点覆盖集**

---

**最小权点覆盖集:** 给定一个有 / 无向图 $G(V, E)$ , 每个点上有一个非负的权值, 选出的权值和最小的点覆盖集被称为 **最小权点覆盖集**

---

**如何求最小权点覆盖集:**

最小权点覆盖集问题在一般的图中是一个 NP 完全问题 (NPC 问题) , 目前证明出来只能用爆搜来做, 时间复杂度一定是指数级别

但是二分图中存在一种非常高效的做法

首先对于二分图中, 如果所有点的权值都是 $1$ , 那么就可以用匈牙利算法直接求, 且 **最大匹配数 = 最小点覆盖数 = n - 最大独立集数**

如果所有点的权值不一定是 $1$ , 那么就不能用匈牙利算法来求, 只能用网络流去解决这类问题

对于一个二分图, 应该有两排点, 另有一个源点一个汇点, 两排节点之间存在若干条边, 每条边都至少要覆盖一个点, 因此可以将这些边的容量设置为 $+ \infty$ , 保证割边不出现在中间. 对于每条边来说, 这两个点至少要有一个被选, 类比到流网络中相当于是这两个点和源点、汇点之间的边是割边, 而最小权点覆盖集和最小割都是求最小值, 因此可以往这个方面去考虑

接下来需要证明能否用最小割模型解决二分图的最小权点覆盖集问题, 每个点都有点权, 左排节点的权值可以放到从源点到这些点的边上, 而右排节点的权值可以放到从这些点到汇点的边上. 由于点权是非负的, 所以容量是合法的. 中间所有边的容量同以上思路设置为 $+\infty$ 

然后看一下建立的流网络和原问题的点覆盖的集合之间是否存在关系, 首先定义一个概念, 将所有只包含和源点、汇点相连的边作为割边的割称为简单割. 显然, 简单割是所有割的一个子集

可以发现, 最小割一定是一个简单割, 因为最小割就是最大流, 而从源点出发的所有边都是有限容量的, 所以最大流是有限值, 最大流等同于最小割也是有限值, 因此最小割一定不包含中间那些容量是 $+ \infty$ 的边, 所以最小割一定是简单割

对于流网络中任意一个简单割 $[S, T]$ , 如果割边是和源点相连, 则将对应的左排节点加入点覆盖集, 如果割边是和汇点相连, 则将对应的右排节点加入点覆盖集. 这样选出来的点集一定是原图的一个点覆盖集, 即保证每条边至少选中一个点. 如何证明呢, 如果某一条边的两个点都不在点覆盖集中, 那么说明两个点和源点、汇点之间的边都不是割边, 这样就能通过这一条路径从源点搜到汇点, 这就不是一个简单割了, 由此反证得出每条边的两个点至少有一个点被选中. 这样就能将任意一个简单割对应到任意一个点覆盖集

对于任意一个点覆盖集, 和上面通过简单割构造点集的方法相反. 这里枚举点覆盖集中的所有点, 如果该点是左排节点, 则从源点到该点的边设为割边, 如果该点是右排节点, 则从该点到汇点的边设为割边. 然后从源点往下搜索, 搜到的所有点放到 $S$ 集合中, 所不到的点放到 $T$ 集合中. 如此得到一个简单割, 首先所有割边必然在左右两侧, 所以如果是割就一定是简单割. 那么是不是一个合法的割呢, 只需要看能否从源点走到汇点即可, 这里假设从源点能走到汇点, 那么就必然经过了中间某一条边, 说明这条边的两个点都没有在点覆盖集中, 这就不是一个合法的点覆盖集, 就矛盾了, 由此反证得出从源点一定走不到汇点, 所以构造出的是合法的简单割

综上所述, 证明了任意一个简单割的集合和任意一个原问题的点覆盖集是一一对应的, 然后需要看一下它们之间的数量关系, 可以发现任意一个简单割的容量就是它所有割边的容量之和, 由于已经设置这些边的容量就是对应点的权值, 所以选出的割边的容量之和就等价于原图中选出的点的权值之和, 就是对应的点覆盖集的权值之和. 所以两者的关系是相等的关系

综上所述, 按照指定的建图方式求一遍最小割就是最小权点覆盖集的权值之和

<br>

---

### 有向图破坏问题

##### 解题思路

> 本题给定一个有向图, 每次可以指定一个点, 然后将这个点出发的所有边删掉或者将这个点到达的所有边删掉. 对于每个点都有这样两种操作, 每个点的两种操作都会有不同的花费, 求将所有边删除需要的最小花费
>
> 这里和最小权点覆盖集的证明有点出入, 证明中讨论的是无向图, 本题则是有向图. 对于每一条有向边 $a \to b$ , 都有两种选择, 一种是删除从 $a$ 出发的所有边时删掉, 花费时 $W_{a^{-}}$ , 一种是删除到达 $b$ 的所有边时删掉, 花费是 $W_{b^{+}}$ . 因此对于每条边来说, 这两个操作至少要选择一个. 这个要求和点覆盖问题非常像
>
> 到这已经和最小权点覆盖集问题有关联了, 但是每个点有两种操作, 因此可以将每个点进行拆点处理, 左部节点是所有费用为 $W^+$ 的点, 即删除到达的边, 右部节点是所有费用为 $W^-$ 的点, 即删除出去的边. 对于一条边 $a \to b$ , 这条边对应的两个点至少要选一个, 所以对应的从 $b^+$ 向 $a^-$ 连一条边, 这样就能构造出一个二分图, 对于原问题来说,  $a^-$ 和 $b^+$ 至少选一个; 对于二分图中对应的这条边来说, 两个端点至少选一个. 所以这两个问题是完全一致的. 然后还需要考虑数量关系, 原问题每个操作都有一个权值, 对应到二分图中每个点都有一个点权, 且点权非负, 因此这就完全转化成了一个二分图的点权非负的最小权点覆盖问题, 按照固定的求法解决即可
>
> 然后还需要求出操作方案, 而原问题的每个操作都对应到二分图中的每个点, 所以求操作方案其实等价于求最小权的点覆盖集. 这里结合证明过程中根据最小割构造点覆盖集的方法. 先从源点开始往下搜, 所有能走到的点在 $S$ 集合, 所有走不到的点在 $T$ 集合, 然后枚举所有正向边, 找出所有割边 (起点在 $S$ , 终点在 $T$ 的边) , 然后将所有割边中除了源点、汇点的点都找出来, 就是最小权的点覆盖集

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];		//记录每个点能否从源点被搜到, 能搜到属于 S 集合, 不能搜到属于 T 集合

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

void dfs (int u)	//爆搜找出最小割, 能从源点搜到的点属于 S 集合, 反之属于 T 集合
{
    st[u] = true;
    
    //在残量网络中沿着容量 > 0 的边往下搜
    for(int i = h[u]; i != -1; i = ne[i])
        if(f[i] && !st[e[i]])
            dfs(e[i]);
}

int main()
{
    cin >> n >> m;
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    
    //左部节点为 + , 编号 1 ~ n; 右部节点为 - , 编号 n + 1 ~ n * 2
    for(int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        add(S, i, w);	//从源点向所有左部节点连一条容量为 w+ 的边
    }
    for(int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        add(n + i, T, w);	//从所有右部节点向汇点连一条容量为 w- 的边
    }
    while(m --)
    {
        int a, b;
        cin >> a >> b;
        add(b, n + a, INF);	//从 b+ 向 a- 连一条容量为 INF 的边
    }
    
    cout << dinic() << endl;	//最小权点覆盖 = 最小割
    dfs(S);		//爆搜找出最小割
    
    int cnt = 0;
    for(int i = 0; i < idx; i += 2)
    {
    	int a = e[i ^ 1], b = e[i];
        if(st[a] && !st[b]) cnt ++;		//找出所有割边
    }
    
    cout << cnt << endl;
    for(int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if(st[a] && !st[b])
        {
            if(a == S) printf("%d +\n", b);
            if(b == T) printf("%d -\n", a - n);
        }
    }
}
```



<div style="page-break-after:always;"></div>

# 最小割之最大点权独立集

### 最大权独立集的相关概念

**独立集:** 给定一个一般图 $G(V, E)$ , 选出图中的某一个点集, 使得选出的所有点之间不存在边, 则将这个点集称为原图的 **独立集**

---

**最大权独立集:** 给定一个有向图 $G(V, E)$ , 每个点上有一个非负权值, 而图中权值和最大的独立集称为 **最大权独立集**

---

**如何求最大权独立集:** 

最大权独立集和最小权点覆盖集问题一样, 在一般情况下都是一个 NP 完全问题 (NPC 问题) , 只能用爆搜来解决, 但是在二分图中却具有非常高效的特殊做法

> 结论: 最大权点独立集 = 所有点的总权值 - 最小权点覆盖集

若整个点集是 $V$ , 点覆盖集是 $V_1$ , 那么补集就是 $V_2 = V - V_1$ 

这里有一个性质, 任意一个点覆盖集的补集都一定是独立集. 这里进一步证明这个性质. 可以用反证法, 假设点覆盖集 $V_1$ 的补集 $V_2$ 不是独立集, 说明 $V_2$ 中存在两个点 $u$ , $v$ 之间存在一条边 $(u, v)$ . 由于 $V_1$ 同样是 $V_2$ 的补集, 说明 $V_1$ 中一定不包含 $u$ , $v$ 这两个点, 那么 $(u, v)$ 这条边的两个点就都不在 $V_1$ 中, 即 $V_1$ 不是一个点覆盖集, 与条件矛盾, 反证得出任意一个点覆盖集的补集都是一个独立集

以上性质反过来, 任意一个独立集的补集都一定是点覆盖集. 同样用反证法, 假设独立集 $V_2$ 的补集 $V_1$ 不是点覆盖集, 就必然存在一条边$(u, v)$ , 使得这条边的两个点 $u$ , $v$ 都不在 $V_1$ , 即一定在 $V_2$ 中, 也就说明 $V_2$ 中存在两个点 $u$ , $v$ 之间是有边的, 所以 $V_2$ 就不是一个独立集, 反证得出任意一个独立集的补集都是一个点覆盖集

可以发现独立集和点覆盖集之间是存在补集这样一个对应关系的, 然后看一下两者之间的数量关系, 数量关系就非常明显了, 因为 $V_1$ 和 $V_2$ 互为补集, 所以两个集合的权值总和就等于所有点的权值和, 即 $w(V_1) + w(V_2) = w(V)$ , 而 $w(V)$ 是一个固定值, 因此想让 $w(V_2)$ 取最大, $w(V_1)$ 就必然取到最小, 因此想要求最大权独立集, 只需要求一下最小权点覆盖集, 最小权点覆盖集的补集就是最大权独立集, 由此得证结论



<div style="page-break-after:always;"></div>

# 最小割之建图实战

### [太空飞行计划问题](https://www.acwing.com/problem/content/2178/) [$^{24}$](https://www.luogu.com.cn/problem/P2762)  最大权闭合图  最小割

##### 解题思路

> 本题给了很多实验, 完成每个实验都能获得一定的收益, 还有很多器材, 每个实验需要对应的一些器材, 每个器材都有一个花费
>
> 可以发现想完成每个实验都需要购买对应的器材, 如果将所有器材的权值设置成负数, 所有实验的权值设置成正数, 如果将所有实验向对应的器材连一条边, 那么可以发现任何一个原问题的可行方案都会对应到图中的一个闭合子图
>
> 因此本题求的最大净收益其实就是图中的最大权闭合子图, 因此可以用求最大权闭合子图的方法来求, 从源点向所有实验连一条容量是收益的边, 从所有器材向汇点连一条容量是花费的边, 从所有实验向对应的器材连一条容量是 $+ \infty$ 的边
>
> 因此本题是经典的最大权闭合子图问题的应用, 最大权闭合子图 = 正权点的权值和 - 最小割
>
> 本题还要输出方案, 可以从最小割中推出最大权闭合子图, 就是 $S - \{s\}$ , 即所有从源点能搜到的点 (除源点)

<br>

##### 算法模板

```c++
int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];		//记录每个点能否从源点搜索到, 能就是 S 集合, 不能就是 T 集合

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == T) return true;
                q[++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    } 
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

void dfs (int u)   //从源点往下爆搜找出割的方案, 搜到的点属于 S 集合, 搜不到的点属于 T 集合
{
    st[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
        if(!st[e[i]] && f[i])
            dfs(e[i]);
}

int main()
{
    cin >> m >> n;
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    getchar();		//过滤掉第一行最后的回车
    
    int tot = 0;
    for(int i = 1; i <= m; i++)
    {
        int w, id;
        string line;
        getline(cin, line);
        stringstream ssin(line);
        ssin >> w;	//从源点向每个实验连一条容量是收益的边
        add(S, i, w);
        while(ssin >> id) add(i, m + id, INF);	//从每个实验向器材连一条容量是INF的边
        tot += w;	//累加正权点的权值
    }
    for(int i = 1; i <= n; i++)
    {
        int p;
        cin >> p;
        add(m + i, T, p);	//从每个器材向汇点连一条容量是花费的边
    }
    
    int res = tot - dinic();
    dfs(S);		//爆搜找出割的方案
    
    //闭合子图 = S - {s}
    for(int i = 1; i <= m; i++)
        if(st[i]) cout << i << ' ';		//属于 S 集合的实验就是闭合子图中的实验
    cout << endl;
    for(int i = m + 1; i <= m + n; i++)
        if(st[i]) cout << i - m << ' ';		//属于 S 集合的器材就是闭合子图中的器材
    cout << endl;
    cout << res << endl;
}
```

<br>

---

### [骑士共存问题](https://www.acwing.com/problem/content/2200/)[$^{24}$](https://www.luogu.com.cn/problem/P3355)  二分图点权最大独立集  最小割

##### 解题思路

> 本题要求放最多的马使得所有马不会相互攻击, 如果将所有能互相攻击的马之间连一条边, 将所有奇数格作为左部节点, 将所有偶数格作为右部节点, 这就是一个二分图, 且要求选中的点之间都不存在边, 也就是求二分图的最大独立集, 可以用匈牙利算法来求
>
> 最大权独立集 = 总权值 - 最小权点覆盖集, 因此需要求出最小权点覆盖集, 用固定做法即可, 从源点向所有左部节点连一条容量是权值的边, 从所有右部节点向汇点连一条容量是权值的边, 左部节点和右部节点之间的边容量为 $+ \infty$ , 最小割就是最小权点覆盖
>
> 本题每个点是没有权值的, 求的也是最大独立集的点数, 因此可以认为每个点的权值都是 $1$ . 这样就能求出最小点覆盖的点数, 对应求出最大独立集的点数

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool g[K][K];	//地图: 记录每个点是不是障碍

int get (int x, int y)	//返回格子的编号
{
    return (x - 1) * n + y;
}

void add (int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if(ver == t) return true;
                q[++ tt] = ver;
            }
        }
    }
    return false;
}

int find (int u, int limit)
{
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; i != -1 && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if(d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if(!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        } 
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while(bfs()) while(flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    cin >> n >> m;
    S = 0, T = n * n + 1;
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++)
    {
        int x, y;
        cin >> x >> y;
        g[x][y] = true;
    }
    
    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int du[] = {1, 2, 2, 1, -1, -2, -2, -1};
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
        {
            if(g[i][j]) continue;
            if((i + j) % 2 == 0)
            {
                add(S, get(i, j), 1);
                for(int k = 0; k < 8; k++)
                {
                    int x = i + dx[k], y = j + dy[k];
                    if(x >= 1 && x <= n && y >= 1 && y <= n && !g[x][y])
                        add(get(i, j), get(x, y), INF);
                }
            }
            else add(get(i, j), T, 1);
        }
    
    cout << n * n - m - dinic() << endl;
}
```



<div style="page-break-after:always;"></div>

# 费用流之算法模板

### EK算法求最小费用流 $O(nm^2)$ 

##### 算法描述

对于 $n$ 个节点, $m$ 条边的流网络, 可以在 $O(nm^2)$ 的时间复杂度内求出该流网络的 **最小费用最大流 (最大费用最大流)**

<br>

##### 算法步骤

用 `while` 循环不断判断残量网络中是否存在增广路径

对于循环中:

1. 找到增广路径
2. 更新残量网络
3. 累加最大流量

循环结束, 得到最大流

**注意:** EK 算法原本是用于求最大流的, 但是经过严格的证明后, 只需要将 EK 算法中找增广路径的 bfs 算法替换成 spfa 算法即可. 如果要求最小费用最大流, 就用 spfa 算法找最短增广路; 如果要求最大费用最大流, 就用 spfa 算法找最长增广路

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
//d[] 表示每个节点到源点的最短费用
//pre[] 表示每个节点的最短路的前驱边
//incf[] 表示源点能传到每个节点的最大流量
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

void EK (int& flow, int& cost)	//EK 算法求最小费用流
{
    flow = cost = 0;	//记录最大流, 最小费用
    while(spfa())	
    {
        int t = incf[T];	//当前最短增广路的最大流量
        flow += t, cost += t * d[T];	//累加最大流和最小费用
        for(int i = T; i != S; i = e[pre[i] ^ 1])	//将这条增广路径删掉
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
}

int main()
{
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d);
    }
    
    int flow, cost;
    EK(flow, cost);
    cout << flow << ' ' << cost << endl;
}
```



<div style="page-break-after:always;"></div>

# 费用流之直接应用

### [运输问题](https://www.acwing.com/problem/content/2194/)[$^{24}$](https://www.luogu.com.cn/problem/P4015)  费用流

##### 解题思路

> 本题有 $m$ 个仓库和 $n$ 个零售店, 每个仓库中都有一定数量的货物, 而每个零售店需要一定数量的货物, 这里保证所有仓库中的货物和所有零售店需要的货物数量是相等的
>
> 从每个仓库将货物运送到每个零售店都需要不同的费用, 然后要求将所有仓库的货物合理运输到所有零售店中需要的最小花费
>
> 可以发现本题是费用流的直接应用, 可以直观的去考虑流网络的建图方式. 把货物看成从仓库流向零售店, 那么如果将仓库看作源点, 零售店看作汇点, 这就是一个多源多汇的网络流问题
>
> 对于这类问题, 可以建立一个虚拟源点, 向每个仓库连一条边, 这样就能保证流网络只有一个源点, 边的容量就是每个仓库中的货物数量, 费用是 $0$ , 因为货物最开始就在仓库中, 因此流向仓库是不需要花费的. 同理, 再建立一个虚拟汇点, 从每个零售店向虚拟汇点连一条边, 边的容量就是每个零售店需要的货物数量, 费用也是 $0$ , 因为货物运到零售店就可以了, 再流向虚拟汇点一样不需要花费
>
> 每个仓库都可以向每个零售店运货, 因此从每个仓库向每个零售店连一条边, 由于运送货物的数量没有限制, 所以容量都是 $+ \infty$ , 费用就是题目给定的值, 假设从第 $i$ 个仓库向第 $j$ 个零售店运送货物, 费用就是 $c_{ij}$ 
>
> 很直观的就可以发现, 我们构建的流网络中任意一个最大可行流和原问题的任意一个运输方案都是一一对应的, 然后原问题要求让运输方案的费用最小, 流网络中只有中间的边有费用, 因此需要再看一下最大可行流中间边的费用和运输方案的费用是否相等. 费用等于每条边的流量乘上费用, 对应到原问题的方案中就等价于每对仓库和零售店之间运输的货物数量乘以单价, 因此在费用上也是一一对应的
>
> 综上所述, 要想求原问题的运输方案的最小花费, 只需要求我们构建的流网络的最小费用最大流
>
> 本题还要求原问题的运输方案的最大花费, 对应的就是流网络的最大费用最大流, 一种方法是在 EK 算法中用 spfa 求最长增广路, 另一种方法是将所有边的费用取反, 这样原图的最大费用最大流就等价于新图的最小费用最大流, 然后再将求出的费用取反回来就是运输方案的最大花费

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(incf[t], f[i]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()	//EK 算法求最小费用最大流
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    cin >> m >> n;
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    
    for(int i = 1; i <= m; i++)
    {
        int a;
        cin >> a;
        add(S, i, a, 0);
    }
    for(int i = 1; i <= n; i++)
    {
        int b;
        cin >> b;
        add(m + i, T, b, 0);
    }
    for(int i = 1; i <= m; i++)
        for(int j = 1; j <= n; j++)
        {
            int c;
            cin >> c;
            add(i, m + j, INF, c);
        }
    
   	cout << EK() << endl;
    
    //将所有边的流量清空, 并将费用取反
    for(int i = 0; i < idx; i += 2)
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    cout << -EK() << endl;	//最大费用最大流 = - 新图的最小费用最大流
}
```

<br>

---

### [负载平衡问题](https://www.acwing.com/problem/content/2196/)[$^{24}$](https://www.luogu.com.cn/problem/P4016)  费用流

##### 解题思路

> 每个仓库最开始都有一定数量的货物, 每个仓库可以向相邻两个仓库搬运货物, 要求用最少的搬运量使所有仓库的货物数量相等
>
> 可以计算出最终每个仓库的货物数量 $x$ , 设第 $i$ 个仓库的货物数量是 $a_i$ , 那么所有货物一定会分成两类, 一类是 $a_i > x$ , 即一定会从这些仓库中流出货物, 另一类是 $a_i < x$ , 即会有货物流入这些仓库
>
> 因此可以根据这两类, 将所有 $a_i > x$ 的仓库作为左部节点, 所有 $a_i < x$ 的仓库作为右部节点. 从源点向所有左部节点连边, 容量就是左部节点最开始多出来的货物, 即 $a_i - x$ , 费用就是 $0$ , 因为最开始货物就在左部节点中. 从所有右部节点向汇点连边, 容量就是右部节点缺少的货物, 即 $x - a_i$ , 费用也是 $0$ , 因为最终货物到右部节点就停止了. 然后从每个仓库向相邻两个仓库连边, 容量是 $+ \infty$ , 费用是 $1$ , 表示一次搬运量

<br>

##### 算法模板

```c++
int n, S, T;
int s[N];	//记录每个仓库最开始的货物数量
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh <= tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    cin >> n;
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    
    int tot = 0;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        tot += s[i];
        
        //从每个仓库向相邻两个仓库连边, 容量是 INF, 费用是 1
        add(i, i < n ? i + 1 : 1, INF, 1);
        add(i, i > 1 ? i - 1 : n, INF, 1);
    }
    
    tot /= n;
    for(int i = 1; i <= n; i++)
        if(tot < s[i])	//从源点向左部节点连一条容量是 s[i] - tot, 费用是 0 的边
            add(S, i, s[i] - tot, 0);
    	else if(tot > s[i])	//从右部节点向汇点连一条容量是 tot - s[i], 费用是 0 的边
            add(i, T, tot - s[i], 0);
    
    cout << EK() << endl;
}
```



<div style="page-break-after:always;"></div>

# 费用流之二分图最优匹配

### [分配问题](https://www.acwing.com/problem/content/2195/)[$^{24}$](https://www.luogu.com.cn/problem/P4014)  二分图最佳匹配  费用流

##### 解题思路

> 有 $n$ 个人和 $n$ 件工作, 每个人做每件工作都有不同的效率, 将 $n$ 个工作分配给 $n$ 个人, 问可以获得的最小效率和最大效率
>
> 可以将 $n$ 个人看作左部节点, $n$ 个工作看作右部节点, 这就是一个二分图. 将每个人做对应工作的效率看作两个节点之间的边的边权, 那么其实就是要求一个二分图的匹配, 使得选中的所有边的权值和最小 / 最大, 这就是一个二分图最优匹配问题
>
> 如果每条边上没有权值, 单单是一个二分图最大匹配问题就非常简单, 从源点左部节点连边, 右部节点向汇点连边, 所有边的容量都是 $1$ , 可以证明原题的方案和流网络的可行流是一一对应的
>
> 求最小效率即求最小费用最大流, 另外还要求最大效率, 也就是最大费用最大流, 可以将所有边的费用取反, 这样新图的最小费用最大流再取反回来就是原图的最大费用最大流

<br>

##### 算法模板

```c++
int n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    cin >> n;
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    
    for(int i = 1; i <= n; i++)
    {
        add(S, i, 1, 0);	//从源点向所有员工连一条容量是 1 费用是 0 的边
        add(n + i, T, 1, 0);	//从所有工作向汇点连一条容量是 1 费用是 0 的边
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
        {
            int c;
            cin >> c;
            add(i, n + j, 1, c);	
            //从所有员工向所有工作连一条边, 容量是 1 , 费用是对应的效率
        }
    
    cout << EK() << endl;	//最小费用最大流
    for(int i = 0; i < idx; i += 2)	//将所有边的流量清空, 并将费用取反
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    cout << -EK() << endl;	//最大费用最大流 = - 新图的最小费用最大流
}
```



<div style="page-break-after:always;"></div>

# 费用流之最大权不相交路径

### [数字梯形问题](https://www.acwing.com/problem/content/2193/)[$^{24}$](https://www.luogu.com.cn/problem/P4013)  限制性带权路径  费用流

##### 解题思路

> 本题给了一个顶部有 $m$ 个点的数字梯形, 并且要求按照三种规则求出 $m$ 个人从顶部往下走能经过的最大数字总和
>
> > 规则一, 所有路径的点和边都不能相交, 即所有点和所有边都只能走一次
> >
> > 规则二, 所有路径的边都不能相交, 即所有边只能走一次, 所有点可以走无数次
> >
> > 规则三, 所有路径的点和边都可以相交, 即所有点和所有边都可以走无数次
>
> 边只能走一次, 只需要将边的容量设置成 $1$ 即可. 点只能走一次就需要一个常用的拆点技巧, 将每个点拆成入点和出点, 对每个点的限制就可以对入点到出点之间的边做限制, 这里每个点只能走一次, 那么就将每个点的入点到出点之间的边的容量设置成 $1$ 
>
> 起点是所有的顶点, 终点是所有的底点, 因此从源点向所有顶点连一条边, 容量是 $1$ . 从所有底点向汇点连一条边, 如果是规则一, 那么容量就是 $1$ , 如果是规则二、三, 由于点可以相交, 最终可能某一个底点是多条路径的终点, 因此这时容量应该设成 $+ \infty$ 
>
> 原问题的任意一个可行方案都和流网络中任意一个可行流是一一对应的, 并且由于所有方案都有 $m$ 条路径, 而源点出去的流量只有 $m$ , 因此任意一个可行方案都对应了一个最大流
>
> 本题要求的是所有方案中经过点的权值和最大的路径, 即权值和最大的一个最大流, 将每个点的入点到出点的边的费用设置成对应的权值, 其余边的费用都设置成 $0$ , 那么权值和最大的最大流就等价于最大费用最大流, 每次根据不同的规则放开点和边的限制重新求一遍最大费用最大流即可

<br>

##### 算法模板

```c++
int m, n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];
int id[V][V], cost[V][V];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{	
    int cnt = 0;	//用于记录唯一编号
    cin >> m >> n;
    S = ++ cnt;		//源点
    T = ++ cnt;		//汇点
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m + i - 1; j++)
        {
            cin >> cost[i][j];
            id[i][j] = ++ cnt;	//给每一个点设置一个唯一编号
            //对于每个点(i, j),id[i][j] * 2 表示入点编号, id[i][j] * 2 + 1 表示出点编号
        }
    
    //规则一
    memset(h, -1, sizeof h), idx = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m + i - 1; j++)
        {
            //从每个点的入点向出点连一条边, 容量是 1 , 费用是当前点的权值
            add(id[i][j] * 2, id[i][j] * 2 + 1, 1, cost[i][j]);
            //从源点向所有顶点连一条边, 容量是 1 , 费用是 0
            if(i == 1) add(S, id[i][j] * 2, 1, 0);
            //从所有底点向汇点连一条边, 容量是 1, 费用是 0
            if(i == n) add(id[i][j] * 2 + 1, T, 1, 0);
            if(i < n)
            {
                //从当前点向左下方的点连一条边, 容量是 1 , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                //从当前点向右下方的点连一条边, 容量是 1 , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    cout << EK() << endl;
    
    //规则二
    memset(h, -1, sizeof h), idx = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m + i - 1; j++)
        {
            //从每个点的入点向出点连一条边, 容量是 INF , 费用是当前点的权值
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            //从源点向所有顶点连一条边, 容量是 1 , 费用是 0
            if(i == 1) add(S, id[i][j] * 2, 1, 0);
            //从所有底点向汇点连一条边, 容量是 INF , 费用是 0
            if(i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if(i < n)
            {
                //从当前点向左下方的点连一条边, 容量是 1 , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                //从当前点向右下方的点连一条边, 容量是 1 , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    cout << EK() << endl;
    
    //规则三
    memset(h, -1, sizeof h), idx = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m + i - 1; j++)
        {
            //从每个点的入点向出点连一条边, 容量是 INF , 费用是当前点的权值
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            //从源点向所有顶点连一条边, 容量是 1 , 费用是 0
            if(i == 1) add(S, id[i][j] * 2, 1, 0);
            //从所有底点向汇点连一条边, 容量是 INF , 费用是 0
            if(i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if(i < n)
            {
                //从当前点向左下方的点连一条边, 容量是 INF , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, INF, 0);
                //从当前点向右下方的点连一条边, 容量是 INF , 费用是 0
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, INF, 0);
            }
        }
    cout << EK() << endl;
}
```



<div style="page-break-after:always;"></div>

# 费用流之网格图模型

### [深海机器人问题](https://www.acwing.com/problem/content/2197/)[$^{24}$](https://www.luogu.com.cn/problem/P4012)  限制性带权路径  费用流

##### 解题思路

> 本题要求在海底收集价值, 有若干个起点和若干个终点, 每个起点都会有若干个机器人出发, 最终到达终点, 每个终点能收纳的机器人数量也是有限的, 需要让尽可能多的机器人走到终点, 并且让采集到的总价值最大 (所有价值都在边上, 每条边的价值只能收集一次)
>
> 本题是一个多源多汇网络流问题, 这里常用的技巧就是建立一个虚拟源点和一个虚拟汇点, 从虚拟源点向每个起点连一条边, 容量是该起点的机器人数量, 从每个终点向虚拟汇点连一条边, 容量是该终点能容纳的机器人数量. 每个机器人都可以向上和向右走, 所以从每个点向上方点和右方点连一条边
>
> 这样一个流网络就构建出来了, 可以发现原问题中每个机器人的行走路径都可以看作流网络中的一条可行流路径, 是一一对应的
>
> 还需要计算每个方案的具体价值, 可以发现所有样本都在边上, 因此可以将对应边的费用设置成样本的价值, 但是本题还要求每条边的样本只能取一次, 之后再走到这条边上将不再获得价值. 因此可以根据两种情况分别连两条边, 从每个点向上方点 (右方点) 连一条容量是 $1$ , 费用是该边价值的边, 再连一条容量是 $+ \infty$ , 费用是 $0$ 的边. 这样就保证了每条边的价值都只能取一次
>
> 通过以上操作, 就可以将原问题的每组方案获得的价值对应到流网络中可行流的费用上. 对于所有样本, 价值是负的边可以不走, 而对于价值是正的边, 一定是走的越多越好, 而只要存在多一条增广路, 那么这条增广路就算沿着所有费用是 $0$ 的边走, 都一定不会让费用变小, 但是流量却会变大, 因此在所有最大流中一定存在一个最大流是所有方案中费用最大的, 所以原问题的价值最大值就对应到了流网络中的最大费用最大流

<br>

##### 算法模板

```c++
int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

int get (int x, int y)
{
    return x * (m + 1) + y;
}

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    int A, B;
    cin >> A >> B >> n >> m;
    S = (n + 1) * (m + 1), T = S + 1;
    memset(h, -1, sizeof h);
    
    for(int i = 0; i <= n; i++)
        for(int j = 0; j < m; j++)
        {
            int c;
            cin >> c;
            add(get(i, j), get(i, j + 1), 1, c);
            add(get(i, j), get(i, j + 1), INF, 0);
        }
    for(int i = 0; i <= m; i++)
        for(int j = 0; j < n; j++)
        {
            int c;
            cin >> c;
            add(get(j, i), get(j + 1, i), 1, c);
            add(get(j, i), get(j + 1, i), INF, 0);
        }
    while(A --)
    {
        int k, x, y;
        cin >> k >> x >> y;
        add(S, get(x, y), k, 0);
    }
    while(B --)
    {
        int r, x, y;
        cin >> r >> x >> y;
        add(get(x, y), T, r, 0);
    }
    
    cout << EK() << endl;
}
```



<div style="page-break-after:always;"></div>

# 费用流之拆点

### [餐巾计划问题](https://www.acwing.com/problem/content/2186/)[$^{24}$](https://www.luogu.com.cn/problem/P1251)  线性规划网络流优化  费用流

##### 解题思路

> 本题要求每天都提供一定数量的毛巾, 毛巾只有洗出来或者新买的才能在当天使用, 洗毛巾可以快洗和慢洗, 因此每一条的若干块毛巾只有三种来处, 新买、快洗、慢洗, 现在要求找到一种合理的毛巾使用方式让总花费最小
>
> 新买需要 $p$ , 快洗需要 $f$ , 慢洗需要 $s$ 
>
> 每天的毛巾有三种来处, 新买、快洗、慢洗, 也有三种去处, 放着、快洗、慢洗, 放着不洗是不能直接用的
>
> 可以发现, 每天都需要接收一些毛巾, 也需要输出一些毛巾, 如果把每一天看作一个节点, 那么每个节点都会有两种操作, 因此可以对每个点进行拆点操作
>
> 将第 $i$ 天分成两个点, 一个点 $i_1$ 表示用完的旧毛巾, 一个点 $i_2$ 表示需要的新毛巾
>
> 第 $i$ 天的新毛巾有三种来处, 新买、快洗、慢洗. 新买相当于凭空变出毛巾, 从源点向 $i_2$ 连一条边, 容量是 $+ \infty$ , 费用是 $p$ ; 快洗则是从第 $i - m$ 天的旧毛巾中洗出来的, 因此从 $(i - m)_1$ 向 $i_2$ 连一条边, 容量是 $+ \infty$ , 费用是 $f$ ; 慢洗则是从第 $i - n$ 天的旧毛巾中洗出来的, 因此从 $(i - n)_1$ 向 $i_2$ 连一条边, 容量是 $+ \infty$ , 费用是 $s$ . 本题中第 $i$ 天固定只需要 $r_i$ 条毛巾, 因此从 $i_2$ 向汇点连一条容量是 $r_1$ 的边, 费用是 $0$ 
>
> 第 $i$ 天用完的毛巾也有三种去处, 留着、快洗、慢洗. 留着相当于将第 $i$ 天的旧毛巾放到了第 $i + 1$ 天, 因此从 $i_1$ 向 $(i + 1)_1$ 连一条边, 容量是 $+ \infty$ , 费用是 $0$ ; 快洗则是将第 $i$ 天的旧毛巾洗了给第 $i + m$ 天, 因此从 $i_1$ 向 $(i + m)_2$ 连一条边, 容量是 $+ \infty$ , 费用是 $f$ ; 慢洗则是将第 $i$ 天的旧毛巾洗了给第 $i + n$ 天, 因此从 $i_1$ 向 $(i + n)_2$ 连一条边, 容量是 $+ \infty$ , 费用是 $s$ . 第 $i$ 天还会产生 $r_i$ 条旧毛巾, 因此从源点向 $i_1$ 连一条边, 容量是 $r_i$ , 费用是 $0$ 
>
> 通过以上方式就能构建出一个流网络, 可以发现原问题中任意一个合理方案都能对应到流网络中任意一个可行流, 并且由于到汇点的流量之和是 $\sum{r_i}$ , 所以任意一个合法方案对应到流网络中都是最大流, 原问题的任意一个方案的总费用和流网络中任意一个最大流的费用是一一对应的
>
> 综上所述, 原问题的最小费用, 就是流网络里所有最大流中费用最小的一个, 即最小费用最大流

<br>

```c++
int n, p, x, xp, y, yp, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add (int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, INF, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int ver = e[i];
            if(f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if(!st[ver])
                {
                    q[tt ++] = ver;
                    if(tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while(spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for(int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    cin >> n >> p >> x >> xp >> y >> yp;
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    
    for(int i = 1; i <= n; i++)
    {
        int r;
        cin >> r;
        add(S, i, r, 0);
        add(n + i, T, r, 0);
        add(S, n + i, INF, p);
        if(i < n) add(i, i + 1, INF, 0);
        if(i + x <= n) add(i, n + i + x, INF, xp);
        if(i + y <= n) add(i, n + i + y, INF, yp);
    }
    
    cout << EK() << endl;
}
```



<div style="page-break-after:always;"></div>

# 2-SAT

### 2-SAT 问题的相关概念

**SAT 问题:** 给定 $n$ 个命题, $x_1, x_2, \dots , x_n$ , 每个命题有两种取值, 可以取值为真或假(0或1). 对于这 $n$ 个命题, 会有若干个条件, 如 $x_1 \vee x_2 \vee \neg x_3$ , 表示 $x_1$ 为真、 $x_2$ 为真、 $x_3$ 为假, 这三个命题中至少有一个是成立的. 我们需要给这 $n$ 个命题一个取值, 使得每一个条件都是成立的

$SAT$ 问题是一个 $NPC$ 问题 ($NP$ 完全问题), 如果给我们一个一般的 $SAT$ 问题, 我们是无法在多项式的复杂度内把这个问题求解出来的. 但是对于 $2-SAT$ 问题, 我们是有一些比较效率的解法的, 最好的算法可以做到线性的时间复杂度

**2-SAT 问题:** 区别于 $SAT$ 问题, $2-SAT$ 问题的每个条件中一定只有两个变量, 例如 $x_1 \vee \neg x_2$ , 表示 $x_1$ 为真、 $x_2$ 为假, 这两个命题中一定有一个是成立的. 相似的, $2-SAT$ 问题中所有的条件都想这样只有两个变量

<br>

---

### 2-SAT 问题的一般解法

给定 $n$ 个命题, $x_1, x_2, \dots , x_n$ , 我们用 $x_i$ 表示 $x_i = 1$ , 用 $\neg x_i$ 表示 $x_i = 0$ 

接下来我们把这个问题放到图论里面, 我们把每一个命题表示成图论里的一个点, 然后把它们之间的推导关系看成边

我们通过 $a \vee b$ 和 $b \vee a$ 得出两个推导公式 $\neg a \to b$ 和 $\neg b \to a$ , 我们就可以把这两个关系看作图论中的边, 对于 $a \vee b$ , 我们从 $\neg a$ 向 $b$ 连一条边, 从 $\neg b$ 向 $a$ 连一条边, 这两条边刚好对应两个推导公式

转化完后, 如果 $x_i$ 和 $\neg x_i$ 能相互到达, 即在同一个强连通分量中时, 就一定无解

这里用构造法, 如果任意一个变量的真值和假值在不同的强连通分量里的话, 我们用一个特定的方式去构造一组合法的解. 首先在求完强连通分量后进行缩点, 这样原图就变成一个拓扑图, 并求一下拓扑图的拓扑排序, 我们看一下这两个强连通分量在拓扑排序中哪一个更靠前哪一个更靠后, 我们每次都选择所在强连通分量更靠后的一个取值, 就能得出一组合法的解

而在我们求完强联通分量并缩点后, 所有强连通分量的编号其实就是拓扑排序的逆序, 所以对于每个变量, 我们想要知道哪个取值在拓扑排序中更靠后, 我们只需要看哪个取值所在的强连通分量编号更靠前, 因为是倒序, 所以编号越小越靠后

**算法模板**

```c++
int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp, stk[N], top;
int id[N], cnt;
int ans[N];
bool ins[N];

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++top] = u, ins[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if(ins[j]) low[u] = min(low[u], dfn[j]);
    }
    if(low[u] == dfn[u])
    {
        int y;
        cnt ++;
        do
        {
            y = stk[top --];
            ins[y] = false;
            id[y] = cnt;
        }while(y != u);
    }
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int i, a, j, b;
        cin >> i >> a >> j >> b;
        i --, j --;
        add(2 * i + !a, 2 * j + b);
        add(2 * j + !b, 2 * i + a);
    }

    for(int i = 0; i < n * 2; i++)
        if(!dfn[i])
            tarjan(i);
    for(int i = 0; i < n; i++)
        if(id[i * 2] == id[i * 2 + 1])
        {
            cout << "Impossible" << endl;
            return;
        }
        else ans[i] = (id[i * 2] > id[i * 2 + 1]);
    cout << "Possible" << endl;
    for(int i = 0; i < n; i++)
        cout << ans[i] << " \n"[i == n - 1];
}
```



<div style="page-break-after:always;"></div>

# 朱刘算法

### 最小树形图的相关概念

**树形图的定义:**

1. 以某一个点为根的有向树, 被称为 **树形图**
2. 一个有向图, 满足无环且每个点的入度为 $1$ (除了根节点), 被称为 **树形图**

**最小树形图:** 对于所有树形图中, 找到一个总权值和最小的树形图, 被称为 **最小树形图**

最小树形图问题本质上就是有向图上的最小生成树问题. $Prim$ 算法和 $Kruskal$ 算法可以解决无向图上的最小生成树问题, 朱刘算法可以解决有向图上的最小生成树问题

<br>

---

### 朱刘算法

朱刘算法是一个迭代算法, 每一次迭代:

1. 除了根节点, 对于每个点, 找一下这个点的入边中权值最小的边

2. 判断选出的边中是否存在环

   (1) 无环, 算法结束

   (2) 有环, 进入步骤 $3$ 

3. 将所有环缩点, 得到新图 $G'$ , 对于每条边:

   (1) 环内部的边, 删去

   (2) 边的终点 $u$ 在环内, 该边的权值变成原权值减去 $u$ 在环内的边的权值, 即 $w - w_{环}$ 

   (3) 其他边, 不变

算法结束后, 之前每一次迭代选出的所有边的总权值之和就是答案

每次迭代最多去掉一个点, 最多迭代 $n$ 次, 每次迭代内部的时间复杂度是 $O(m)$ , 因此整个算法时间复杂度是 $O(nm)$ 

**算法模板**

```c++
int n, m;
int d[N][N], bd[N][N];
int pre[N];
int dfn[N], low[N], timestamp, stk[N], top;
int id[N], cnt;
bool st[N], ins[N];

void dfs(int u)
{
    st[u] = true;
    for(int i = 1; i <= n; i++)
        if(d[u][i] < INF && !st[i])
            dfs(i);
}

bool check_con()
{
    memset(st, false, sizeof st);
    dfs(1);
    for(int i = 1; i <= n; i++)
        if(!st[i])
            return false;
    return true;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++top] = u, ins[u] = true;

    int j = pre[u];
    if(!dfn[j])
    {
        tarjan(j);
        low[u] = min(low[u], low[j]);
    }
    else if(ins[j]) low[u] = min(low[u], dfn[j]);

    if(low[u] == dfn[u])
    {
        int y;
        ++ cnt;
        do
        {
            y = stk[top --];
            ins[y] = false;
            id[y] = cnt;
        }
        while(y != u);
    }
}

int Edmonds()
{
    if(!check_con()) return -1;

    int res = 0;
    while(true)
    {
        for(int i = 1; i <= n; i++)
        {
            pre[i] = i;
            for(int j = 1; j <= n; j++)
                if(d[pre[i]][i] > d[j][i])
                    pre[i] = j;
        }

        memset(dfn, 0, sizeof dfn);
        timestamp = cnt = 0;
        for(int i = 1; i <= n; i++)
            if(!dfn[i])
                tarjan(i);
        if(cnt == n)
        {
            for(int i = 2; i <= n; i++)
                res += d[pre[i]][i];
            break;
        }

        for(int i = 2; i <= n; i++)
            if(id[pre[i]] == id[i])
                res += d[pre[i]][i];
        for(int i = 1; i <= cnt; i++)
            for(int j = 1; j <= cnt; j++)
                bd[i][j] = INF;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(d[i][j] < INF && id[i] != id[j])
                {
                    int a = id[i], b = id[j];
                    if(id[pre[j]] == id[j]) bd[a][b] = min(bd[a][b], d[i][j] - d[pre[j]][j]);
                    else bd[a][b] = min(bd[a][b], d[i][j]);
                }
        n = cnt;
        memcpy(d, bd, sizeof d);
    }
    return res;
}
```

```c++
//非邻接矩阵式朱刘算法模板
struct edge
{
    int u, v, val;
}e[M];
int n, m, root = 1; //点数,边数,根节点
int min_pre[N], fa[N]; //每次迭代中找到的最小入边的权值,入边的起点
int cnt_cyc, incyc_id[N]; //环的编号计数,每个点在哪个环里面
int f[N]; //类似并查集中的最高祖先,找一个点沿着入边往上跳的最终节点

int Zhuliu()
{
    int ans = 0;
    while(true)
    {
        cnt_cyc = 0;
        for(int i = 1; i <= n; i++)
            incyc_id[i] = f[i] = 0, min_pre[i] = INF;
        //--------------------init--------------------
        for(int i = 0; i < m; i++)
            if(e[i].u != e[i].v && e[i].val < min_pre[e[i].v])
                fa[e[i].v] = e[i].u, min_pre[e[i].v] = e[i].val;
        //---------------找每个点的最小入边---------------
        int now = min_pre[root] = 0;
        for(int i = 1; i <= n; i++)
        {
            if(min_pre[i] == INF) return 0; //孤立点特判
            ans += min_pre[i];
            for(now = i; now != root && f[now] != i && !incyc_id[now]; now = fa[now])
                f[now] = i;
            if(now != root && !incyc_id[now])
            {
                incyc_id[now] = ++ cnt_cyc;
                for(int v = fa[now]; v != now; v = fa[v])
                    incyc_id[v] = cnt_cyc;
            }
        }
        if(!cnt_cyc) return ans;
        //--------------------找环--------------------
        for(int i = 1; i <= n; i++)
            if(!incyc_id[i]) incyc_id[i] = ++ cnt_cyc;
        for(int i = 0; i < m; i++)
        {
            int las = min_pre[e[i].v];
            e[i].u = incyc_id[e[i].u]; e[i].v = incyc_id[e[i].v];
            if(e[i].u != e[i].v) e[i].val -= las;
        }
        n = cnt_cyc; root = incyc_id[root];
    }
}
```



<div style="page-break-after:always;"></div>

# Splay

### Splay 的相关概念

> **Splay:** Splay 是平衡树的一种, 和红黑树, treap, AVL 等相似. 相比于其他平衡树, Splay 的代码长度适中, 但是非常灵活, 能实现很多的操作, 有些操作对于别的平衡树来说, 可能很难实现或不能实现

> **Splay 的应用场景**
>
> 可以处理序列翻转一类的问题, 也可以处理有关线段的一系列问题, 可以处理很多线段树可以处理的问题, 而且比线段树更灵活

> **Splay 的原理**
>
> Splay 是一个平衡二叉树, 期望是 $log{n}$ 的高度
>
> 在 Splay 进行任何操作时, 不管是插入还是查询等, 都将这个点旋转到树根, 同时保证中序遍历是不变的
>
> Splay 的核心思路就是, 每操作一个节点, 都会把这个节点旋转到树根, 基于类似于缓存的思想, 可以让 Splay 做到平均意义下每次操作的时间复杂度都是 $O(log{n})$ 

<br>

---

### Splay 的操作实现

> **插入**
>
> 单纯的插入一个数值 $x$ , 那么找到它应该插入的位置, 插入后再把它旋转到根
>
> 将一个序列插入到 $y$ 的后面, 可以先找到 $y$ 的后继 $z$ , 先将 $y$ 旋转到根, 再把 $z$ 旋转到 $y$ 的下面, 此时由于 $z$ 是 $y$ 的后继, 所有 $z$ 一定是 $y$ 的右子节点, 且 $z$ 的左子树上一定是空的, 那么想将序列插入到 $y$ 和 $z$ 之间, 其实就是要插到 $z$ 的左子树上, 所有先将序列构造成一个二叉树, 然后直接插到 $z$ 的左子树上即可
>
> **删除**
>
> 将一段序列 $[L, R]$ 从平衡树中删除, 先找到 $L$ 的前驱 $L - 1$ 和 $R$ 的后继 $R + 1$ , 将 $L + 1$ 旋转到根节点, 将 $R + 1$ 旋转到根节点的下面, 此时 $R + 1$ 的左子树就是 $[L, R]$ 这一段序列, 直接将整个左子树去掉即可
>
> **维护信息**
>
> 对于 $Splay$ 来说, 需要维护的信息有很多种, 根据题目要求来定义, 除了题目要求的信息以外, 如果需要进行区间修改操作, 那么就需要和线段树一样维护一个懒标记, 同样需要 $pushup(\ )$ 和 $pushdown(\ )$ 两个函数, $pushup(\ )$ 可以用两个子节点的信息得到当前节点的信息, $pushdown(\ )$ 则是将当前节点的懒标记传递到两个子节点中. 两个函数根据它们的作用分别放在旋转之后以及递归之前

<br>

##### 算法模板

```c++
//Splay算法模板 (以维护序列的翻转操作为例)

struct Node
{
    int s[2], p, v;	//左右儿子节点指针, 父节点指针, 当前节点的值
    int size, flag;	//以当前节点为根的子树的节点个数, 懒标记
    
    void init (int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int root, idx;

void pushup (int x)	//通过子节点信息得到当前节点信息
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void pushdown (int x)	//将当前节点的懒标记向下传递给子节点
{
    if(tr[x].flag)
    {
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    }
}

void rotate (int x)	//左旋 + 右旋
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;	//k = 0 对应右旋, k = 1 对应左旋
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay (int x, int k)	//将节点 x 旋转到节点 k 的下面
{
    while(tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if(z != k)
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
        	else rotate(y);
        rotate(x);
    }
    if(!k) root = x;
}

void insert (int v)		//将值 v 插入 Splay
{
    int u = root, p = 0;
    while(u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx ;
    if(p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
}

int get_k (int k)	//找到第 k 个数的下标 (第k个数指中序遍历的第k个数)
{
    int u = root;
    while(true)
    {
        pushdown(u);
        if(tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if(tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

void output (int u)	//输出以节点 u 为根的子树的中序遍历
{
    pushdown(u);
    if(tr[u].s[0]) output(tr[u].s[0]);
    if(tr[u].v >= 1 && tr[u].v <= n) printf("%d ", tr[u].v);	//特判哨兵	
    if(tr[u].s[1]) output(tr[u].s[1]);
}
```

<br>

---

### Splay 的扩展应用

##### 并查集维护多棵Splay + 启发式合并

```c++
//启发式合并的数量上限是O(nlogn),每次合并时均新增节点,所以总节点数为 n + nlogn
//每一个集合中都维护一棵 Splay

struct Node
{
    int s[2], p, v, id;
    int size;
    
    void init (int _v, int _id, int _p)
    {
        v = _v, id = _id, p = _p;
        size = 1;
    }
}tr[N];

int root[N], idx;	//记录每一个 Splay 的根节点下标
int p[M];

int find (int x)	//找到 x 所在集合的根节点
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void pushup (int x)
{
    tr[x].size = tr[tr[x],s[0]].size + tr[tr[x].s[1]].size + 1;
}

void rotate (int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x. tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay (int x, int k, int b)	//将集合 b 的 Splay 中的 x 节点旋转到节点 k 的下面
{
    while(tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if(z != k)
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
        	else rotate(y);
        rotate(x);
    }
    if(!K) root[b] = x;
}

void insert (int v, int id, int b)	//将编号为id,重要度为v的节点插入集合b的Splay中
{
    int u = root[b], p = 0;
    while(u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if(p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, id, p);
    splay(u, 0, b);
}

int get_k (int k , int b)	//查询集合 b 的 Splay 中重要度第 k 小的节点编号
{
    int u = root[b];
    while(u)
    {
        if(tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
    	else if(tr[tr[u].s[0]].size + 1 == k) return tr[u].id;
    	else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

void dfs (int u, int b)	//将根节点 u 所在 Splay 中的每一个点插入到集合 b 的 Splay 中
{
    if(tr[u].s[0]) dfs(tr[u].s[0], b);
    if(tr[u].s[1]) dfs(tr[u].s[1], b);
    insert(tr[u].v, tr[u].id, b);
}

//初始化
for(int i = 1; i <= n; i++)	
{
    p[i] = root[i] = i;
    tr[i].init(v[i], i, 0);
}
idx = n;

//将集合 a 的 Spaly 和集合 b 的 Splay 合并
a = find(a), b = find(b);
if(a != b)
{
    if(tr[root[a]].size > tr[root[b]].size) swap(a, b);
    dfs(root[a], b);
    p[a] = b;
}
```



<div style="page-break-after:always;"></div>

# 树套树

### 思想

> 树套树是在一个数据结构中套用一个数据结构的思想, 分为内外两层
>
> 外层数据结构中的每一个节点都表示一个内层数据结构
>
> 外层通常用线段树或树状数组, 内层通常用平衡树或线段树

<br>

---

### 线段树 + 平衡树(STL)

##### 维护操作

> 1. 将 $pos$ 位置的数修改为 $x$ 
> 2. 查询整数 $x$ 在区间 $[l, r]$ 内的前驱 (前驱定义为小于 $x$ 的最大的数)

<br>

##### 算法模板

```c++
struct Node
{
    int l, r;
    multiset<int> s;	//平衡树
}tr[N * 4];	//线段树

int w[N];	//原序列

void build (int u, int l, int r)
{
    tr[u] = {l, r};
    tr[u].s.insert(-INF), tr[u].s.insert(INF);
    for(int i = l; i <= r; i++) tr[u].s.insert(w[i]);
    if(l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void modify (int u, int p, int x)	//单点修改
{
    tr[u].s.erase(tr[u].s.find(w[p]));
    tr[u].s.insert(x);
    if(tr[u].l == tr[u].r) return;
    
    int mid = tr[u].l + tr[u].r >> 1;
    if(p <= mid) modify(u << 1, p, x);
    else modify(u << 1 | 1, p, x);
}

int query (int u, int l, int r, int x)	//区间查询前驱
{
    if(tr[u].l >= l && tr[u].r <= r)
    {
        auto it = tr[u].s.lower_bound(x);	//大于等于 x 的最小数
        -- it;	//小于 x 的最大数
        return *it;
    }
    
    int mid = tr[u].l + tr[u].r >> 1;
    int res = -INF;
    if(l <= mid) res = max(res, query(u << 1, l, r, x));
    if(r > mid) res = max(res, query(u << 1 | 1, l, r, x));
    return res;
}

//初始化线段树
build(1, 1, n);

//将 pos 位置的数修改为 x
modify(1, pos, x);
w[pos] = x;

//查询整数 x 在区间 [l, r] 内的前驱
query(1, l, r, x);
```

<br>

---

### 线段树 + 平衡树

##### 维护操作

> 1. 查询整数 $x$ 在区间 $[l, r]$ 内的排名
> 2. 查询区间 $[l, r]$ 内排名为 $k$ 的值
> 3. 将 $pos$ 位置的数修改为 $x$ 
> 4. 查询整数 $x$ 在区间 $[l, r]$ 内的前驱 (前驱定义为小于 $x$ 的最大的数)
> 5. 查询整数 $x$ 在区间 $[l, r]$ 内的后继 (后继定义为大于 $x$ 的最小的数)

<br>

##### 算法模板

```c++
struct node
{
    int s[2], p, v;
    int size;
    
    void init (int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];	//平衡树(内层树)
int idx;

struct Node
{
    int l, r;
    int t;	//区间 [l, r] 对应的平衡树的根节点
}TR[N];	//线段树(外层树)

int w[N];	//原序列

//平衡树: 用子节点信息更新当前节点信息
void pushup (int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

//平衡树: 左旋 + 右旋
void rotate (int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

//平衡树: 将 x 旋转到 k 的下面
void splay (int &root, int x, int k)
{
    while(tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if(z != k)
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
        	else rotate(y);
        rotate(x);
    }
    if(!k) root = x;
}

//平衡树: 插入数值 v
void insert (int &root, int v)
{
    int u = root, p = 0;
    while(u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if(p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(root, u, 0);
}

//平衡树: 找出小于 v 的数的个数
int get_x (int root, int v)
{
    int u = root;
    int res = 0;
    while(u)
    {
        if(tr[u].v < v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

//平衡树: 将 p 修改为 x
void update (int &root, int p, int x)
{
    //找出 p 所在的位置
    int u = root;
    while(u)
    {
        if(tr[u].v == p) break;
        if(tr[u].v < p) u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    splay(root, u, 0);	//将 p 旋转到根节点
    //找出 p 的前驱和后继
    int l = tr[u].s[0], r = tr[u].s[1];
    while(tr[l].s[1]) l = tr[l].s[1];
    while(tr[r].s[0]) r = tr[r].s[0];
    //将 p 的前驱和后继旋转上来
    splay(root, l, 0), splay(root, r, l);
    tr[r].s[0] = 0;	//将 p 删去
    pushup(r), pushup(l);	//更新信息
    insert(root, x);	//将 x 插入进来
}

//平衡树: 找出小于 v 的最大值
int get_pre (int root, int v)
{
    int u = root, res = -INF;
    while(u)
    {
        if(tr[u].v < v) res = max(res, tr[u].v), u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

//平衡树: 找出大于 v 的最小值
int get_next (int root, int v)
{
    int u = root, res = INF;
    while(u)
    {
        if(tr[u].v > v) res = min(res, tr[u].v), u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}

//线段树: 初始化
void build (int u, int l, int r)
{
    TR[u] = {l, r};
    insert(TR[u].t, -INF), insert(TR[u].t, INF);
    for(int i = l; i <= r; i++) insert(TR[u].t, w[i]);
    if(l == r) return;
    
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

//线段树: 查询 [l, r] 中小于 x 的数的个数
int query (int u, int l, int r, int x)
{
    if(TR[u].l >= l && TR[u].r <= r) return get_x(TR[u].t, x) - 1;
    
    int mid = TR[u].l + TR[u].r >> 1;
    int res = 0;
    if(l <= mid) res += query(u << 1, l, r, x);
    if(r > mid) res += query(u << 1 | 1, l, r, x);
    return res;
}

//线段树: 将 p 位置的数修改为 x
void modify (int u, int p, int x)
{
    update(TR[u].t, w[p], x);
    if(TR[u].l == TR[u].r) return;
    
    int mid = TR[u].l + TR[u].r >> 1;
    if(p <= mid) modify(u << 1, p, x);
    else modify(u << 1 | 1, p, x);
}

//线段树: 查询 [l, r] 中小于 x 的最大数
int query_pre (int u, int l, int r, int x)
{
    if(TR[u].l >= l && TR[u].r <= r) return get_pre(TR[u].t, x);
    
    int mid = TR[u].l + TR[u].r >> 1;
    int res = -INF;
    if(l <= mid) res = max(res, query_pre(u << 1, l, r, x));
    if(r > mid) res = max(res, query_pre(u << 1 | 1, l, r, x));
    return res;
}

//线段树: 查询 [l, r] 中大于 x 的最小数
int query_next (int u, int l, int r, int x)
{
    if(TR[u].l >= l && TR[u].r <= r) return get_next(TR[u].t, x);
    
    int mid = TR[u].l + TR[u].r >> 1;
    int res = INF;
    if(l <= mid) res = min(res, query_next(u << 1, l, r, x));
    if(r > mid) res = min(res, query_next(u << 1 | 1, l, r, x));
    return res;
}

//初始化线段树
build(1, 1, n);

//查询整数 x 在区间 [l, r] 内的排名
query(1, l, r, x) + 1;

//查询区间 [l, r] 内排名为 k 的值
//二分
int L = 0, R = INF;
while(L < R)
{
    int mid = L + R + 1 >> 1;
    if(query(1, l, r, mid) + 1 <= k) L = mid;
    else R = mid - 1;
}

//将 pos 位置的数修改为 x
modify(1, pos, x);
w[pos] = x;

//查询整数 x 在区间 [l, r] 内的前驱
query_pre(1, l, r, x);

//查询整数 x 在区间 [l, r] 内的后继
query_next(1, l, r, x);
```



<div style="page-break-after:always;"></div>

# 莫队

> 莫队是一类离线区间询问问题, 经常应用于需要维护的信息无法合并时(如线段树等)
>
> 其核心思想是: 维护两个指针 `l` , `r` . 在已知 `[l,r]` 这段区间的信息的前提下, 两个指针分别移动到 `l'` , `r'` 的过程中, 实时地维护答案, 从而算出区间 `[l,r]` 的信息



---

### 莫队之基础莫队

> 莫队是一类离线区间询问问题, 核心是对大量的询问进行处理, 每个询问一般都有一个区间 `[l,r]` , 我们对询问进行分块
>
> 维护两个指针 `l` , `r` , 在已知 `[l,r]` 这段区间的信息的前提下, 两个指针分别移动到 `l'` , `r'` 的过程中, 实时地维护答案, 从而算出区间 `[l,r]` 的信息

<br>

> 对询问进行分块
>
> ① 按照 `[l,r]` , `l` 递增进行排序, 分成 $\sqrt{n}$ 块
>
> ② 每一块内部按照 `r` 排序
>
> 优化: 分块长度 `len` = $\sqrt{\dfrac{n^2}{m}}$ , ( `n` 为数组长度, `m` 为询问个数)
>
> $\quad$ $\quad$ 奇数块内 `r` 从小到大排序, 偶数块内 `r` 从大到小排序

<br>

```c++
//基础莫队算法模板
int n,m,len;	//n为数组长度,m为询问个数,len为分块长度
int w[N],ans[M],cnt[S];	//w[]记录数组,ans[]记录每个询问答案,cnt[]数组实时维护每个元素出现的次数

struct Query
{
    int id,l,r;
}q[M];	//离线记录询问

int get (int l)	//按左端点分块
{
    return l/len;
}

bool cmp (const Query&a,const Query &b)	//对询问排序
{
    int i=get(a.l),j=get(b.l);
    if(i!=j)return i<j;		//第一关键字:左端点l分块从小到大排序
    else return a.r<b.r;	//第二关键字:同一块内,按右端点r排序
}

void add (int x,int &res)
{
    if(!cnt[x])res++;
    cnt[x]++;
}

void del (int x,int &res)
{
    cnt[x]--;
    if(!cnt[x])res--;
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>w[i];
    cin>>m;
    len=max(1,(int)sqrt((double)n*n/m));
    
    for(int i=0;i<m;i++)
    {
        int l,r;
        cin>>l>>r;
        q[i]={i,l,r};
    }
    sort(q,q+m,cmp);
    
    for(int k=0,i=0,j=1,res=0;k<m;k++)	//i是向r靠齐的指针,j是向l靠齐的指针
    {
        int id=q[k].id,l=q[k].l,r=q[k].r;
        while(i<r)add(w[++i],res);
        while(i>r)del(w[i--],res);
        while(j<l)del(w[j++],res);
        while(j>l)add(w[--j],res);
        ans[id]=res;
    }
    
    for(int i=0;i<m;i++)cout<<ans[i]<<'\n';
    return 0;
}
```





---

### 莫队之带修改的莫队

> 在离线莫队里加入时间戳 `(l,r,t)`
>
> 对于操作来说, 我们把修改和询问分开
>
> 对于询问: 左端点所在块为第一关键字, 右端点所在块为第二关键字, 时间为第三关键字进行排序
>
> 与普通莫队相似, 只需要多维护一个修改的操作: 假设两个询问的时间分别为 `t1` , `t2` , 只需要把 `[t1,t2]` 这段时间内的修改操作执行一遍(时光正流或倒流)
>
> 优化: `len` = $\sqrt[3]{nt} + 1$ , ( `n` 为元素个数, `t` 为时间/操作次数)

<br>

```c++
//带修莫队算法模板
int n,m,mq,mc,len;	//n为元素个数,mq为询问次数,mc为操作次数
int w[N],cnt[S],ans[M];

struct Query	//记录询问
{
    int id,l,r,t;
}q[M];

struct Modify	//记录操作
{
    int p,c;
}c[M];

int get (int x)
{
    return x/len;
}

bool cmp (const Query&a,const Query&b)
{
    int al=get(a.l),ar=get(a.r);
    int bl=get(b.l),br=get(b.r);
    if(al!=bl)return al<bl;
    if(ar!=br)return ar<br;
    return a.t<b.t;
}

void add (int x,int &res)
{
    if(!cnt[x])res++;
    cnt[x]++;
}

void del (int x,int &res)
{
    cnt[x]--;
    if(!cnt[x])res--;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>w[i];
    for(int i=0;i<m;i++)
    {
        char op[2];
        int a,b;
        cin>>op>>a>>b;
        if(*op=='Q')mq++,q[mq]={mq,a,b,mc};	//记录询问
        else c[++mc]={a,b};	//记录操作
    }
    
    len=cbrt((double)n*max(1,mc))+1;
    sort(q+1,q+1+mq,cmp);
    
    for(int k=1,i=0,j=1,res=0,t=0;k<=mq;k++)
    {
        int id=q[k].id,l=q[k].l,r=q[k].r,tm=q[k].t;
        while(i<r)add(w[++i],res);
        while(i>r)del(w[i--],res);
        while(j<l)del(w[j++],res);
        while(j>l)add(w[--j],res);
        while(t<tm)
        {
            t++;
            if(c[t].p>=l&&c[t].p<=r)
            {
                del(w[c[t].p],res);
                add(c[t].c,res);
            }
            swap(w[c[t].p],c[t].c);
        }
        while(t>tm)
        {
            if(c[t].p>=l&&c[t].p<=r)
            {
                del(w[c[t].p],res);
                add(c[t].c,res);
            }
            swap(w[c[t].p],c[t].c);
            t--;
        }
        ans[id]=res;
    }
    
    for(int i=1;i<=mq;i++)cout<<ans[i]<<'\n';
    return 0;
}
```





---

### 莫队之回滚莫队

> 回滚莫队用于维护一段区间内的 `max` 或 `min` 
>
> 处理一段区间分为两部分:
>
> ① 对于左端点 `l` 和右端点 `r` 在同一段内的区间, 暴力处理
>
> ② 对于左端点 `l` 和右端点 `r` 不在同一段内的区间, 分别处理 `[l,right]` 和 `[right+1,r]`
>
> 以左端点所在的块升序为第一关键字, 以右端点升序为第二关键字

<br>

```c++
//回滚莫队算法模板
int n,m,len;
int w[N],cnt[N];
long long ans[N];
vector<int> nums;

struct Query
{
    int id,l,r;
}q[N];

int get (int x)
{
    return x/len;
}

bool cmp (const Query&a,const Query&b)
{
    int i=get(a.l),j=get(b.l);
    if(i!=j) return i<j;
    else return a.r<b.r;
}

void add (int x,long long &res)	//回滚莫队只有增加操作,没有删减操作
{
    cnt[x]++;
    res=max(res,(long long)cnt[x]*nums[x]);
}

int main()
{
    cin>>n>>m;
    len=sqrt(n);
    
    for(int i=1;i<=n;i++)cin>>w[i],nums.push_back(w[i]);
    sort(nums.begin(),nums.end());	//离散化
	nums.erase(unique(nums.begin(),nums.end()),nums.end());
    for(int i=1;i<=n;i++)
        w[i]=lower_bound(nums.begin(),nums.end(),w[i])-nums.begin();
    	//w[i]存储原数在离散化数组nums中的下标
    
    for(int  i=0;i<m;i++)
    {
        int l,r;
        cin>>l>>r;
        q[i]={i,l,r};
    }
    sort(q,q+m,cmp);
    
    for(int x=0;x<m;)
    {
        int y=x;	//处理左端点l在同一段内的所有询问[x,y)
        while(y<m&&get(q[y].l)==get(q[x].l))y++;
        int right=(get(q[x].l)+1)*len-1;	//左端点l所在段终点为right
        
        //暴力求右端点r在块内的询问
        while(x<y&&q[x].r<=right)
        {
            long long res=0;
            int id=q[x].id,l=q[x].l,r=q[x].r;
            for(int k=l;k<=r;k++)add(w[k],res);
            ans[id]=res;
            for(int k=l;k<=r;k++)cnt[w[k]]--;	//复原
            x++;
        }
        
        //求右端点r在块外的询问
        long long res=0;
        int i=right,j=right+1;	//i是右指针,j是左指针
        while(x<y)
        {
            int id=q[x].id,l=q[x].l,r=q[x].r;
            while(i<r)add(w[++i],res);
            long long backup=res;	//备份[right+1,r]的res值
            while(j>l)add(w[--j],res);
            ans[id]=res;
            while(j<right+1)cnt[w[j++]]--;	//复原
            res=backup;
            x++;
        }
        memset(cnt,0,sizeof cnt);
    }
    
    for(int i=0;i<m;i++)cout<<ans[i]<<'\n';
    return 0;
}
```





---

### 莫队之树上莫队

> 树上莫队可以在树上查询一些很有意思的东西, 比如众数、数的出现次数
>
> 众所周知, 莫队是在序列上进行一系列的查询的, 并且必须离线与静态. 那么我们就不妨考虑将一棵树转化为一个序列, 再在这个序列上进行我们想要的操作. 这个序列就是欧拉序
>
> 欧拉序列指的是对一棵树的深度优先遍历的顺序, 在遍历每一个点的时候, 先将这个点放到序列中, 然后递归遍历它的所有子树, 遍历完所有子树后, 回溯时再把这个点放到序列中 (即每个点在序列中都会出现两遍)

<br>

> 欧拉序列的性质: 
>
> 对于一棵树的欧拉序列, `ein[u]` 表示节点 `u` 在欧拉序列中第一次出现的位置, `eout[u]` 表示节点 `u` 在欧拉序列中最后一次出现的位置
>
> 对于树上的两个节点 `x` , `y` , 满足 `ein[x] < ein[y]`
>
> ① 若 `lca(x,y) == x` , 则从 `x` 到 `y` 的路径为欧拉序列中 `[ein[x], ein[y]]` 中只出现一次的点
>
> ② 若 `lca(x,y) != x` , 则从 `x` 到 `y` 的路径为欧拉序列中 `[eout[x], ein[y]]` 中只出现一次的点以及 `lca(x, y)`

<br>

> 树上莫队一般流程:
>
> ① 离散化
>
> ② 求欧拉序列
>
> ③ 求LCA (倍增/ tarjan)
>
> ④ 将树中询问变成序列中的询问
>
> ⑤ 基础莫队

<br>

```c++
//树上莫队算法模板
int n,m,len;	//n为节点个数,m为询问个数,len为分块长度
int w[N];		//存储每个节点的元素值
int h[N],e[N],ne[N],idx;	//邻接表存储树边
int depth[N],fa[N][size];		//倍增求lca,size取logn(n为节点数量)
int seq[N],top,ein[N],eout[N];		//欧拉序列
int cnt[N],st[N],ans[N];	
//cnt[]数组实时维护每个元素出现的次数,st[]数组实时维护每个节点出现的次数,ans[]记录每个询问答案
int que[N];		//宽搜队列
vector<int> nums;	//离散化数组

struct Query
{
    int id,l,r,p;	//p记录是否考虑lca,及lca是多少
}q[N];	//离线记录询问

void add_edge (int a,int b)	//添加有向边
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void dfs (int u,int father)	//深搜预处理欧拉序列
{
    seq[++top]=u;
    ein[u]=top;		//ein[u]表示节点u在欧拉序列中第一次出现的位置

    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j!=father)dfs(j,u);
    }

    seq[++top]=u;
    eout[u]=top;	//eout[u]表示节点u在欧拉序列中最后一次出现的位置
}

void bfs()	//宽搜预处理depth和fa数组
{
    memset(depth,0x3f,sizeof depth);
    depth[0]=0,depth[1]=1;
    int hh=0,tt=0;
    que[0]=1;

    while(hh<=tt)
    {
        int t=que[hh++];
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                que[++tt]=j;
                fa[j][0]=t;
                for(int k=1;k<=size;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}

int lca (int a,int b)	//查询节点a,b的最近公共祖先
{
    if(depth[a]<depth[b])swap(a,b);
    for(int k=size;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b])
            a=fa[a][k];
    if(a==b)return a;

    for(int k=size;k>=0;k--)
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    return fa[a][0];
}

int get (int x)	//分块
{
    return x/len;
}

bool cmp (const Query &a,const Query &b)	//对询问排序
{
    int i=get(a.l),j=get(b.l);
    if(i!=j)return i<j;		//第一关键字:左端点l分块按从小到大排序
    else return a.r<b.r;	//第二关键字:同一块内,按右端点r排序
}

void add (int x,int &res)	//树上莫队添加和删减操作相同
{
    st[x]^=1;
    if(st[x]==0)
    {
        cnt[w[x]]--;
        if(!cnt[w[x]])res--;
    }
    else
    {
        if(!cnt[w[x]])res++;
        cnt[w[x]]++;
    }
}

int main()
{
    cin>>n>>m;

    for(int i=1;i<=n;i++)cin>>w[i],nums.push_back(w[i]);
    sort(nums.begin(),nums.end());	//离散化
    nums.erase(unique(nums.begin(),nums.end()),nums.end());
    for(int i=1;i<=n;i++)
        w[i]=lower_bound(nums.begin(),nums.end(),w[i])-nums.end();
		//w[i]存储原数在离散化数组nums中的下标

    memset(h,-1,sizeof h);
    for(int i=0;i<n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        add_edge(a,b),add_edge(b,a);
    }

    dfs(1,-1);
    bfs();

    for(int i=0;i<m;i++)
    {
        int a,b;
        cin>>a>>b;
        if(ein[a]>ein[b])swap(a,b);
        int p=lca(a,b);
        if(a==p)q[i]={i,ein[a],ein[b]};
        else q[i]={i,eout[a],ein[b],p};
    }

    len=sqrt(top);
    sort(q,q+m,cmp);

    for(int k=0,i=0,j=1,res=0;k<m;k++)	//i是向r靠齐的指针,j是向l靠齐的指针
    {
        int id=q[k].id,l=q[k].l,r=q[k].r,p=q[k].p;
        while(i<r)add(seq[++i],res);
        while(i>r)add(seq[i--],res);
        while(j<l)add(seq[j++],res);
        while(j>l)add(seq[--j],res);
        if(p)add(p,res);
        ans[id]=res;
        if(p)add(p,res);
    }

    for(int i=0;i<m;i++)cout<<ans[i]<<'\n';

    return 0;
}
```





---

### 莫队之二次离线莫队

> 莫队二次离线, 是一种莫队, 专门用来处理莫队中转移不是 $O(1)$ , 但可以前缀和拆分的问题, 其基于莫队 + 扫描线的思想, 通过扫描线, 再次将更新答案的过程离线处理, 降低时间复杂度
>
> 具体的, 设更新答案的时间复杂度为 $O(k)$ , 那么它可以将莫队的时间复杂度从 $O(nk\sqrt n)$ 降低到 $O(nk + n\sqrt n)$ , 大大简化了计算
>
> 二次离线莫队通常适用于满足以下条件的题目:
>
> + 可用莫队做
> + 莫队扩展或者删除一个点对答案的影响取决于当前区间的长度
> + 扩展或删除一个点对答案的影响可用前缀写成差分的形式

<br>

> 莫队二次离线的应用: [AcWing 2535. 二次离线莫队](https://www.acwing.com/problem/content/2537/)

```c++
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 100010;

struct Query
{
    int id, l, r; //编号、左端点、右端点
    LL ans; //由于每个询问的答案可能分成多个部分分别处理，需要先将部分答案单独存下来
}q[N]; //存储所有询问

struct Range
{
    int id, l, r, t; //编号、左端点、右端点、类型（1 表示加上，-1 表示减去）
};
//range[i] 表示询问 w[l] ~ w[r] 中每个数和 w[1] ~ w[i] 共有多少个配对
vector<Range> range[N]; //存储每个询问中需要二次离线解决的问题

int n, m, k, len;
int w[N]; //原序列
int id[N]; //记录每个下标所在的块编号
LL res[N]; //记录每个询问的答案
//f[i] 表示 w[1] ~ w[i] 中与 w[i + 1] 配对的数的个数
//g[x] 表示前 i 个数中与 x 配对的数的个数
int f[N], g[N];

inline int get(int x)  //分块
{
    return x / len;
}

inline int get_count(int x) //计算 x 的二进制表示中 1 的个数
{
    int res = 0;
    for(int i = 0; i < 14; i++) res += x >> i & 1;
    return res;
}

//先按照左端点所在块的编号从小到大排序，再按照右端点从小到大排序
bool cmp(const Query &a, const Query &b)
{
    int i = get(a.l), j = get(b.l);
    if(i != j) return i < j;
    return a.r < b.r;
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);

    for(int i = 1; i <= n; i++) scanf("%d", &w[i]);

    vector<int> nums; //存储所有二进制表示中有 k 个 1 的数
    for(int i = 0; i < 1 << 14; i++) //枚举范围内的所有数
        if(get_count(i) == k) //如果当前数的二进制表示中有 k 个 1
            nums.push_back(i); //将当前数加入容器

    //预处理 f[]
    for(int i = 1; i <= n; i++)
    {
        for(auto y: nums) g[w[i] ^ y]++;
        f[i] = g[w[i + 1]];
    }

    //接收所有询问
    for(int i = 0; i < m; i++)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }

    len = sqrt(n); //计算块的长度

    //将所有询问先按照左端点所在块的编号从小到大排序，再按照右端点从小到大排序
    sort(q, q + m, cmp);

    //莫队算法
    for(int x = 0, i = 1, j = 0; x < m; x++)
    {
        int l = q[x].l, r = q[x].r;

        //j 向右移向 r，则 [j + 1, r] 中的所有 -S[i - 1] 需要二次离线处理
        if(j < r) range[i - 1].push_back({x, j + 1, r, -1});
        while(j < r) q[x].ans += f[j++]; 
        //j 向右移向 r，加入 w[j + 1]，ans + (S[j] - S[i - 1])

        //j 向左移向 r，则 [r + 1, j] 中的所有 +S[i - 1] 需要二次离线处理
        if(j > r) range[i - 1].push_back({x, r + 1, j, 1});
        while(j > r) q[x].ans -= f[--j]; 
        //j 向左移向 r，删去 w[j]，ans - (S[j - 1] - S[i - 1])

        //i 向右移向 l，则 [i, l - 1] 中的所有 -S[j] 需要二次离线处理
        if(i < l) range[j].push_back({x, i, l - 1, -1});
        while(i < l) q[x].ans += f[i - 1] + !k, i++; 
        //i 向右移向 l，删去 w[i]，ans - (S[j] - S[i])

        //i 向左移向 l，则 [l, i - 1] 中的所有 +S[j] 需要二次离线处理
        if(i > l) range[j].push_back({x, l, i - 1, 1});
        while(i > l) q[x].ans -= f[i - 2] + !k, i--; 
        //i 向左移向 l，加入 w[i - 1]，ans + (S[j] - S[i - 1])
    }

    memset(g, 0, sizeof g); //g[] 数组复用，提前清空

    //二次离线
    for(int i = 1; i <= n; i++)
    {
        for(auto y: nums) g[w[i] ^ y]++; //递推出前 i 个数的 g[]
        for(auto& rg: range[i]) //处理所有和 1 ~ i 求配对的询问
        {
            int id = rg.id, l = rg.l, r = rg.r, t = rg.t;
            for(int x = l; x <= r; x++) q[id].ans += g[w[x]] * t; 
            //将求出的结果加入对应询问的答案中
        }
    }

    for(int i = 1; i < m; i++) q[i].ans += q[i - 1].ans; //前缀和求出所有询问的最终答案
    for(int i = 0; i < m; i++) res[q[i].id] = q[i].ans; //记录所有询问的答案

    for(int i = 0; i < m; i++) printf("%lld\n", res[i]); //输出所有询问的答案

    return 0;
}
```



<div style="page-break-after:always;"></div>

# 树链剖分

### 树链剖分的相关概念

**树链剖分:** 树链剖分是一种思想, 它可以通过给树中每个点重新编号, 使得我们可以将树中任意一条路径转化成 $O(\log n)$ 段连续区间. 这样就能将树上路径的问题转化成区间问题, 再用求区间问题的方法去进行处理

---

**树链剖分的原理**

首先定义几个树链剖分中的概念

**重儿子:** 对于任意非叶子节点 $u$ , 它的子节点中所在子树节点个数最多的子节点称为 $u$ 的 **重儿子** , 若有多个所在子树节点个数最多的顶点, 则任选一个作为重儿子

**轻儿子:** 对于树中的所有节点, 除去根节点和所有重儿子, 剩余的全部节点都是 **轻儿子**

**重边:** 树中任意重儿子和它的父节点之间的边称为 **重边**

**轻边:** 对于树中的所有边, 除去重边, 剩余的所有边都是 **轻边**

**重链:** 树中所有极大的由重边构成的路径被称为 **重链** , 树中每个点都要在一个极大重链中, 如果某个点不和重边相连, 则自成一个重链. 每个重儿子一定在它父节点所在的重链中, 每个轻儿子一定在从它往下的重链中

对于一棵树, 我们直接通过它的 $dfs$ 序将其变成一个序列, 这个序列就是在 $dfs$ 的过程中按顺序遍历到的每个点的次序, 从根节点开始, 遍历的过程中要求优先遍历整棵子树的重儿子, 最开始一定会按照子节点的重儿子一直往下走, 直到重儿子遍历完后, 一步一步的回溯, 回溯的过程中再将没有遍历到的子树遍历, 过程中只要遇到重儿子就优先遍历, 再进行回溯

根据优先遍历重儿子而得到的 $dfs$ 序能保证所有重链中节点的编号都是连续的, 在此前提下就有以下这个关键的定理

---

**定理:** 树中任意一条路径均可拆分成 $O(\log n)$ 条重链, 即 $O(\log n)$ 个连续区间

---

以上就是树链剖分的全部思想, 整个流程并不复杂, 简单来说, 先用一个 $dfs$ 标记出每个节点的重儿子, 再用一个 $dfs$ 找出所有的重链并标记出每个节点所在重链的顶点, 同时还能得到整棵树转化成的优先遍历重儿子的 $dfs$ 序. 到此就将整棵树转化成一个序列, 并标记出了每个重链, 接下来就需要将任意一条路径拆分成 $O(\log n)$ 条重链

转化的过程类似于求最近公共祖先的做法, 假设想求 $(u, v)$ 之间的路径, 设 $u$ 所在重链的顶点是 $x$ , $v$ 所在重链的顶点是 $y$ , 看一下 $x$ , $y$ 哪个更靠下, 每次将更靠下的那一段重链拆分出来, 假设此时 $x$ 更靠下, 此时 $x$ 到 $u$ 的路径已经被拆分出来, 然后就需要从 $x$ 走到下一段路径中, 也就是 $x$ 的父节点 $fx$ , 然后找出 $fx$ 所在的重链的顶点 $z$ , 再去判断 $z$ 和 $y$ 哪一个更靠下, 再将靠下的一段重链拆分出来, 以此类推. 最终, 这两个顶点一定会走到某一条公共的重链上, 这条重链就是这两个顶点的最近公共祖先所在的重链, 再将这两个点在重链上中间的一部分抠出来, 就能得到 $O(\log n)$ 条重链

综上所述, 就将每条路径拆分成了 $O(\log n)$ 条重链, 然后就能再通过其他处理区间问题的数据结构去进行维护. 一般处理这些区间问题的时间复杂度都是 $O(\log n)$ 的, 每一个询问又拆分成 $O(\log n)$ 个连续区间, 因此每个询问的时间复杂度是 $O(\log^2 n)$ 的

另外, 对于 $dfs$ 序还有一个特点, 任意一棵子树中的所有节点的编号都是连续的, 因此对于任意一棵子树同样可以转化成一段连续的区间, 因此如果想对某一个子树中的节点进行操作, 就可以直接转化成区间操作来处理

<br>

---

##### 维护操作

> 1. 修改路径上节点权值, 将节点 $u$ 和节点 $v$ 之间路径上的所有节点 (包括这两个节点) 的权值增加 $k$ 
> 2. 修改子树上节点权值, 将以节点 $u$ 为根的子树上的所有节点的权值增加 $k$ 
> 3. 询问路径, 询问节点 $u$ 和节点 $v$ 之间路径上的所有节点 (包括这两个节点) 的权值和
> 4. 询问子树, 询问以节点 $u$ 为根的子树上的所有节点的权值和

<br>

##### 算法模板

```c++
int n, m;
int w[N], h[N], e[M], ne[M], idx;
int id[N], nw[N], cnt;
//id[i] 表示节点 i 的 dfs 序中的编号
//nw[i] 表示 dfs 序中第 i 个点的权值
int dep[N], sz[N], top[N], fa[N], son[N];
//dep[i] 表示节点 i 的深度
//sz[i] 表示以节点 i 为根节点的子树中节点个数
//top[i] 表示节点 i 所在重链的顶点
//fa[i] 表示节点 i 的父节点
//son[i] 表示节点 i 的重儿子

struct Tree
{
    int l, r;
    LL add, sum;
}tr[N * 4];

void add (int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

//当前节点编号 u , 父节点编号 father , 当前节点深度 depth
//预处理 dep[], fa[], sz[], son[]
void dfs1 (int u, int father, int depth)	
{
    dep[u] = depth, fa[u] = father, sz[u] = 1;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(j == father) continue;
        dfs1(j, u, depth + 1);
        sz[u] += sz[j];
        if(sz[son[u]] < sz[j]) son[u] = j;
    }
}

//当前节点编号 u , 当前重链的顶点 t
//找出 dfs 序和所有重链
void dfs2 (int u, int t)
{
    id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t;
    if(!son[u]) return;	//没有儿子直接返回
    dfs2(son[u], t);	//否则优先搜索重儿子
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(j == fa[u] || j == son[u]) continue;
        dfs2(j, j);	//轻儿子所在重链的顶点就是它自己
    }
}

void pushup (int u)
{
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown (int u)
{
    auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
    if(root.add)
    {
        left.add += root.add, left.sum += root.add * (left.r - left.l + 1);
        right.add += root.add, right.sum += root.add * (right.r - right.l + 1);
        root.add = 0;
    }
}

void build (int u, int l, int r)
{
    tr[u] = {l, r, 0, nw[r]};
    if(l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void update (int u, int l, int r, int k)	//区间修改
{
    if(l <= tr[u].l && r >= tr[u].r)
    {
        tr[u].add += k;
        tr[u].sum += k * (tr[u].r - tr[u].l + 1);
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) update(u << 1, l, r, k);
    if(r > mid) update(u << 1 | 1, l, r, k);
    pushup(u);
}

LL query (int u, int l, int r)	//区间查询
{
    if(l <= tr[u].l && r >= tr[u].r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    LL res = 0;
    if(l <= mid) res += query(u << 1, l, r);
    if(r > mid) res += query(u << 1 | 1, l, r);
    return res;
}

void update_path (int u, int v, int k)	//树上路径修改
{
    while(top[u] != top[v])	//只要 u 和 v 不在同一个重链中, 就能继续拆出重链
    {
        if(dep[top[u]] < dep[top[v]]) swap(u, v);
        update(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }
    if(dep[u] < dep[v]) swap(u, v);
    update(1, id[v], id[u], k);	//将拆除的最后一段重链单独计算
}

LL query_path (int u, int v)	//树上路径查询
{
    LL res = 0;
    while(top[u] != top[v])	//只要 u 和 v 不在同一个重链中, 就能继续拆出重链
    {
        if(dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if(dep[u] < dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);	//将拆出的最后一段重链单独计算
    return res;
}

void update_tree (int u, int k)	//树上子树修改
{
    update(1, id[u], id[u] + sz[u] - 1, k);	//转化成区间修改
}

LL query_tree (int u)	//树上子树查询
{
    return query(1, id[u], id[u] + sz[u] - 1);	//转化成区间查询
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];
    memset(h, -1, sizeof h);
    for(int i = 0; i < n - 1; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs1(1, -1, 1);	//预处理 dep[], fa[], sz[], son[]
    dfs2(1, 1);	//找出 dfs 序和所有重链
    build(1, 1, n);
    
    cin >> m;
    while(m --)
    {
        int op;
        cin >> op;
        if(op == 1)	//树上路径修改
        {
            int u, v, k;
            cin >> u >> v >> k;
            update_path(u, v, k);
        }
        else if(op == 2)	//树上子树修改
        {
            int u, k;
            cin >> u >> k;
            update_tree(u, k);
        }
        else if(op == 3)	//树上路径查询
        {
            int u, v;
            cin >> u >> v;
            cout << query_path(u, v) << endl;
        }
        else	//树上子树查询
        {
            int u;
            cin >> u;
            cout << query_tree(u) << endl;
        }
    }
}
```



<div style="page-break-after:always;"></div>

# 动态树

### 动态树的相关概念

**动态树:** 动态树就是动态的维护一个森林, 能够动态的添加或删除一些边, 同时维护树上的一些信息

---

### 动态树的原理

动态树中的边分为虚边和实边, 每个节点最多只会有一条实边连出去, 也可以没有实边. 用实边连成的路径称为实边路径, 没有实边的孤立点也被看作一条实边路径. 动态树就是通过维护实边之间的关系来维护整棵树

在树链剖分中, 我们使用线段树或树状数组来维护重链. 而在动态树中, 由于要支持添加和修改操作, 因此这里要使用一些更加灵活的数据结构去进行维护, 这里会用 $Splay$ 来维护所有的极大的实边路径. 而 $Splay$ 是用类似于维护区间的方式来维护实边路径的, 整个 $Splay$ 的中序遍历就是一条从上到下的实边路径

在所有实边路径之间, 存在很多虚边, 如果某个节点和它的父节点不在同一个实边路径中, 则它们之间的边就是虚边

由于一个 $Splay$ 的中序遍历是一条从上到下的实边路径, 因此对于 $Splay$ 中的某一个点, 它在树中的子节点应该是在 $Splay$ 中的后继节点, 它在树中的父节点应该是在 $Splay$ 中的前驱节点

注意, 这里使用 $Splay$ 中的前驱后继关系来维护树中的父子关系, $Splay$ 中的父子关系只是用来维护中序遍历的, 和树中的父子关系是毫无关联的

而对于所有的虚边, 可以发现任意一条虚边都是某一条实边路径中的最上面的一个点和它在树中的父节点之间的边. 可以发现在每个 $Splay$ 中, 它的根节点的父节点是没有被用过的, 因此我们可以用每个 $Splay$ 的根节点来维护它所对应的实边路径最上面的节点和其父节点之间的虚边

到此, 我们就能用每个 $Splay$ 去维护每条实边路径, 然后用每个 $Splay$ 的根节点去维护实边路径之间的虚边, 这样就能用 $Splay$ 维护区间的方式来维护好整棵树

可以发现, 对于每条实边, 父节点是连向子节点的, 子节点也是连向父节点的, 但是对于每条虚边, 只有子节点连向父节点, 父节点并没有连向子节点, 因此对于每条边, 我们可以通过父节点是否指向子节点来判断这条边是实边还是虚边. 而这样的好处就是对于任意一个节点, 我们可以任意选择这个节点对应的实边, 如果我们想将当前这条实边 $(u, v)$ 换成另一条 $(u, x)$ 的话,只需要让这个节点的后继 $v$ 更换成 $x$ 即可. 可以发现, 这样我们就能非常容易的将一条实边删掉换成另一条虚边

---

### 动态树能实现的操作

**$access(x)$ : 将根节点到 $x$ 的路径变成实边 (建立一条从根节点到 $x$ 且只能到 $x$ 的实边路径)**

我们需要将根节点到 $x$ 的路径上的边都变成实边, 然后将冲突的边变成虚边, 可以从小到大来操作

首先我们先要从 $x$ 往上找到一条虚边, 由于虚边都存储在 $Splay$ 中根节点的位置, 所以我们需要先将 $x$ 在 $Splay$ 中转到根节点, 此时 $x$ 和 $x$ 的父节点 $p$ 的关系就会对应这条虚边, 此时我们要想将 $(x, p)$ 这条边变成实边, 就要将 $x$ 变成 $p$ 的后继, 所以我们需要先将 $p$ 转到根节点, 由于 $p$ 此时应该是它所在的实边路径中最下面的一个点, 因此 $p$ 被转到根节点之后, 它的右子树应该是空的, 那么我们就只需要将以 $x$ 为根的这个 $Splay$ 插入到 $p$ 的右子树中就行了. 此时我们就将两条实边路径中间的虚边变成了实边, 合并成了一条实边路径, 且它对应的是一个以 $p$ 为根节点的 $Splay$ , 此时 $p$ 和它的父节点之间的边又对应了更上面的一条实边, 我们继续用刚才的方法将两个实边路径合并. 直到合并后的 $Splay$ 的根节点没有父节点为止, 说明已经将整个路径都合并成实边了

在合并过程中, 可能 $x$ 的父节点此时已经存在一条实边, 但是我们并不需要再进行额外的处理, 因为更换实边本身就是一个更换后继的过程, 而我们在合并的时候就是将整个右子树进行了更换, 此时不管它原本时候存在后继, 都已经被我们更换成了新的后继, 此时原本的实边自然就被更换成了新的实边

**$make\_root(x)$ : 将 $x$ 变成整棵树的根节点**

这个操作就比较简单了, 我们可以先用 $access(x)$ 建立一条从根节点到 $x$ 的实边路径, 首先这棵树其实是一棵无向树, 每条边都是无向的, 而对于一条无向路径来说, 我们将整个路径翻转一下并不会影响整棵树的拓扑结构. 由于 $Splay$ 的中序遍历表示的是从上到下的实边路径, 所以此时的中序遍历应该是从根节点到 $x$ , 因此我们可以将 $x$ 转到根节点, 然后将整个路径翻转过来. 翻转之后的终须遍历就变成了 $x$ 到根节点, 转化为实边路径后 $x$ 就变成了最上面的一个点, 也就是整棵树的根节点

**$find\_root(x)$ : 找到 $x$ 所在的实边路径的根节点**

对于 $x$ 所在的实边路径的根节点应该是它对应的 $Splay$ 的中序遍历的最左边的节点, 因此我们首先还是用 $access(x)$ 建立一条从根节点到 $x$ 的实边路径, 然后将 $x$ 旋转到所在 $Splay$ 的根节点, 此时 $x$ 所在实边路径的根节点就是 $x$ 的左子树中的最左边的一个节点, 因此我们从 $x$ 一直往左搜到底就是我们要找的点

而该操作也可以用来判断两个点是否在同一条实边路径中

**$split(x, y)$ : 将 $x$ 到 $y$ 的路径变成一条实边路径**

结合前面的操作就能轻易的实现这一操作, 我们通过 $make\_root(x)$ 将 $x$ 变成整棵树的根节点, 然后就能通过 $access(y)$ 建立一条从 $x$ 到 $y$ 的实边路径

**$link(x, y)$ : 若 $x$ , $y$ 不连通, 则加入 $(x, y)$ 这条边**

我们可以先通过 $make\_root(x)$ 将 $x$ 变成整棵树的根节点, 然后用 $find\_root(y)$ 找一下 $y$ 所在的实边路径的根节点, 如果 $x$ , $y$ 连通, 则 $y$ 所在的实边路径的根节点就是 $x$ , 否则说明不连通, 那么就从 $x$ 向 $y$ 连接一条边 $(x, y)$ , 而 $make\_root(x)$ 不仅会将 $x$ 变成整棵树的根节点, 同时还会将 $x$ 变成所在 $Splay$ 的根节点, 此时其实就是从 $x$ 所在的 $Splay$ 向 $y$ 连一条虚边, 本质上就是将 $x$ 的父节点变成 $y$ 即可

**$cut(x, y)$ : 若 $x$ , $y$ 之间有边, 则删掉该边**

我们先通过 $make\_root(x)$ 将 $x$ 变成整棵树的根节点, 然后通过 $find\_root(y)$ 判断一下 $y$ 所在实边路径的根节点是不是 $x$ , 若是, 说明 $x$ , $y$ 在同一条实边路径中, 而 $find\_root(y)$ 在查找 $y$ 所在实边路径的根节点的同时, 还会将 $y$ 所在实边路径的根节点变成整棵树的根节点, 因此 $y$ 所在实边路径的根节点就应该是 $x$ , 如果 $x$ , $y$ 之间有边, 那就意味着 $y$ 是 $x$ 的后继, 因此我们只需要判断一下 $y$ 是不是 $x$ 的后继, 就能直到 $x$ , $y$ 之间是否有边, 若有边, 将其删去即可, 而只要 $y$ 是 $x$ 的右子节点且 $y$ 不存在左子树, 就意味着 $y$ 是 $x$ 的后继

**$is\_root(x)$ : 判断 $x$ 是不是所在 $Splay$ 的根节点**

判断方法很简单, 只需要判断一下 $x$ 是不是它的父节点的左儿子或者右儿子, 若都不是, 说明 $x$ 和它的父节点之间的边是一条虚边, 此时 $x$ 必然是根节点

以上就是 $Link\_Cut\_Tree$ 版本的动态树所能实现的全部操作, 至于如何维护树中每个节点的信息, 只需要将信息放入 $Splay$ 里面进行维护即可. 另外由于动态树本身需要实现翻转操作, 因此 $Splay$ 本身需要一个 $rev$ 懒标记来记录子节点是否需要翻转

注意: 对于懒标记通常是我们从上往下递归的时候顺便往下传的, 但是在动态树中存在从下往上的操作, 比如我们要进行 $Splay$ 将 $x$ 转上去时, 但是上面的懒标记还没有传下来, 这就会导致结果出错, 为了能将懒标记正确的从上往下传下来, 我们就需要先从 $x$ 遍历到根节点, 然后再从上往下去将所有懒标记传下来, 而这里要用到一个栈来做辅助

---

**维护操作**

> + `0 x y` , 表示询问点 $x$ 到点 $y$ 之间的路径上的所有点(包括两端点)的权值的异或和, 保证 $x$ 和 $y$ 之间存在连通路径
> + `1 x y` , 表示在点 $x$ 和点 $y$ 之间增加一条边 $(x, y)$ . 注意: 如果两点已经处于连通状态, 则无视该操作
> + `2 x y` , 表示删除边 $(x, y)$ . 注意: 如果该边不存在, 则无视该操作
> + `3 x w` , 表示将点 $x$ 的权值修改为 $w$ 

**算法模板**

```c++
struct Node
{
    int s[2], p, v; //子节点、父节点、权值
    int sum, rev; //权值和、记录子节点是否需要翻转（懒标记）
}tr[N]; //Splay
int stk[N]; //辅助栈，用于下传懒标记
int n, m;

void pushrev(int x) //将 x 翻转
{
    swap(tr[x].s[0], tr[x].s[1]);
    tr[x].rev ^= 1;
}
void pushup(int x) //用子节点的信息更新当前节点的信息
{
    tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;
}
void pushdown(int x) //将当前节点的懒标记下传
{
    if(tr[x].rev)
    {
        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]); //将左、右儿子分别翻转
        tr[x].rev = 0; //将当前节点的懒标记清空
    }
}
bool is_root(int x) //判断当前节点是不是根节点
{
    //若当前节点的父节点的左、右儿子都不是当前节点，说明当前节点是根节点
    return tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x;
}
void rotate(int x) //左旋、右旋
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    if(!is_root(y)) tr[z].s[tr[z].s[1] == y] = x; //y 是根节点时不能修改父节点的信息，会导致实边更改
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}
void splay(int x) //将 x 转到所在 Splay 的根节点
{
    //在将 x 转上去之前，先将根节点到 x 的所有懒标记传下去
    int top = 0, r = x;
    stk[++top] = r;
    while(!is_root(r)) stk[++top] = r = tr[r].p;
    while(top) pushdown(stk[top--]);

    //将 x 转到根节点
    while(!is_root(x))
    {
        int y = tr[x].p, z = tr[y].p;
        if(!is_root(y))
        {
            if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
}
void access(int x) //建立一条从 x 到根节点的实边路径，同时将 x 转到所在 Splay 的根节点
{
    int z = x;
    //y 表示当前实边路径的根节点，x 所在的实边路径为当前要合并的实边路径
    for(int y = 0; x; y = x, x = tr[x].p)
    {
        splay(x); //将 x 转到所在 Splay 的根节点
        tr[x].s[1] = y, pushup(x); //将 y 插入 x 的右子树
    }
    splay(z);
}

void make_root(int x) //将 x 变成整棵树的根节点，同时将 x 转到所在 Splay 的根节点
{
    access(x); //建立一条从 x 到根节点的实边路径，同时将 x 转到所在 Splay 的根节点
    pushrev(x); //然后将整棵子树翻转
}
int find_root(int x) //找到 x 所在实边路径的根节点，再将 x 所在实边路径的根节点变成整棵树的根节点
{
    access(x); //建立一条从 x 到根节点的实边路径，同时将 x 转到所在 Splay 的根节点
    while(tr[x].s[0]) pushdown(x), x = tr[x].s[0]; //向左走到底（递归之前一定要下传懒标记）
    splay(x); //将当前的 x 转到所在 Splay 的根节点
    return x;
}
void split(int x, int y) //建立一条从 x 到 y 的实边路径，实边路径对应的 Splay 的根节点是 y
{
    make_root(x); //将 x 变成整棵树的根节点，同时将 x 转到所在 Splay 的根节点
    access(y); //建立一条从 x 到根节点的实边路径，同时将 x 转到所在 Splay 的根节点
}
void link(int x, int y) //如果 x 和 y 不连通，则加入一条 x 和 y 中间的边（虚边）
{
    make_root(x); //将 x 变成整棵树的根节点，同时将 x 转到所在 Splay 的根节点
    if(find_root(y) != x) tr[x].p = y; //如果 x 和 y 不连通，建立虚边
}
void cut(int x, int y) //如果 x 和 y 之间存在边，则删除该边
{
    make_root(x); //将 x 变成整棵树的根节点，同时将 x 转到所在 Splay 的根节点
    //如果 x 和 y 连通，y 是 x 走右子节点且 y 不存在左子树，说明 x 和 y 之间存在边
    if(find_root(y) == x && tr[y].p == x && !tr[y].s[0])
    {
        tr[x].s[1] = tr[y].p = 0; //将边删去
        pushup(x); //更新 x 的信息
    }
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> tr[i].v;

    while(m--)
    {
        int op, x, y;
        cin >> op >> x >> y;
        if(op == 0) //查询 x 到 y 的路径上所有点的异或和
        {
            split(x, y); //建立一条从 x 到 y 的实边路径
            cout << tr[y].sum << endl; //split 后 y 是所在 Splay 的根节点
        }
        else if(op == 1) link(x, y); //在 x 和 y 之间添加一条边
        else if(op == 2) cut(x, y);//将 x 和 y 之间的边删去
        else //将 x 的权值改为 y
        {
            splay(x); //将 x 转到所在 Splay 的根节点
            tr[x].v = y; //将 x 的权值修改为 y
            pushup(x); //更新 x 的信息
        }
    }
}
```



<div style="page-break-after:always;"></div>

# Dancing Links

### Dancing Links 的相关概念

**Dancing Links:** $Dancing \ Links$ 是一种数据结构, 专门能用来解决两种类型的问题, 一种是精确覆盖问题, 一种是重复覆盖问题

由于精确覆盖问题和重复覆盖问题都是 $NP$ 完全问题, 因此极端的时间复杂度都是 $O(2^n)$ , 因此看上去 $n$ 的范围不能太大, 但是实际上通过 $Dancing \ Links$ 优化后 $n$ 的范围可以取到非常大, 甚至可以取到 $10^4$ 的级别. 但是能用 $Dancing \ Links$ 优化的前提是这个矩阵必须是一个稀疏矩阵, 也就是矩阵中 $1$ 的个数必须非常少

对于 $Dancing \ Links$ 能解决的题, 都需要先将题目转化为精确覆盖问题或重复覆盖问题, 然后再用 $Dancing \ Links$ 去做

---

**Dancing Links 的原理**

这里以精确覆盖问题为模型进行原理讲解

首先需要考虑一下如何存储整个矩阵, 由于矩阵中 $1$ 的个数非常少, 因此我们在存储的时候只需要存储 $1$ , 不再存储 $0$ 

这里需要用到十字链表来存储所有的 $1$ , 十字链表每个节点有四个指针, 分别连向上、下、左、右四个方向上的节点, 十字链表的指针是循环的, 一个节点如果左边没有节点, 那么它的指针会指向右边第一个节点, 其他三个指针也同理

我们先对所有 $1$ 的位置建立一个节点, $0$ 的位置就不用建了. 要建立十字链表也非常好建, 十字链表中的第一行和第一列是哨兵(表头), 我们先手动创建第一行的哨兵, 如果一共有 $m$ 列, 那么第一行在创建的时候还要加上第 $0$ 列的哨兵, 因此一共会循环 $m + 1$ 次, 然后再依次将每一行的节点加入到十字链表中. 在插入每一行时, 我们用两个指针 $hh$ , $tt$ 表示该行的两个节点, 然后我们将要插入的节点插入到 $hh$ 和 $tt$ 之间, 最开始时该行没有节点, 所以最开始将 $hh$ , $tt$ 都初始化成当前要插入的这个点, 插入之后我们再更新 $hh$ , $tt$ 的位置让它俩相邻, 以便让下一个点插入到它俩之间, 这样以此类推将每一行的所有节点加入进来

注意, 我们在插入每一行的时候每次都是将当前行插入到第一行的下一行, 也就是哨兵的下面, 因此其实是倒着插入的, 最终除了表头之外第一行是第 $m$ 行, 第二行是第 $m - 1$ 行, 以此类推. 然后同理每一行中我们也都是将每个节点插入到头节点的下一个位置, 因此行也是倒着插入的. 但是记录的编号是正确的, 存储之后的拓扑结构是不变的, 因此不影响最终的结果

建完十字链表之后就需要考虑如何去搜索这个问题, 可以发现我们所选择的行的顺序是没有关系的, 因此我们 $dfs$ 的过程应该是每次从所有没被选择的行中任意地选择一行, 选完之后递归下去处理, 这样一定可以把所有方案都搜到

以上就是 $Dancing \ Links$ 的搜索框架, 非常简单且暴力, 接下来的重点就在于如何去剪枝. 首先第一个剪枝, 我们每次优先选择一个可选择方案最少的一列来看, 如果某一行中只有一个 $1$ , 显然这一行必须要选, 那么我们就可以把这一行选上. 因此我们每次选择 $1$ 的个数最少的列. 假设 $1$ 的个数最少的列中有三个 $1$ , 那么我们必然要从这三行中选择一行出来, 因此接下来我们只需要枚举一下选择这三行中的哪一行, 然后继续递归下去, 这一步就是优化搜索顺序的剪枝

根据以上的搜索顺序每次会有一列满足要求, 也就是恰好有一个 $1$ , 此时这一列我们就不需要再考虑了, 因此我们就需要将这一列删掉. 而当我们选择某一行时, 不只要删除当前我们考虑的这一列, 因为该行中可能不止一个 $1$ , 因此我们要将该行中所有是 $1$ 的列全部删掉, 这样才能保证在接下来的搜索中不会重复选择. 这一步是将不可行的方案及时剪掉, 是可行性剪枝

注意, 在可行性剪枝中删除所有是 $1$ 的列时, 如果是从左到右删除的, 那么在恢复现场的时候一定要从右到左去恢复, 也就是要反着来, 否则在个别的情况下可能会造成死循环

到此我们考虑完了 $dfs$ 过程中需要进行的剪枝, 然后我们需要考虑如何实现 $Dancing \ Links$ 中删除某一列和恢复某一列的操作. 这里在删除的时候有点取巧, 我们在 $dfs$ 中选择 $1$ 的个数最少的列时是枚举第 $0$ 行来选择的, 因此我们在删除的时候只需要将第 $0$ 行中对应这一列的节点删去即可, 这样在枚举选择列的时候就不会枚举到已经有 $1$ 的列了. 而在删除这一列的同时我们还要去枚举这一列是 $1$ 的所有行, 此时这一列已经有 $1$ 了, 那么所有这一列有 $1$ 的行都不能再选了, 因此我们还需要将这些行也都删掉, 而在删掉这些行的时候我们也不需要将整个行删去, 只需要将这些行在列的意义上删去即可, 因为我们选择的时候是先从第 $0$ 行中确定我们的列, 然后再在这一列中纵向去枚举所有的行, 因此我们只需要在纵向意义上将这些行删掉即可, 横向意义上不需要过多的处理, 而保留横向意义的目的也是为了后面方便去恢复它. 至于恢复操作则是和删除操作完全反着来即可

<br>

---

### 精确覆盖问题

**精确覆盖问题:** 给定一个 $01$ 矩阵, 要求从中选出若干行, 使得选出的所有行中每一列恰好包含一个 $1$ (判断是否存在合法解)

**算法模板**

```c++
int n, m;
//l[i] 表示节点 i 的左节点
//r[i] 表示节点 i 的右节点
//u[i] 表示节点 i 的上节点
//d[i] 表示节点 i 的下节点
//s[i] 表示第 i 列中 1 的个数
//row[i] 表示节点 i 所在的行的编号
//col[i] 表示节点 i 所在的列的编号
int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx;
int res[N], top; //存储选择方案

void init() //初始化十字链表
{
    for(int i = 0; i <= m; i++) //初始化第一行的哨兵（表头）
    {
        l[i] = i - 1, r[i] = i + 1;
        u[i] = d[i] = i; //最开始只有一行，所有每个节点的上、下指针都指向自己
    }
    l[0] = m, r[m] = 0; //特别处理左、右边界情况
    idx = m + 1; //已经加入 m + 1 个节点，下标从 m + 1 开始
}

void add(int &hh, int &tt, int x, int y) //将 (x, y) 插入到 hh 和 tt 之间
{
    row[idx] = x, col[idx] = y, s[y]++;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; //纵向：将当前节点插入到表头的下面
    r[hh] = idx, l[tt] = idx, r[idx] = tt, l[idx] = hh; //横向：将当前节点插入 hh 和 tt 的中间
    tt = idx++; //tt 移到当前节点上，保证 hh 和 tt 之间仍是空的，方便后面插入
}

void remove(int p) //删除第 p 列
{
    r[l[p]] = r[p], l[r[p]] = l[p]; //将第 p 列的表头删掉
    for(int i = d[p]; i != p; i = d[i]) //将第 p 列是 1 的所有行删去
        for(int j = r[i]; j != i; j = r[j])
        {
            s[col[j]]--; //更新对应列中 1 的个数
            u[d[j]] = u[j], d[u[j]] = d[j]; //将该行在纵向意义上删去
        }
}

void resume(int p) //恢复第 p 列
{
    //根据删除操作完全反着来即可
    for(int i = u[p]; i != p; i = u[i])
        for(int j = l[i]; j != i; j = l[j])
        {
            u[d[j]] = j, d[u[j]] = j;
            s[col[j]]++;
        }
    r[l[p]] = p, l[r[p]] = p;
}

bool dfs() //dfs 求精确覆盖问题
{
    if(!r[0]) return true; //如果所有列都被删除，说明已经找到答案

    //否则还需要继续搜索，找出 1 的个数最少的列
    int p = r[0]; //记录 1 的个数最少的列的表头
    for(int i = r[0]; i; i = r[i])
        if(s[i] < s[p])
            p = i;

    remove(p); //将这一列删掉

    for(int i = d[p]; i != p; i = d[i]) //枚举当前列选择哪一行
    {
        res[++top] = row[i]; //将当前行加入答案
        for(int j = r[i]; j != i; j = r[j]) remove(col[j]); //将当前行中所有是 1 的列删去
        if(dfs()) return true; //如果当前分支有解，直接回溯
        //否则需要恢复现场
        for(int j = l[i]; j != i; j = l[j]) resume(col[j]); //将当前行中删去的所有列恢复
        top--; //将当前行从答案中移出
    }

    resume(p); //恢复现场

    return false; //到这说明当前分支无解
}

int main()
{
    cin >> n >> m;

    init(); //初始化十字链表

    //依次加入每一行
    for(int i = 1; i <= n; i++)
    {
        int hh = idx, tt = idx;
        for(int j = 1; j <= m; j++)
        {
            int x;
            cin >> x;
            if(x) add(hh, tt, i, j); //只有当前节点是 1 才建出来
        }
    }

    if(dfs()) //如果有解
    {
        for(int i = 1; i <= top; i++)
            cout << res[i] << " \n"[i == top];
    }
    else cout << "No Solution!" << endl;
}
```

<br>

---

### 重复覆盖问题

**重复覆盖问题:** 给定一个 $01$ 矩阵, 要求从中选出若干行, 使得选出的所有行中每一列至少包含一个 $1$ (求集合最少需要包含的行数)

**解题思路**

重复覆盖问题相比于精确覆盖问题就是把每一列对 $1$ 的限制去掉了, 每一列可以包含多个 $1$ , 但是必须有 $1$ 

由于重复覆盖问题中每一列可以存在多个 $1$ , 因此相比于精确覆盖问题能承受的数据范围要更小一些, 而重复覆盖问题不再要求 $1$ 的数量必须少, 但是要求答案不能太大

之所以要求答案不能太大, 是因为重复覆盖问题的方案比精确覆盖问题更多, 因此爆搜的时候一般需要基于 $IDA^*$ 来进行优化, $IDA^*$ 本质上就是一个启发式的迭代加深, 而迭代加深算法要求搜索的层数不能太深, 因此答案不能太大

重复覆盖问题用 $Dancing Links$ 存储节点的方式和精确覆盖问题是一样的, 是都将所有的 $1$ 存入十字链表中

然后就是如何去搜索, 重复覆盖问题的搜索框架和精确覆盖问题也是一样的, 都是选择一个 $1$ 的数量最少的列, 然后用当前列是 $1$ 的所有行来填这一列, 再依次往下递归

在搜索的过程中, 我们如果选择了某一列, 则这一列将会被填上 $1$ , 不用再考虑, 所以需要将这一列删掉, 同时还要将选择好的覆盖这一列的行中所有的 $1$ 对应的列都删掉. 到此都和精确覆盖问题的思路一致, 但是在精确覆盖问题中, 由于每一列只能有一个 $1$ , 因此当我们在删除其他的列时, 会将这些列中所有是 $1$ 的行都删去, 这是因为这一列已经有 $1$ 了, 别的在这一列有 $1$ 的行都不能选, 但是在重复覆盖问题中, 每一列是可以有多个 $1$ 的, 因此在删除每一列时, 我们不用将这一列是 $1$ 的所有行删去, 而是可以保留下来继续选择. 因此在重复覆盖问题中, 我们删除每一列, 只需要将这一列删去即可, 不用讲这一列中所有的行都删掉, 相比于精确覆盖问题少了一层循环

而因为重复覆盖问题比精确覆盖问题少了一层循环, 剪枝的数量比较少, 所以重复覆盖问题在搜索的时候就会比较慢, 因此我们就需要给它加一些其他的优化. 这里就要用到 $IDA^*$ 来进行优化

$IDA^*$ 的核心就是需要一个估价函数, 判断当前情况下最少还需要再走多少步. 对应在重复覆盖问题中就是最少需要选多少行才能让每一列都有 $1$ 

这就用到 $Dancing \ Links$ 非常经典的一个估价函数, 也比较直观, 很容易想出来. 我们从前往后遍历一下当前还没有被覆盖(未被删掉)的所有列, 对于每一列, 我们最终必须要覆盖掉它, 也就是至少要选这一列中的任意一行, 而我们这里直接将所有行都选上, 但是在累加需要选择的行数时, 只累加一行, 最终我们一定能将所有列都覆盖掉, 而且此时累加出的行数一定 $\le$ 真实值. 因此这个估价函数就成立了, 并且实际应用中效果更好

**算法模板**

```c++
int n, m;
//l[i] 表示节点 i 的左节点
//r[i] 表示节点 i 的右节点
//u[i] 表示节点 i 的上节点
//d[i] 表示节点 i 的下节点
//s[i] 表示第 i 列中 1 的个数
//row[i] 表示节点 i 所在的行的编号
//col[i] 表示节点 i 所在的列的编号
int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx;
int res[N]; //记录方案选择的所有行的编号
bool st[M]; //用于计算启发函数

void init() //初始化十字链表
{
    for(int i = 0; i <= m; i++)
    {
        l[i] = i - 1, r[i] = i + 1;
        col[i] = u[i] = d[i] = i;
        s[i] = 0;
    }
    l[0] = m, r[m] = 0;
    idx = m + 1;
}

void add(int &hh, int &tt, int x, int y) //将 (x, y) 加入到 hh 和 tt 之间
{
    row[idx] = x, col[idx] = y, s[y]++;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    r[hh] = idx, l[tt] = idx, r[idx] = tt, l[idx] = hh;
    tt = idx++;
}

int h() //估价函数：至少还要选多少行，使得每一列都有 1
{
    int cnt = 0; //记录最少要选的行数
    memset(st, 0, sizeof st); //清空 st，st 表示当前新覆盖了哪些列
    for(int i = r[0]; i; i = r[i]) //枚举当前还没有被覆盖的列
    {
        if(st[col[i]]) continue; //如果当前列已经被覆盖掉，直接跳过
        cnt++; //否则要选的行数 + 1
        st[col[i]] = true; //记录当前列被覆盖
        for(int j = d[i]; j != i; j = d[j]) //将这一列所有的行都选上
            for(int k = r[j]; k != j; k = r[k]) //将每一行中所有是 1 的列覆盖
                st[col[k]] = true; 
    }
    return cnt;
}

void remove(int p) //将 p 所在的列删掉（将这一列整个删掉但是保留 p，方便恢复）
{
    for(int i = d[p]; i != p; i = d[i])
    {
        r[l[i]] = r[i];
        l[r[i]] = l[i];
    }
}

void resume(int p) //将 p 所在的列恢复
{
    for(int i = u[p]; i != p; i = u[i])
    {
        r[l[i]] = i;
        l[r[i]] = i;
    }
}

bool dfs(int k, int depth) //迭代加深，k 表示当前已经选择的行数，depth 表示最多选择的行数
{
    //如果当前选择的行数 + 最少还要选择的行数 > 最多能选择的行数，说明无解
    if(k + h() > depth) return false;
    if(!r[0]) return true; //如果所有列都已经被覆盖，说明有解

    //否则找到 1 的个数最少的列继续搜索
    int p = r[0];
    for(int i = r[0]; i; i = r[i])
        if(s[i] < s[p])
            p = i;

    //枚举选择的行
    for(int i = d[p]; i != p; i = d[i])
    {
        res[k] = row[i];
        //将当前行中有 1 的列都删掉
        remove(i); //下面的循环删除时删不掉 i 所在的列，这里单独删一下
        for(int j = r[i]; j != i; j = r[j]) remove(j);
        if(dfs(k + 1, depth)) return true;
        //否则将删掉的列恢复
        for(int j = l[i]; j != i; j = l[j]) resume(j);
        //同理恢复时也恢复不到 i，单独恢复一下 i 所在的列
        resume(i);
    }
    return false; //到这说明当前分支无解
}

int main()
{
    cin >> n >> m;

    init(); //初始化十字链表

    //依次加入图中每一行
    for(int i = 1; i <= n; i++)
    {
        int hh = idx, tt = idx;
        for(int j = 1; j <= m; j++)
        {
            int x;
            cin >> x;
            if(x) add(hh, tt, i, j); //如果当前点是 1 就加入十字链表
        }
    }

    //迭代加深
    int depth = 0;
    while(!dfs(0, depth)) depth++;

    cout << depth << endl;
    for(int i = 0; i < depth; i++)
        cout << res[i] << " \n"[i == depth - 1];
}
```



<div style="page-break-after:always;"></div>

# 左偏树

### 左偏树的相关概念

**左偏树:** 左偏树的本质是一个堆的集合, 可以实现堆的操作: 插入、求最小值、删除最小值. 另外它还有一个最重要的操作就是支持合并两个左偏树

**左偏树的原理**

以维护最小值为例

左偏树是通过递归来定义的, 对于左偏树中的每一棵子树, 都满足根节点的权值 $\le$ 它的两个子节点的权值

因此左偏树和堆一样需要维护一个权值信息 $val$ . 除此之外, 左偏树相比于堆还需要额外维护一个信息 $dis$ 表示每个节点到距离它最近的空节点的距离, 每个叶子节点的 $dis$ 为 $1$ 

左偏树对于 $dis$ 还有一个要求, 对于每一棵子树的根节点, 都需要满足它的左儿子的 $dis$ $\ge$ 右儿子的 $dis$ . 这就会导致整棵树的左边会更深一点, 子树会更大一点, 而右边则会更浅一点, 子树也会更小一点, 整棵树是一个向左偏的形状, 因此被称为左偏树

左偏树的所有操作都是和根节点的 $dis$ 成正比的, 而根节点的 $dis$ 是 $O(\log n)$ 级别的, 并且能保证根节点的 $dis \le \log n$ 

<br>

---

### 左偏树能实现的操作

**$merge(a, b)$ : 合并子树 $a$ 和 $b$ , 并返回合并后的根节点**

首先看一下子树 $a$ 和 $b$ , 哪一棵子树的根节点比较小, 我们假设 $a$ 的权值 $\le$ $b$ 的权值

由于 $b$ 的整棵子树的权值都是 $\ge$ $b$ 的权值的, 而 $b$ 的权值 $\ge$ $a$ 的权值, 因此 $b$ 所在的子树的权值都是 $\ge$ $a$ 的权值的. 因此合并完之后根节点应该是 $a$ . 那么 $a$ 就不用动了, 由于每个点的左、右子树之间是没有关系的, 此时 $a$ 的左子树我们也不需要动, 我们将 $a$ 的右子树和 $b$ 所在的子树合并, 这里就是一个递归的过程, 继续递归合并即可, 最终一定会是一个空节点和剩余的子树合并, 此时直接将剩余的子树插入到空节点的位置, 整个合并过程就结束了

然后在合并完后, 由于我们是往右子树进行合并的, 因此右子树的 $dis$ 会改变, 如果右子树的 $dis$ 比左子树大了, 那么我们就将左、右子树交换一下, 保证左偏树的左偏性质. 由于左偏树本质上是一个堆的结构, 因此左、右子树交换一下位置并不会有什么影响

由于每次合并会将 $a$ 所在子树的 $dis$ 或 $b$ 所在子树的 $dis$ 减 $1$ , 因此最多会递归 $dis[a] + dis[b]$ 次, 由于 $dis$ 是 $O(\log n)$ 级别的, 所以合并操作的时间复杂度也是 $O(\log n)$ 级别的

**插入一个数 $x$** 

我们将 $x$ 建成一棵只包含一个点的左偏树, 然后将这个点和原树合并即可

**求最小值**

由于左偏树本质是一个堆, 根节点维护的就是最小值, 因此直接查询根节点即可

**删除最小值**

由于最小值就是根节点的权值, 因此删除最小值就是删除根节点, 如果我们将根节点删除, 那么整棵左偏树就会被拆分成左、右两棵子树, 我们只需要将左、右两棵子树重新合并成一棵左偏树即可, 合并后的新的根节点作为原树的根节点

<br>

---

**维护操作**

> 维护一个小根堆的集合, 初始时集合是空的
>
> 该集合支持如下四种操作:
>
> 1. `1 a` , 在集合中插入一个新堆, 堆中只包含一个数 $a$ 
> 2. `2 x y` , 将第 $x$ 个插入的数和第 $y$ 个插入的数所在的小根堆合并. 数据保证两个数均为被删除, 若两数已在同一堆中, 则忽略此操作
> 3. `3 x` , 输出第 $x$ 个插入的数所在小根堆的最小值. 数据保证该数未被删除
> 4. `4 x` , 删除第 $x$ 个插入的数所在小根堆的最小值 (若最小值不唯一, 则优先删除先插入的数). 数据保证该数未被删除

**算法模板**

```c++
int n;
//v[i] 表示节点 i 的权值
//dist[i] 表示距离节点 i 最近的空节点的距离
//l[i] 表示节点 i 的左儿子
//r[i] 表示节点 i 的右儿子
int v[N], dis[N], l[N], r[N], idx;
int p[N]; //并查集

bool cmp(int x, int y) //判断 x 的权值是否小于 y 的权值，如果权值相等则判断下标
{
    if(v[x] != v[y]) return v[x] < v[y];
    return x < y;
}

int find(int x) //返回 x 所在的集合
{
    if(x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int merge(int x, int y) //将 x 和 y 所在的左偏树合并，并返回合并后的根节点
{
    if(!x || !y) return x + y; //如果 x 或 y 是空节点，直接合成一棵
    if(cmp(y, x)) swap(x, y); //保证 x < y
    //合并后 x 是根节点，继续合并 x 右子树
    r[x] = merge(r[x], y);
    if(dis[l[x]] < dis[r[x]]) swap(l[x], r[x]); //保证 x 的左子树距离 > 右子树距离
    dis[x] = dis[r[x]] + 1; //x 的距离 = 右子树距离 + 1，右子树发生改变，x 的距离也需要更新
    return x; //返回合并后的根节点
}

int main()
{
    cin >> n;

    v[0] = INF; //将 0 节点的权值设为正无穷，用于处理边界情况
    while(n--)
    {
        int op, x, y;
        cin >> op;
        if(op == 1) //插入一个新的左偏树，左偏树中只有一个值 x
        {
            cin >> x;
            v[++idx] = x; //建立左偏树
            dis[idx] = 1; //每个节点的距离最开始是 1
            p[idx] = idx; //建立并查集
        }
        else if(op == 2) //将 x 和 y 所在的左偏树合并
        {
             cin >> x >> y;
             x = find(x), y = find(y);
             if(x != y) //不在同一个左偏树中，需要合并
             {
                 if(cmp(y, x)) swap(x, y); //保证 x < y
                 p[y] = x; //合并后根节点是 x
                 merge(x, y); //合并两个左偏树
             }
        }
        else if(op == 3)
        {
            cin >> x;
            cout << v[find(x)] << endl; //输出 x 所在的左偏树的最小值
        }
        else //删除 x 所在左偏树的最小值
        {
            cin >> x;
            x = find(x);
            if(cmp(r[x], l[x])) swap(r[x], l[x]); //保证 v[l[x]] < v[r[x]]
            //此时 l[x] 是左偏树的新根节点
            p[x] = l[x], p[l[x]] = l[x]; //将当前集合的根节点换成 l[x]
            merge(l[x], r[x]); //合并左、右子树
        }
    }
}
```



<div style="page-break-after:always;"></div>

# 后缀数组

### 后缀数组的相关概念

**后缀数组:** 对于一个长度是 $n$ 的字符串, 存在 $n$ 个不同的后缀, 称第 $i$ 个字符为起点的后缀为第 $i$ 个后缀, 后缀数组能将所有后缀从小到大进行排序

后缀数组有两种实现方法, 分别是倍增法和 $DC3$ , 倍增法的时间复杂度为 $O(n \log n)$ , 但是常数较小, $DC3$ 的时间复杂度为 $O(n)$ , 但是常数较大

后缀数组能处理出几个常用信息, 然后用这些信息来解决问题, $sa_i$ 记录排名第 $i$ 位的是第几个后缀, $rk_i$ 记录第 $i$ 个后缀的排名是多少, $height_i$ 记录第 $as_i$ 个后缀和第 $as_{i - 1}$ 个后缀的最长公共前缀

<br>

---

### 倍增法求后缀数组

**后缀数组的原理**

倍增法的思路就是每次倍增地对某些后缀排序, 直到所有后缀都排好序为止

首先将所有后缀以第一字符为关键字进行排序, 如果某两个后缀的关键字相同, 则相对顺序不变. 这里用基数排序来为所有后缀进行排序, 基数排序能在 $O(n)$ 的时间复杂度之内将所有字符串排序

此时所有后缀都按照第一个字符排好序, 然后再去进行倍增. 假设当前所有后缀已经按照前 $k$ 个字符排好序 (如果某个后缀不足 $k$ 个字符, 则在后面补上空字符, 空字符最小). 现在我们已经考虑了前 $k$ 个字符, 接下来就要考虑前 $2k$ 个字符, 倍增地去考虑

我们将每个后缀的前 $k$ 个字符当作第一关键字, 将每个后缀的第二段 $k$ 个字符当作第二关键字. 然后将所有后缀按照这两个关键字进行排序, 如果第一关键字更大, 则字符串更大. 如果第一关键字相同, 则第二关键字大的字符串更大, 这样就将所有字符串按照前 $2k$ 个字符排序. 而每一轮排序之后我们都会将前 $k$ 个字符进行离散化, 因此第一关键字是一个整数, 而第二个关键字我们也会通过一些处理给它变成一个整数. 由于只有 $n$ 个后缀, 因此离散化后的数是在 $1$ ~ $n$ 的范围内的, 这样的排序同样可以用基数排序来排, 也是 $O(n)$ 的时间复杂度

通过以上思路, 每次考虑的字符数量是倍增的, 因此最多执行 $\log n$ 次, 就可以考虑到 $n$ 个字符, 就能将所有后缀排序. 每次排序是 $O(n)$ 的复杂度, 因此整个的时间复杂度就是 $O(n \log n)$ 

到此, 就是后缀数组的大致思路, 接下来还有一些细节需要考虑. 首先对于基数排序, 它的前提是每个数需要在 $1$ ~ $n$ 以内, 不能比 $n$ 大, 因为基数排序的时间复杂度是和值域有关的, 因此值域不能太大, 所以这里才需要用离散化

基数排序的思路, 先求一下 $1$ ~ $n$ 中每个数 $i$ 出现的次数 $c_i$ , 然后再对每个 $i$ 求一下 $\le i$ 的数的个数 $s_i$ , 显然就是求一个前缀和, 然后我们从前往后依次看每个数 $a_i$ , 如果 $\le a_i$ 的数的个数是 $x$ , 则 $a_i$ 的排名就是 $x$ , 此时第 $x$ 个位置已经有数了, 此时 $\le a_i$ 的数还剩 $x - 1$ 个, 都应该放在 $x$ 的前面, 因此令 $s_{a_i} - 1$ , 然后再依次往后看剩下的每个数 $a_j$ , 根据 $\le a_j$ 的数的个数来确定它的排名, 同时更新 $s$ 数组, 最终就能确定出每个数的排名

这里有一个基数排序的特性, 就是对于 $a_i$ , 我们是根据 $s_{a_i}$ 来确定它的排名, 此时如果存在两个 $a_i$ , 则第二个 $a_i$ 将会排在 $s_{a_i} - 1$ 的位置, 也就是倒着排序. 这会导致排序后相同数之间的相对顺序发生改变, 但是我们后缀数组中要保证相同数之间的相对顺序不变, 这里要想保证不变也很简单, 只需要在基数排序的过程中从后往前依次确定每个数的位置, 这样就会令第二个 $a_i$ 排在后面, 第一个 $a_i$ 排在前面, 保证相同数之间的相对顺序不变

以上就是基数排序单关键字的排法, 而双关键字排序则是类似的, 只需要先将所有后缀按照第二关键字排好序, 再将所有后缀从后往前按照第一关键字排序, 此时既能保证所有后缀都按照双关键字排好序, 又能保证相同后缀之间的相对顺序不变

这里还需要考虑如何将后缀按照第二关键字排序, 可以发现对于第 $i$ 个后缀的第二关键字刚好对应第 $i + k$ 个后缀的第一关键字, 因此对于第 $i$ 个后缀在第二关键字中的排名, 其实就是第 $i + k$ 个后缀在第一关键字中的排名 $-k$ , 直接递推即可. 另外, 第 $n - k + 1$ 个后缀及以后的所有后缀, 长度都是 $\le k$ 的, 因此它们的第二关键字都是补空字符的, 因此它们在第二关键字排序中一定是最小的 $k$ 个后缀, 且相对关系没有变化, 因此这 $k$ 个后缀的排名可以直接得到. 到此就能将所有后缀按照第二关键字排序, 接着再去进行后续处理即可

然后每次排序完之后需要将前 $2k$ 个字符作为下一轮排序的第一关键字进行离散化, 这里的离散化也比较简单, 如果当前后缀的前 $2k$ 个字符和前一个后缀的前 $2k$ 个字符相同, 则离散化后的排名相同, 否则比前一个后缀的排序 $+1$ , 直接枚举处理即可

排序结束的判断依据就是离散化后最后一个后缀的排名是不是 $n$ , 如果是 $n$ 说明已经将 $n$ 个后缀完全区分开了, 则排序结束. 否则一定还存在至少某两个后缀排名相同, 需要继续排序. 这里由于每个后缀的长度各不相同, 因此所有后缀一定不可能相同, 即排名不可能相同

至此我们将所有后缀排好序. 然后还需要预处理出 $height$ 数组. $height_i$ 表示排名为第 $i$ 的后缀和排名第 $i - 1$ 的后缀的最长公共前缀

我们设 $lcp(i, j)$ 表示排名第 $i$ 的后缀和排名第 $j$ 的后缀的最长公共前缀

首先两个后缀的最长公共前缀和两个后缀的顺序是无关的, 因此 $lcp(i, j) = lcp(j, i)$ , 并且 $lcp(i, i) = len(i)$ . 除此以外, 还有一个关键的性质, $lcp(i, j) = min(lcp(i, k), lcp(k, j))$ , $k \in [i, j]$ 

利用这个性质我们就能将任意的 $lcp(i, j)$ 进行拆分, 即 $lcp(i, j) = min\{lcp(i, i + 1), lcp(i + 1, i + 2), \dots, lcp(j - 1, j) \}$ 

此时, $height_i$ 其实就是 $lcp(i - 1, i)$ . 接下来就要考虑如何求 $lcp(i - 1, i)$ 

这里还要用另一个重要的性质, 设 $h_i = height_{rk_i}$ , 即第 $i$ 个后缀和排名在它前面一位的后缀的最长公共前缀. 这里的性质就是 $h_i \ge h_{i - 1} - 1$ 

有了这个性质之后就可以有一个 $O(n)$ 的做法. 我们可以从前往后枚举每个后缀, 假设现在已经求完了 $h_{i - 1}$ , 那么对于 $h_i$ , 由于 $h_i \ge h_{i - 1} - 1$ , 所以我们不用从第一个字符开始枚举来求 $h_i$ , 我们可以直接从第 $h_{i - 1} - 1$ 个字符开始枚举. 这样就会保证我们枚举的数量是非常有限的, 只有 $O(n)$ 的级别

**算法模板**

```c++
int n, m; //字符串长度、不同字符数量
string s;
//sa[i] 表示排名第 i 的是第几个后缀
//x[i] 表示第 i 个后缀的第一关键字
//y[i] 表示第 i 个后缀的第二关键字
//c[i] 表示关键字为 i 的数的个数
//rk[i] 表示第 i 个后缀的排名
//height[i] 表示排名第 i 的后缀和排名第 i - 1 的后缀的最长公共前缀
int sa[N], x[N], y[N], c[N], rk[N], height[N];

void get_sa() //预处理 sa
{
    //将所有后缀按照首字母从小到大排序（基数排序）
    for(int i = 1; i <= n; i++) c[x[i] = s[i]]++; //记录每个关键字出现的次数
    for(int i = 2; i <= m; i++) c[i] += c[i - 1]; //求前缀和
    for(int i = n; i >= 1; i--) sa[c[x[i]]--] = i; //为每个数安排位置

    //每一轮将后缀按照前 2k 个字符排序
    for(int k = 1; k <= n; k <<= 1)
    {
        //先将所有后缀按照第二关键字排序
        int num = 0;
        for(int i = n - k + 1; i <= n; i++) y[++num] = i;
        for(int i = 1; i <= n; i++)
            if(sa[i] > k)
                y[++num] = sa[i] - k;

        //再将所有后缀按照第一关键字排序（基数排序）
        for(int i = 1; i <= m; i++) c[i] = 0;
        for(int i = 1; i <= n; i++) c[x[i]]++;
        for(int i = 2; i <= m; i++) c[i] += c[i - 1];
        for(int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i], y[i] = 0; //y 数组清空，用于后面存储当前的第一关键字

        //将排序后的所有后缀再按照前 2k 个字符离散化
        swap(x, y);
        x[sa[1]] = 1, num = 1;
        for(int i = 2; i <= n; i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;

        if(num == n) break; //如果 n 个后缀的排名都不同，说明已经排好序
        m = num; //更新不同字符的个数
    }
}

void get_height() //预处理 height
{
    for(int i = 1; i <= n; i++) rk[sa[i]] = i; //预处理 rk
    //预处理 height
    for(int i = 1, k = 0; i <= n; i++) //k 记录当前的 h[i]
    {
        if(rk[i] == 1) continue; //height[1] 默认为 0
        if(k) k--; //应该从 h[i - 1] - 1 开始枚举，也就是 k - 1
        int j = sa[rk[i] - 1]; //记录第 i 个后缀前一个排名的后缀
        //如果 i 和 j 的第 k 位相同，则最长公共前缀长度 + 1
        while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
        height[rk[i]] = k; //height[rk[i]] = k
    }
}

int main()
{
    cin >> s;
    s = " " + s;

    n = s.size() - 1, m = 122; //最大字符 'z' 的 ASCII 码是 122
    get_sa(); //预处理 sa
    get_height(); //预处理 height

    for(int i = 1; i <= n; i++) 
    	cout << sa[i] << " \n"[i == n];
    for(int i = 1; i <= n; i++) 
        cout << height[i] << " \n"[i == n];
}
```



<div style="page-break-after:always;"></div>

# 后缀自动机

### 后缀自动机的相关概念

**后缀自动机:** 后缀自动机是用来存储某一字符串的所有字串的一个有限状态自动机. 如果我们想把一个字符串的所有字串存下来, 就可以用后缀自动机, 而后缀自动机则恰好可以将一个字符串的所有字串存储起来. 自动机简成为 $DFA$ , 一个自动机会有一个源点和若干个终点. 后缀自动机简称 $SAM$ 

$DFA$ 可以看作一个有向无环图, 类比于 $Trie$ 字典树. 这里给出一张 $SAM$ 的例图

![后缀自动机](E:\个人博客\博客内容\算法竞赛\进阶算法\数据结构\后缀自动机.png)

**后缀自动机的性质:** 

1. $SAM$ 是个状态机, 一个起点, 若干个终点, 原串的所有子串和从 $SAM$ 起点开始的所有路径一一对应, 不重不漏. 所有终点就是包含后缀的点
2. 每个点包含若干个字串, 每个字串都一一对应一条从起点到该点的路径, 且这些子串一定是里面最长的子串的连续后缀
3. $SAM$ 问题中经常考虑两种边:
   1. 普通边, 类似于 $Trie$ , 表示在某个状态所表示的所有子串的后面添加一个字符
   2. $Link$ , $Father$ , 表示从某个状态的终点向该状态所表示的最短子串的首字母删去后的字符串对应的状态的终点连边, 这类边构成一棵树

可以发现普通边是在后面加上一个字母, $Link$ , $Father$ 是在前面删掉一个字母

<br>

---

### 后缀自动机的构造

**后缀自动机的构造思路:**

我们定义一个函数 $endpos(s)$ , 表示子串 $s$ 所有出现位置 (尾字母下标) 的集合. 对于所有子串, 可能存在某些子串的 $endpos$ 的集合是完全相同的, 我们称这些子串为一个 $endpos$ 的等价类. 最终所有 $endpos$ 的等价类就是原图里的每个状态. 我们将每个等价类表示成一个状态, 我们就可以通过构造得到一个满足以上三个性质的后缀自动机

首先看一下 $endpos$ 等价类满足的性质:

1. 令 $s_1$ , $s_2$ 为 $S$ 的两个子串, 不妨设 $|s_1| \le |s_2|$ (我们用 $|s|$ 表示 $s$ 的长度, 此时等价于 $s_1$ 不长于 $s_2$) , 则 $s_1$ 是 $s_2$ 的后缀当且仅当 $endpos(s_1) \supseteq endpos(s_2)$ , $s_1$ 不是 $s_2$ 的后缀当且仅当 $endpos(s_1) \cap endpos(s_2) = \emptyset$​ 
2. 两个不同子串的 $endpos$ , 要么有包含关系, 要么没有交集
3. 两个子串的 $endpos$ 相同, 那么短串为长串的后缀
4. 对于一个状态 $st$ (等价类), 以及任意的 $longest(st)$ 的后缀 $s$ , 如果 $s$ 的长度满足 $|shortest(st)| \le |s| \le |longest(st)|$ , 那么 $s \in substrings(st)$ 

此时我们知道, 对于某一个等价类中包含的所有子串都一定是最长串的连续后缀, 从前面的图中以 $endpos(x) = 4$ 的等价类为例, 等价类中有 $aabb$ , $abb$ , $bb$ , 而更短的后缀 $b$ 就不再属于 $4$ 这个等价类了, 因为 $b$ 可能会在其他 $4$ 以外的地方出现过, 因此再短的话它的 $endpos$ 中可能会出现一些新的位置, 因此再短的后缀就会变成一个新的状态, 新的状态里面存的字符串也一定是新串的若干连续后缀, 再变短又会变成新的状态, 新的状态又包含更短的若干连续后缀, 以此类推. 此时对于一个子串的连续后缀来看, 第一段属于第一个状态, 小到某个程度从第二段开始就属于第二个状态, 再小到某个程度从第三段开始就属于第三个状态, 以此类推. 此时 $Link$ , $Father$ 这类的边其实就是每个状态连向下一个状态的边. 这就是这类边的意义

而普通边, 就是某个状态中的每个后缀后面都加上一个字母, 变成一个新的状态, 这就是普通边的意义. 可以发现两类边其实都是连接不同的状态之间的边

$SAM$ 可以处理一些问题

对于如何求不同子串的数量, 由于后缀自动机中从起点开始的每一条路径和原串的每一个子串是一一对应的关系, 而且不同路径对应不同子串, 没有重复, 因此不同点之间表示的串一定是没有任何交集的, 因此不同子串的集合就一定是不同点所表示的字符串的并集, 我们只要能求出每个点所表示的字符串的数量, 就能求出不同子串的数量. 那么怎么求每个点所表示的字符串的数量呢, 根据前面 $endpos$ 的性质 $4$ , 对于每个点所对应的字符串, 我们找出最长的子串和最短的子串, 它们之间的所有字符串就是该点的所有字符串, 若最长字符串长度为 $a$ , 最短字符串长度为 $b$ , 那么该点的字符串数量就是 $a - b + 1$ . 而每个点的最长串和最短串是可以在构造后缀自动机的过程中顺带进行维护的. 而我们其实只需要维护最长串即可, 由于所有的等价类合在一起是连续的后缀, 因此对于想要求当前点的最短串, 只需要找到当前点的 $Link$ , $Father$ 边连向的下一个等价类的最长串 $c$ , 此时当前点的最短串就是 $a - c + 1$ 

对于如何求每个子串出现的次数, 假设要求子串 $s$ 出现的次数, 其实就是求 $|endpos(s)|$ , 这里我们对于某一个等价类, 我们去看一下连向他的 $Link$ , $Father$ 边的等价类, 这些等价类对应的串去掉首字母其实就是当前等价类对应的串, 而根据前面的性质, 我们知道这些等价类之间是相互没有交集的, 因此这些等价类一定能拼在一起凑成当前等价类的一部分, 但是并不能完全凑成当前等价类, 因为如果当前等价类中的某些串并不能在前面加上一个字符, 那么就不存在指向它的等价类, 也就没有拼凑出它, 而不能在前面加上字符的字符串只可能是某一个前缀, 因此当前等价类中的字符串数量也就是 $|endpos(s)|$ 就等于所有指向它的等价类的 $endpos$ 的数量之和再加上当前等价类中的前缀数量. 这是一个递推出结果的过程. 这里注意, 由于不同前缀的终点一定是不一样的, 因此不同前缀一定属于不同的等价类, 而且每一个等价类中最多只会有一个前缀, 因此只需要在递推之前将所有有前缀的等价类加上一个 $1$ , 然后再去递推即可

而要想找一下某一个子串在哪个等价类中, 只需要跟 $Trie$ 字典树一样从源点往下一个字母一个一个字母地走即可, 最终走到的位置所在的点就是所在的等价类

<br>

**后缀自动机的构造过程:**

构造的过程是一个增量式的加入的过程

假设最开始自动机是空的, 只有一个源点, 源点表示空串, 每次添加一个字符到自动机中, 然后维护一遍, 然后再添加下一个字符, 再维护一遍, 直到加入所有的字符为止

对于每次要插入的字符 $c$ , 都要分情况来讨论, 对于自动机中的每个状态我们需要维护一些信息, 当前状态中所有子串的最大长度 $len$ , 当前状态 $Link$ 边指向的状态 $fa$ , 当前状态后面加上字符 $i$ 变成的新状态 $ch_i$ 

我们设上一个插入的状态是 $p$ , 当前插入的状态是 $np$ , 此时显然 $np$ 的最大子串长度就是 $p$ 的最大子串长度 $+1$ , 然后由于 $p$ 的后面加上了 $c$ , 因此 $p$ 去掉首字母的状态后面也应该加上 $c$ , 因此将 $p$ 的 $Link$ 边指向的状态后面也加上 $c$ , 以此类推, 需要将沿着 $Link$ 边往后走到的所有状态后面都加上 $c$ 

如果中间某一个状态 $sq$ 后面已经有 $c$ 了, 假设状态 $sq$ 加上 $c$ 后是状态 $q$ , 那么此时状态 $q$ 应该属于一个新的等价类, 因此 $np$ 的 $Link$ 边应该指向 $q$ , 如果 $q$ 的长度是 $sq$ 的长度 $+1$ , 则我们直接令 $np$ 的 $Link$ 边直接指向 $q$ . 但是如果 $q$ 的长度不是 $sq$ 的长度 $+1$ , 则说明 $q$ 并不是跟着 $sq$ 后面的状态, 因此我们需要复制一个真正跟着 $sq$ 后面的状态 $nq$ , 我们令 $nq$ 的长度是 $sq$ 的长度 $+1$ , 此时 $nq$ 就跟在 $sq$ 后面了, 此时我们令 $q$ , $np$ 的 $Link$ 边都指向 $nq$ , 然后要将 $sq$ 后面所有的状态的 $c$ 边如果指向 $q$ , 一律都改成指向 $nq$ , 到此字符 $c$ 就添加完毕. 再用同样的方式继续添加后续字符即可

注意, 后缀自动机构造的时候需要用到两倍的点, 因此空间需要开两倍

<br>

**后缀自动机的时间复杂度:**

后缀自动机的状态数量不会超过 $O(2n)$ , 自动机内转移的数量不会超过 $O(3n)$ , 而后缀自动机的时间复杂度就和状态数量、转移数量有关, 因此后缀自动机的时间复杂度是 $O(n)$ 

**算法模板**

```c++
int tot = 1, last = 1; //tot 表示当前用到的编号，last 表示上一个点的编号，1 号点是源点（空节点）

struct Node
{
    int len, fa; //len 表示当前状态中所有子串的最大长度，fa 表示 Link 边指向的状态
    int ch[26]; //ch[i] 指向当前状态后面加上字符 i 变成的状态
}node[N]; //存储后缀自动机的每个状态
char str[N]; //原字符串
LL f[N]; //f[i] 表示后缀自动机中状态 i 的 endpos 大小
int h[N], e[N], ne[N], idx; //邻接表，用于存储所有 Link 边的反向边，便于求每个状态的 endpos 的大小

void extend(int c) //将字符 c 加入后缀自动机
{
    //p 表示上一个插入的状态，np 表示当前插入的新状态
    int p = last, np = last = ++tot;
    //依次加入每个点，则每次插入得到的新状态都是一个前缀，递推时无法记录前缀，这里提前算上每个前缀在 endpos 中的贡献
    f[tot] = 1;
    node[np].len = node[p].len + 1; //新状态的长度 = 旧状态的长度 + 1
    //p 的末尾加上了 c，则 p 沿着 Link 边往下走到的所有状态后面也应该都加上 c
    for(; p && !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;
    if(!p) node[np].fa = 1; //如果 p 沿着 Link 边走到的所有状态后面都没有 c，则新状态 np 的 Link 边指向源点
    else
    {
        //否则说明从当前 p 开始沿着 Link 边走到的所有状态后面都有 c，此时当前的 p 加上 c 后的状态就是一个新的等价类
        //新状态 np 的 Link 应该指向当前的 p 加上 c 后的状态 q
        int q = node[p].ch[c];
        //如果 q 的长度正好是 p 的长度 + 1，则 np 的 Link 边直接指向 q
        if(node[q].len == node[p].len + 1) node[np].fa = q;
        else
        {
            //否则需要拷贝一个长度是 p 的长度 + 1 的新的状态，再令 q 和 np 的 Link 边指向拷贝后的状态 nq
            int nq = ++tot;
            node[nq] = node[q], node[nq].len = node[p].len + 1; //拷贝并修改长度
            node[q].fa = node[np].fa = nq; //令 q 和 np 的 Link 边指向 nq
            for(; p && node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq; //再将指向 q 的所有普通边改成指向 nq
        }
    }
}

void add(int a, int b) //添加边
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs(int u) //从源点递推所有状态的 endpos 的大小
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        dfs(j); //继续往下递推
        f[u] += f[j]; //更新当前状态的 endpos 大小
    }
}

int main()
{
    scanf("%s", str);

    for(int i = 0; str[i]; i++) extend(str[i] - 'a'); //将每个字符依次加入后缀自动机

    memset(h, -1, sizeof h); //初始化邻接表
    //从每个状态的 Link 边指向的状态向当前状态连一条反向边
    for(int i = 2; i <= tot; i++) add(node[i].fa, i);

    dfs(1); //从源点递推所有状态的 endpos 的大小
}
```



<div style="page-break-after:always;"></div>

# 点分治

### 点分治的相关概念

**点分治:** 点分治是一种树上分治的算法. 核心思路就是对于每个点上的问题, 就所有问题分成两大类, 一大类是该点连接的每个子树内部的问题, 这一类问题可以递归处理每棵子树; 一大类是这些子树之间的问题, 这一类问题可以归并处理

**边分治:** 边分治也是一种树上分治的算法. 核心思路就是对于每条边上的问题, 将所有问题分成两大类, 一大类是该边连接的两棵子树内部的问题, 这一类问题可以递归处理; 一大类是连接的两棵子树之间的问题, 这一类问题可以归并处理

对于树上分治问题, 一般用点分治居多, 因为边分治算法在处理菊花图时的时间复杂度会降到 $O(n^2)$ , 并不能保证永远是 $O(n \log n)$ 的效率. 而点分治则可以保证永远是 $O(n \log n)$ 的时间复杂度

---

### 点分治的时间复杂度证明

点分治是按照每个点的子树依次递归下去的. 对于一棵树, 我们可以保证将它的重心删去之后剩余所有子树的最大节点数一定不超过 $\dfrac{n}{2}$ 

我们这里可以用反证法, 假设对于树的某一个重心 $u$ , 删掉之后存在某一棵以 $v$ 为根的子树的节点数 $k > \dfrac{n}{2}$ . 此时我们尝试将 $v$ 变成重心, 那么将 $v$ 删去, 则 $u$ 所在的子树的大小就应该是 $n - k$ , 由于 $k > \dfrac{n}{2}$ , 所以 $n - k < \dfrac{n}{2} < k$ , 而 $v$ 的另一边的每棵子树的节点数也一定不超过 $k - 1$ , 那么此时 $v$ 作为重心每个子树的大小都 $< k$ , 显然这就与 $u$ 是重心矛盾了. 由此得证, 我们把重心删完之后剩余所有子树的大小都 $\le \dfrac{n}{2}$ 

而由于点分治是每次往子树递归处理, 因此点分治的时间复杂度应该和它的递归的层数有关, 上面我们证明了如果将重心作为根节点, 则每个子树的大小都 $\le \dfrac{n}{2}$ , 因此我们只要每次选择当前子树的重心往下递归, 则每次往下一层节点数都会至少减半, 这样递归的层数最多只有 $\log n$ 层, 所以时间复杂度为 $O(n \log n)$ 

---

### 点分治的思想

通过上述时间复杂度的证明, 我们也能基本得出点分治的核心思想

最开始从整棵树开始做, 对于整棵树求一下重心是什么, 然后将问题转化成若干个子问题和一个归并的问题, 然后我们递归解决若干个子问题, 然后再解决合并的问题, 就能将整个问题解决. 这就是点分治的核心思想

---

### 点分治的应用

> **[男人八题]**
>
> 给定一棵有 $N$ 个点 (编号 $0, 1, \dots, N - 1$) 的树, 每条边都有一个权值 (不超过 $100$)
>
> 树上两个节点 $x$ 和 $y$ 之间的路径长度就是路径上各条边的权值之和
>
> 求长度不超过 $K$ 的路径有多少条

> 整个点分治算法的过程就是:
>
> 1. 任选一个根节点 $p$ 
> 2. 从 $p$ 出发进行一次 $dfs$​ , 求出 `d[]` 数组和 `b[]` 数组
> 3. 执行 $Calc(p)$ 
> 4. 删除根节点 $p$ , 对 $p$ 的每棵子树(看作无根树)递归执行 $1$ ~ $4$ 步
>
> 在分治的过程中, 每一层的所有递归过程合计对每个节点处理 $1$ 次, 因此若递归最深达到第 $T$ 层, 则整个算法的时间复杂度就是 $O(TN \log N)$ 
>
> 如果问题中的树是一条链, 最坏情况下每次都以链的一端为根, 那么点分治将需要递归 $N$ 层, 时间复杂度退化到 $O(N^2 \log N)$ . 为了避免这种情况, 可以每次选择树的重心作为根节点 $p$ , 此时 $p$ 的每棵子树的大小都不会超过整棵树的大小的一般, 点分治最多只会递归 $O(\log n)$ 层, 整个算法的时间复杂度为 $O(N \log^2 N)$ 

```c++
int n, k;
int h[N], e[M], w[M], ne[M], idx; //邻接表
//a[] 按照d值将所有节点从小到大排序
//d[i] 表示第i个节点到根节点的距离
//b[i] 表示第i个节点属于根节点的哪一棵子树
//cnt[i] 表示[L + 1, R]中属于根节点的第i棵子树的节点个数
//sizes[i] 表示以第i个节点为根节点的子树中的节点个数
int d[N], b[N], cnt[N], sizes[N], a[N], acnt;
int root; //表示根节点(每次将树的重心作为根节点)
int res; //全局答案
int max_size; //连通块中节点个数的最大值
//st[] 记录每个点是否被删除，true 表示已被删除，false 表示未被删除
bool st[N];

void add(int a, int b, int c) //添加边
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

bool cmp(int a, int b) //比较函数：所有节点按照d值从小到大排序
{
    return d[a] < d[b];
}

void dfs_find(int S, int u, int father) //dfs找重心
{
    sizes[u] = 1; //当前以u为根节点子树中只发现了u自己

    int maxs = 0; //记录删除u节点后，剩余连通块中节点个数的最大值
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(st[j] || j == father) continue; //如果走到父节点(不能往回走)，或已经被删除，直接跳过

        dfs_find(S, j, u); //搜索子节点
        maxs = max(maxs, sizes[j]); //用子节点所在的连通块更新节点个数的最大值
        sizes[u] += sizes[j]; //更新以u节点为根节点子树的节点个数
    }

    maxs = max(maxs, S - sizes[u]); //用u节点上面部分的连通块更新节点个数的最大值
    if(maxs < max_size) //如果去掉u节点后剩余连通块的节点个数最大值更小
    {
        max_size = maxs; //更新节点个数最大值
        root = u; //更新树的重心
    }
}

void dfs(int u, int father)
{
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(st[j] || j == father) continue; //如果走到父节点(不能往回走)，或已经被删除，直接跳过

        b[j] = b[u]; //每个子节点属于父节点所在的子树
        a[++acnt] = j; //将子节点加入a[]数组
        cnt[b[j]]++; //父节点所在的子树中的节点个数+1

        d[j] = d[u] + w[i]; //更新子节点到根节点的距离
        dfs(j, u); //继续搜索子节点
    }
}

void work(int S, int u, int father) //S 表示当前树中节点个数，u表示当前节点
{
    max_size = S; //节点数最多只有S个
    root = u;
    dfs_find(S, u, father); //找出当前树的重心作为根节点

    //重置数组
    memset(d, 0, sizeof d);
    memset(cnt, 0, sizeof cnt);

    acnt = 0; //清空a[]数组
    b[root] = root; //root属于自己这颗子树
    a[++acnt] = root; //将root加入a[]数组
    st[root] = true; //将root从原树中删去

    cnt[root]++; //root属于自己这颗子树，a[]数组中属于以root为根节点的子树的节点个数+1
    for(int i = h[root]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(st[j] || j == father) continue; //如果走到父节点(不能往回走)，或已经被删除，直接跳过

        b[j] = j; //j节点是root的子节点，因此j属于root的以j为根节点的子树
        a[++acnt] = j; //将j节点加入a[]数组
        cnt[j]++; //以j为根节点的子树的节点个数+1

        d[j] = w[i]; //j节点到root的距离就是它们之间的边权
        dfs(j, root); //搜索j节点的所有子节点，并将它们加入a[]数组
    }

    sort(a + 1, a + 1 + acnt, cmp); //将所有节点按照d值从小到大排序

    int l = 1, r = acnt; //l, r指针
    while(l < r) //双指针
    {
        cnt[b[a[l]]]--; //cnt[] 维护的是[l + 1, r]之间所有子树的节点个数，需要将l指针指向的节点去掉
        while(d[a[l]] + d[a[r]] > k) //找到最大的r，使得d[l] + d[r] <= k
        {
            cnt[b[a[r]]]--; //将r指针指向的节点去掉
            r--; //r指针左移
        }

        res += r - l - cnt[b[a[l]]]; //累加所有符合的点对数量

        l++; //l指针右移
    }

    for(int i = h[root]; i != -1; i = ne[i]) //枚举当前根节点的所有子节点
    {
        int j = e[i];
        if(st[j]) continue; //如果当前子节点已经被删除，直接跳过

        work(sizes[j], j, root); //否则递归搜索子节点中符合要求的点对
    }
}

int main()
{
    cin >> n >> k;
    memset(h, -1, sizeof h); //初始化邻接表
    for(int i = 0; i < n - 1; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c); //无向边
    }

    work(n, 1, -1); //点分治
    cout << res << endl;
}
```



<div style="page-break-after:always;"></div>

# CDQ 分治

### CDQ 分治的相关概念

**CDQ 分治:** CDQ 分治可以快速的解决一类问题: 给定 $n$ 个元素, 第 $i$ 个元素有 $a_i$ , $b_i$ , $c_i$ 三个属性. 对于每个 $i$ , 求满足 $a_j \le a_i$ , $b_j \le b_i$ , $c_j \le c_i$ , $j \ne i$ 的 $j$ 的数量. 这种问题也被称为三维偏序问题

对于所有可以用 CDQ 分治解决的问题, 都是将原问题转化成上述的三维偏序问题

<br>

##### CDQ 分治的思想

> 先考虑简化版的问题, 再依次扩展到三维

> 对于一维问题, 就是对于每个 $i$ , 找出有多少个不同的 $j$ 满足 $a_j \le a_i$ , $j \ne i$ 
>
> 对于一维版本只需要将所有的元素按照 $a$ 为第一关键字从小到大排序, 对于每个元素 $a_i$ 来说, 所有 $< a_i$  的数全部在 $a_i$ 的左边. 因此一共会有 $i - 1$ 个 $j$ 满足 $a_j \le a_i$ 

> 然后考虑二维版本, 二维版本就是再加上一个 $b_j \le b_i$ 的条件. 二维的做法很多, 一种做法就是将所有元素按 $a$ 为第一关键字, $b$ 为第二关键字从小到大排序. 此时对于每个元素 $a_i$ , 所有满足 $a_j \le a_i$ , $b_j \le b_i$ 的元素一定在 $a_i$ 的前面, 但不代表前面所有的元素都满足条件, 因此可以从前往后扫描一遍, 首先前面的元素一定满足 $a_j \le a_i$ , 所以只需要找一下前面有多少个 $j$ , 满足 $b_j \le b_i$ . 这里可以用很多方法求, 一种比较简单的方法是树状数组, 可以先将 $b$ 数组离散化, 然后从前往后枚举, 对于 $i$ 求一下 $1$ ~ $b_i$ 中出现了多少个数, 就是满足条件的 $j$ 的数量, 然后将 $b_i$ 也加入树状数组
>
> 除了树状数组以外, 也可以用分治来求二位版本. 第一步还是将所有元素按照双关键字排序, 这里双关键字排序的作用是保证对于每个 $i$ , 满足要求的元素一定在前面, 不可能出现在后面. 然后同样是要求对于每个 $i$ , 前面有多少个 $b_j \le b_i$ , 此时区间中所有满足要求的 $i$ , $j$ 对有三种情况, 一种是 $i$ 和 $j$ 都在左半边, 一种是 $i$ 和 $j$ 都在右半边, 一种是 $i$ 和 $j$ 一个在左半边一个在右半边. 由于已经将所有元素按照双关键字排好序, 因此此时所有满足条件的 $i$ , $j$ 对都已经是 $j$ 在 $i$ 的左边. 对于情况一, 可以递归到左区间处理, 对于情况二, 可以递归到右区间处理. 对于情况三, 由于一定是 $j$ 在左, $i$ 在右, 而此时左边的元素的 $a$ 都一定 $\le $ 右边的元素的 $a$ , 因此只需要对于右半边的每个 $i$ 求一下左半边有多少个 $j$ 是满足 $b_j \le b_i$ . 可以可以用归并的思想, 在递归的过程中用归并将所有元素按照 $b$ 来排序, 此时对于当前区间, 左半区间和右半区间就已经各自排好序了, 那么此时对于每个 $i$ 要想求有多少个 $j$ 满足 $b_j \le b_i$ , 就可以用双指针扫描来求, 每次 $i$ 向后移动一格, 然后将 $j$ 向后移动找到第一个 $b_j > b_i$ 的位置, 此时满足 $b_j \le b_i$ 的 $j$ 就有 $j - 1$ 个. 由于两个区间都各自有序, 因此 $i$ 递增之后, $j$ 也一定是递增的, 可以直接扫描

> 最后考虑三维版本, 此时需要满足 $a_j \le a_i$ , $b_j \le b_i$ , $c_j \le c_i$ 三个条件. 这里同样可以用类似上面的做法, 将所有元素按照三关键字从小到大排序, 此时同样保证对于每个 $i$ , 所有满足要求的 $j$ 一定在 $i$ 的左边. 第二维用分治的思想来处理, 将所有满足要求的 $i$ , $j$ 对分成三大类, 第一类是 $i$ , $j$ 都在左半边, 第二类是 $i$ , $j$ 都在右半边, 第三类是 $j$ 在左半边, $i$ 在右半边. 第一类和第二类都可以用递归来求, 只需要考虑第三类. 首先因为按照三关键字排序, 所有左侧任意元素 $a_j$ 一定 $\le$ 右侧任意元素 $a_i$ , 然后只需要考虑后面两个条件. 对于 $b_j \le b_i$ , 可以用二维的方法, 在归并的过程中将所有元素按照 $b$ 重新排序, 此时对于右侧任意一个 $i$ , 要求出左侧有多少个 $j$ 满足 $b_j \le b_i$ , $c_j \le c_i$ , $b$ 的限制可以用双指针来解决. 对于每个 $i$ 都能用双指针线性的找到第一个 $b_j > b_i$ 的位置 $j$ , 此时 $1$ ~ $j - 1$ 中的元素都一定满足 $b$ 的限制, 然后需要在 $1$ ~ $j - 1$ 中找到满足 $c$ 限制的数的个数. 这里就可以用到二位版本的第一个做法, 用树状数组来求, 将 $c$ 数组离散化, 此时从前往后对每个 $i$ 来说, $\le c_i$ 的数的个数就相当于 $1$ ~ $c_i$ 中出现的数的个数, 而每次 $j$ 往后移动一位, 就向树状数组中加入一个数

> 至此, 就将三维偏序问题解决了, 第一维通过三关键字排序自然满足, 第二维通过双指针来求, 第三位通过树状数组来求, 整个的时间复杂度是 $n \ log^2 {n}$ 

<br>

##### 算法模板

```c++
struct Data
{
    //a, b, c 表示权值, s 表示当前元素出现的此时, res 表示和当前元素配对的数的个数
    int a, b, c, s, res;
    
    bool operator< (const Data &t) const	//三关键字排序
    {
        if(a != t.a) return a < t.a;
        if(b != t.b) return b < t.b;
        return c < t.c;
    }
    bool operator == (const Data &t) const 	//重载等号
    {
        return a == t.a && b == t.b && c == t.c;
    }
}q[N], w[N];	//q 存储所有三维元素, w 为归并排序的辅助数组

int tr[M];	//树状数组

int lowbit (int x)
{
    return x & -x;
}

void add (int x, int c)	//树状数组第 x 个数加上 c
{
    for(int i = x; i < M; i += lowbit(i))
        tr[i] += c;
}

int sum (int x)	//树状数组求前 x 个数的前缀和
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

void merge_sort (int l, int r)	//将所有元素按第二关键字归并排序
{
    if(l >= r) return;
    
    int mid = l + r >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    
    int i = l, j = mid + 1, k = 0;
    while(i <= mid && j <= r)
        if(q[i].b <= q[j].b) add(q[i].c, q[i].s), w[k ++] = q[i ++];
    	else q[j].res += sum(q[j].c), w[k ++] = q[j ++];
    while(i <= mid) add(q[i].c, q[i].s), w[k ++] = q[i ++];
    while(j <= r) q[j].res += sum(q[j].c), w[k ++] = q[j ++];
    for(int i = l; i <= mid; i++) add(q[i].c, -q[i].s);
    for(int i = l, j = 0; j < k; i++, j++) q[i] = w[j];
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        q[i] = {a, b, c, 1};
    }
    sort(q, q + n);
    
    //判重
    int k = 1;
    for(int i = 1; i < n; i++)
        if(q[i] == q[k - 1]) q[k - 1].s ++;
   		else q[k ++] = q[i];
    
    //CDQ 分治
    merge_sort(0, k - 1);
}
```



<div style="page-break-after:always;"></div>

# 基环树DP

### 基环树的相关概念

**基环树:** 给定一棵无向树, 包含 $n$ 个点 $n - 1$ 条边, 在树中任意两个点之间加一条边, 此时树中有且仅有一个环, 此时整棵树的形状应该是以环为中心, 环上每个点都可能向环外延伸出一棵子树, 这就是一棵基环树. 对于每棵基环树, 恰好有 $n$ 个点 $n$ 条边

可以发现, 仙人掌是有多个简单环, 而基环树只有一个简单环, 因此基环树其实是一个特殊的仙人掌

如果给基环树中每条边一个方向, 环上边的方向都要一致, 如果以环上每个点为根的子树上的边都是指向环外, 则称为外向树. 如果以环上每个点为根的子树上的边都是指向环内, 则称为内向树

若干棵基环树构成的图, 被称为基环树森林. 若干棵外向树构成的图, 被称为外向树森林. 若干棵内向树构成的图, 被称为内向树森林

对于一张图, 如果图中每个点恰好有 $1$ 条入边或恰好有 $1$ 条出边, 那么这张图一定是一个基环森林

**基环树的应用:**

基环树问题的常见题型就是求树上的某些信息

在求树上的信息的时候一般有两种常见的做法, 一种是对于环上节点用单调队列求最值, 从而快速得到某些信息. 一种是将环上某一条边删去, 将基环树问题转化成普通的树上问题, 用树形 $dp$ 求解

<br>

---

### 岛屿问题

##### 解题思路

> 本题每一个点都会向外连一条出边, 因此一定是一个基环森林. 本题要求每个基环树中任意两点之间的距离最大值之和
>
> 由于是一个基环森林, 里面每一棵基环树都是相互独立的, 因此可以对于每一棵基环树, 单独算一下, 任意两个点之间距离的最大值, 累加起来就是答案
>
> 接下来的问题就是对于一棵基环树, 如何快速求出任意两个点之间距离的最大值. 可以将所有点对分成两类, 一类是两个点属于同一棵子树, 则此时这两个点的路径只会用到子树内的边, 不会用到环上的边, 这样就是单纯在一棵树内求任意两个点之间距离的最大值, 也就是求树的直径, 可以用树形 $dp$ 来求, 枚举子树上所有点作为最高点, 求出向下走的最长路和次长路, 就是经过当前点的直径, 枚举所有点取一个最大值就是整棵子树的直径
>
> 另一类就是两个点不属于同一棵子树, 此时这两个点之间的路径必然会经过环, 可以将路径分成三部分, 一部分是环上的路径, 另外两部分是环上任意两个点往下走的路径, 由于要求最大距离, 因此这三部分都要尽可能的大, 而环上每个点往下走的最长距离一定是固定的, 因此可以预处理一下环上每个点往下走的最长距离 $d_i$ , 然后枚举环上任意两个点 $a$ , $b$ , 此时这条路径应该是 $d_a + d_b + S_{a, b}$ , 其中 $S_{a, b}$ 表示 $a$ , $b$ 之间的最长距离. 这里肯定不能直接枚举环上的任意两点, 太慢了, 需要考虑优化
>
> 可以发现 $S_{a, b}$ 和 $S_{b, a}$ 是相同的, 因此可以枚举一种方向, 就是设 $a$ 在 $b$ 的顺时针方向上, 这样只需要枚举 $a$ , 就能枚举到环上所有的情况, 此时对于任意的 $a$ , 需要在环上找到一个 $b$ , 使得 $d_a + d_b + S_{a, b}$ 最大,  由于 $S_{a, b}$ 其实是一个区间和, 因此可以预处理一个前缀和, 则此时的路径长度变成 $d_a + d_b + S_a - S_b$ , 此时 $a$ 是固定的, 因此 $d_a + S_a$ 是固定的, 只需要求 $d_b - S_b$ 的最大值, 可以破环成链, 再将链复制一遍接在后面, 若 $n$ 为环的长度, 则每次枚举链上任意一个长度为 $n$ 的区间, 都是环上的任意一个情况, 就是要在任意一个情况中取 $d_b - S_b$ 的最大值, 这就是一个滑动窗口求最值的问题. 可以用单调队列来求, 这样这一步也是 $O(n)$ 的时间了
>
> 以上就是整体的思路, 对于每棵基环树单独求最长距离, 再累加在一起就是答案
>
> 还有一个细节,  对于基环树, 如何找出环, 这里可以用一个 $dfs$ 来找环, 用一个栈记录递归的路径, 当搜到路径中的某个点时, 就找到环了, 再把这个环取出来即可

<br>

##### 算法模板

```c++
int n;
int h[N], e[M], w[M], ne[M], idx;	//邻接表
int fu[N], fw[N];	//记录每个点的父节点和它与父节点之间边的权值
bool st[N], ins[N];	//记录每个点是否被搜过, 每个点是否在栈中
int cir[N], ed[N], cnt;	//cir 连续的存储所有环, ed 表示每一段环的终点, 基环树的数量
LL s[N];	//s[i] 表示 i 到所在环第一个点的前缀和
LL d[N * 2], sum[N * 2];	//破环成链后的新序列、前缀和数组
int q[N * 2];	//单调队列
LL ans;	//记录每棵基环树的直径

void add (int a, int b, int c)	
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void dfs_c (int u, int from)	//找出所有基环树的环
{
    st[u] = ins[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        if(i == (from ^ 1)) continue;
        int j = e[i];
        fu[j] = u, fw[j] = w[i];
        if(!st[j]) dfs_c(j, i);
        else if(ins[j])	//找到环
        {
            cnt ++;
            ed[cnt] = ed[cnt - 1];
            LL sum = w[i];
            for(int k = u; k != j; k = fu[k])
            {
                s[k] = sum;
                sum += fw[k];
                cir[++ ed[cnt]] = k;
            }
            s[j] = sum, cir[++ ed[cnt]] = j;
        }
    }
    ins[u] = false;
}

LL dfs_d (int u)	//统计从 u 往下走的最大距离
{
    st[u] = true;
    LL d1 = 0, d2 = 0;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(st[j]) continue;
        LL dist = dfs_d(j) + w[i];
        if(dist >= d1) d2 = d1, d1 = dist;
        else if(dist > d2) d2 = dist;
    }
    ans = max(ans, d1 + d2);	//情况 1
    return d1;
}

int main()
{
    cin >> n;
   	memset(h, -1, sizeof h);
    
    for(int i = 1; i <= n; i++)
    {
        int a, b;
        cin >> a >> b;
        add(i, a, b), add(a, i, b);	
    }
    
    //找出所有基环树的环
    for(int i = 1; i <= n; i++)
        if(!st[i])
            dfs_c(i, -1);
    
    memset(st, false, sizeof st);
    for(int i = 1; i <= ed[cnt]; i++)
        st[cir[i]] = true;	//标记环上的点
    
    LL res = 0;
    for(int i = 1; i <= cnt; i++)
    {
        ans = 0;
        int sz = 0;	//记录环的大小
        for(int j = ed[i - 1] + 1; j <= ed[i]; j++)	//找出环中的所有点
        {
            int k = cir[j];
            d[sz] = dfs_d(k);
            sum[sz] = s[k];
            sz ++;
        }
        //破环成链
        for(int j = 0; j < sz; j++)
            d[sz + j] = d[j], sum[sz + j] = sum[j] + sum[sz - 1];
        
        //单调队列
        int hh = 0, tt = -1;
        for(int j = 0; j < sz * 2; j++)
        {
            if(hh <= tt && j - q[hh] + 1 > sz) hh ++;
            //情况 2
            if(hh <= tt) ans = max(ans, d[j] + sum[j] + d[q[hh]] - sum[q[hh]]);
            while(hh <= tt && d[q[tt]] - sum[q[tt]] <= d[j] - sum[j]) tt --;
            q[++ tt] = j;
        }
        res += ans;
    }
    
    cout << res << endl;
}
```

<br>

---

### 骑士问题

##### 解题思路

> 如果将每个骑士向讨厌的人连边, 则可以看作每个点只有一条出边, 因此这就是一个基环森林
>
> 然后要求在基环森林中选出若干个点, 使得任意两个点没有公共边, 要求选出的点权和最大
>
> 可以发现基环森林中每棵基环树的选法都是独立的, 因此可以对于每棵基环树单独考虑如何选点. 如果是一棵普通的树, 可以直接用树形 $dp$ 来求, 但本题是一棵基环树, 存在依赖关系就没法用 $dp$ 了
>
> 可以考虑将一条边断开, 取环上某一点 $p$ , $p$ 讨厌 $A_p$ , 则所有方案可以分成两种, 一种是选 $p$ , 一种是不选 $p$ , 如果将 $p \to A_p$ 这条边断开, 那么基环树就会变成一棵树, 就可以在树上做树形 $dp$ 了, 要在做树形 $dp$ 的时候把选 $p$ 和不选 $p$ 的方案都考虑到, 可以分别枚举这两种方案, 对于不选 $p$ 的情况, 此时 $A_p$ 可选可不选, 因此 $p \to A_p$ 这条边就没有意义了, 因为此时 $A_p$ 选还是不选和 $p$ 没有关系了, 那么这条边删去就不会造成任何影响, 直接在删完边的树上求一遍树形 $dp$ 即可
>
> 这里的树形 $dp$ 设 $f_{u, 0}$ 表示在以 $u$ 为根的子树中选若干个点且不选 $u$ 的所有方案的最大值, $f_{u, 1}$ 表示在以 $u$ 为根的子树中选若干个点且选 $u$ 的所有方案的最大值. 设 $u$ 的每一个子节点是 $s$ , 得到以下状态转移方程:
>
> $f_{u, 0} = \sum max \{f_{s, 0}, f_{s, 1}\}$ , $f_{u, 1} = \sum f_{s, 0}$ 
>
> 最终对于 $p$ 会得到两个状态 $f_{p, 0}$ 和 $f_{p, 1}$ , 此时不选 $p$ 的所有方案的最大值就是 $f_{p, 0}$ 
>
> 然后考虑选 $p$ 的情况, 此时就意味着 $A_p$ 一定不能选, 那么仍然可以按照上述的树形 $dp$ 来做, 但在 $A_p$ 这里需要特判一下, $A_p$ 只能不选. 这样又能得到两个状态 $f_{p, 0}$ 和 $f_{p, 1}$ , 此时选 $p$ 的所有方案的最大值就是 $f_{p, 1}$ 
>
> 最终从两个情况的最大值中取一个最大值就是答案, 树形 $dp$ 的时间复杂度是 $O(n)$ 的
>
> 注意, 如果从每个骑士向讨厌的人连边, 则整个图会是一个内向树森林, 会有若干个入度为 $0$ 的点, 而做树形 $dp$ 时是需要选择一个根节点往下递推的, 因此建边的时候需要反向建边, 建一棵外向树

<br>

##### 算法模板

```c++
int n;
int h[N], e[M], rm[N], w[N], ne[N], idx;	//rm[i] 表示 i 边是否被删掉
bool st[N], ins[N];	//记录每个点是否被搜过、每个点是否在栈中
LL f1[N][2], f2[N][2];
LL res;

void add (int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

//树形 dp 求以 u 为根的子树中不选 ap 的所有方案的最大值
void dfs_f (int u, int ap, LL f[][2])
{
    //不选 u
    for(int i = h[u]; i != -1; i = ne[i])
    {
        if(rm[i]) continue;	//当前边已经被删掉
        int j = e[i];
        dfs_f(j, ap, f);
        f[u][0] += max(f[j][0], f[j][1]);
    }
    
    //选 u
    f[u][1] = -INF;
    if(u != ap)	//如果 u != ap, 说明 u 可选
    {
        f[u][1] = w[u];
        for(int i = h[u]; i != -1; i = ne[i])
        {
            if(rm[i]) continue;
            int j = e[i];
            f[u][1] += f[j][0];
        }
    }
}

void dfs_c (int u, int from)	//找出 u 所在的基环树的环
{
    st[u] = ins[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(!st[j]) dfs_c(j, i);
        else if(ins[j])	//找到环
        {
            rm[i] = 1;	//将 u -> j 的边删掉
            dfs_f(j, -1, f1);	//不选 j 的情况
            dfs_f(j, u, f2);	//选 j 的情况
            res += max(f1[j][0], f2[j][1]);
        }
    }
    ins[u] = false;
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof h);
    
    for(int i = 1; i <= n; i++)
    {
        int a, b;
        cin >> a >> b;
        add(b, i);
        w[i] = a;
    }
    
    //求出所有基环树的环
    for(int i = 1; i <= n; i++)
        if(!st[i])
            dfs_c(i, -1);
    cout << res << endl;
}
```



<div style="page-break-after:always;"></div>

# 二维计算几何基础

```c++
1. 前置知识点
    (1) pi = acos(-1);
    (2) 余弦定理 c^2 = a^2 + b^2 - 2abcos(t)

2. 浮点数的比较
const double eps = 1e-8;
int sign(double x)  // 符号函数
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int cmp(double x, double y)  // 比较函数
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

3. 向量
    3.1 向量的加减法和数乘运算
    3.2 内积（点积） A·B = |A||B|cos(C)
        (1) 几何意义：向量A在向量B上的投影与B的长度的乘积。
        (2) 代码实现
        double dot(Point a, Point b)
        {
            return a.x * b.x + a.y * b.y;
        }
    3.3 外积（叉积） AxB = |A||B|sin(C)
        (1) 几何意义：向量A与B张成的平行四边形的有向面积。B在A的逆时针方向为正。
        (2) 代码实现
        double cross(Point a, Point b)
        {
            return a.x * b.y - b.x * a.y;
        }
    3.4 常用函数
        3.4.1 取模
        double get_length(Point a)
        {
            return sqrt(dot(a, a));
        }
        3.4.2 计算向量夹角
        double get_angle(Point a, Point b)
        {
            return acos(dot(a, b) / get_length(a) / get_length(b));
        }
        3.4.3 计算两个向量构成的平行四边形有向面积
        double area(Point a, Point b, Point c)
        {
            return cross(b - a, c - a);
        }
        3.4.5 向量A顺时针旋转C的角度：
        Point rotate(Point a, double angle)
        {
            return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle) + a.y * cos(angle));
        }
4. 点与线
    4.1 直线定理
        (1) 一般式 ax + by + c = 0
        (2) 点向式 p0 + vt
        (3) 斜截式 y = kx + b
    4.2 常用操作
        (1) 判断点在直线上 A x B = 0
        (2) 两直线相交
        // cross(v, w) == 0则两直线平行或者重合
        Point get_line_intersection(Point p, Vector v, Point q, vector w)
        {
            vector u = p - q;
            double t = cross(w, u) / cross(v, w);
            return p + v * t;
        }
        (3) 点到直线的距离
        double distance_to_line(Point p, Point a, Point b)
        {
            vector v1 = b - a, v2 = p - a;
            return fabs(cross(v1, v2) / get_length(v1));
        }
        (4) 点到线段的距离
        double distance_to_segment(Point p, Point a, Point b)
        {
            if (a == b) return get_length(p - a);
            Vector v1 = b - a, v2 = p - a, v3 = p - b;
            if (sign(dot(v1, v2)) < 0) return get_length(v2);
            if (sign(dot(v1, v3)) > 0) return get_length(v3);
            return distance_to_line(p, a, b);
        }
        (5) 点在直线上的投影
        Point get_line_projection(Point p, Point a, Point b)
        {
            Vector v = b - a;
            return a + v * (dot(v, p - a) / dot(v, v));
        }
        (6) 点是否在线段上
        bool on_segment(Point p, Point a, Point b)
        {
            return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <= 0;
        }
        (7) 判断两线段是否相交
        bool segment_intersection(Point a1, Point a2, Point b1, Point b2)
        {
            double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
            double c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
            return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
        }
5. 多边形
    5.1 三角形
    5.1.1 面积
        (1) 叉积
        (2) 海伦公式
            p = (a + b + c) / 2;
            S = sqrt(p(p - a) * (p - b) * (p - c));
    5.1.2 三角形四心
        (1) 外心，外接圆圆心
            三边中垂线交点。到三角形三个顶点的距离相等
        (2) 内心，内切圆圆心
            角平分线交点，到三边距离相等
        (3) 垂心
            三条垂线交点
        (4) 重心
            三条中线交点（到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点）
    5.2 普通多边形
        通常按逆时针存储所有点
        5.2.1 定义
        (1) 多边形
            由在同一平面且不再同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形
        (2) 简单多边形
            简单多边形是除相邻边外其它边不相交的多边形
        (3) 凸多边形
            过多边形的任意一边做一条直线，如果其他各个顶点都在这条直线的同侧，则把这个多边形叫做凸多边形
            任意凸多边形外角和均为360°
            任意凸多边形内角和为(n−2)180°
        5.2.2 常用函数
        (1) 求多边形面积（不一定是凸多边形）
        我们可以从第一个顶点除法把凸多边形分成n − 2个三角形，然后把面积加起来。
        double polygon_area(Point p[], int n)
        {
            double s = 0;
            for (int i = 1; i + 1 < n; i ++ )
                s += cross(p[i] - p[0], p[i + 1] - p[i]);
            return s / 2;
        }
        (2) 判断点是否在多边形内（不一定是凸多边形）
        a. 射线法，从该点任意做一条和所有边都不平行的射线。交点个数为偶数，则在多边形外，为奇数，则在多边形内。
        b. 转角法
        (3) 判断点是否在凸多边形内
        只需判断点是否在所有边的左边（逆时针存储多边形）。
    5.3 皮克定理
        皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为:
            S = a + b/2 - 1
        其中a表示多边形内部的点数，b表示多边形边界上的点数，S表示多边形的面积。
6. 圆
    (1) 圆与直线交点
    (2) 两圆交点
    (3) 点到圆的切线
    (4) 两圆公切线
    (5) 两圆相交面积
```



<div style="page-break-after:always;"></div>

# 凸包

### 二维凸包的相关概念

> 平面直角坐标系上有 $n$ 个点, 在平面上能包含所有点的周长最短的凸多边形叫做凸包
>
> 求凸包的常用算法有 $Graham算法$ 和 $Andrew算法$ 

<br>

---

### Andrew 算法

> ##### 算法步骤
>
> 1. 将所有点按横坐标为第一关键字, 纵坐标为第二关键字排序
> 2. 将凸包分成上半部分和下半部分. 先从左到右枚举所有点求上半部分凸包, 再从右往左枚举所有点求下半部分凸包
> 3. 对于上半部分, 从左到右枚举每个点, 枚举的过程中用栈来维护当前凸包. 枚举每个点 $i$ , 当栈中元素个数 $\le 2$ 时, 直接将当前点 $i$ 加入栈中. 当栈中元素个数 $> 2$ 时, 如果新点 $i$ 在栈顶两元素构成的向量的左侧, 则弹出栈顶元素, 再当当前点 $i$ 入栈
> 4. 求完上半部分凸包后, 需要将上半部分凸包中的点标记, 避免被重复计算到下半部分凸包中. 但由于最终要将上半部分和下半部分凸包合并, 两个凸包需要能够连接成一个完整的凸包, 因此在枚举下半部分凸包前一个将上半部分凸包的第一个点的标记删除

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef pair<double,double> PDD;

int n;
PDD q[N];
int stk[N];
bool used[N];

double get_dist (PDD a, PDD b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

PDD operator - (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

double cross (PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

double area (PDD a, PDD b, PDD c)
{
    return cross(b - a, c - a);
}

double andrew()
{
    sort(q, q + n);
    int top = 0;
    for(int i = 0; i < n; i++)
    {
        while(top >= 2 && area(q[stk[top - 1]], q[stk[top]], q[i]) <= 0)
        {
            //凸包边界上的点即使被从栈中删掉,也不能删掉used上的标记
            if(area(q[stk[top - 1]], q[stk[top]], q[i]) < 0)
                used[stk[top -- ]] = false;
            else top -- ;
        }
        stk[ ++ top] = i;
        used[i] = true;
    }
    used[0] = false;
    for(int i = n - 1; i >= 0; i--)
    {
        if(used[i]) continue;
        while(top >= 2 && area(q[stk[top - 1]], q[stk[top]], q[i]) <= 0)
            top --;
        stk[ ++ top] = i;
    }
    
    double res = 0;
    for(int i = 2; i <= top; i++)
        res += get_dist(q[stk[i - 1]], q[stk[i]]);
    return res;
}
```



<div style="page-break-after:always;"></div>

# 半平面交

### 半平面交的相关概念

> 在平面中存在若干条有向直线, 每条直线都相当于是对平面的一个划分, 对于每条直线, 只保留它正方向的左半部分, 则所有直线保留的部分的交集就称为半平面交
>
> 对于半平面交相关的问题, 一般都是要求半平面交的面积

<br>

---

### 求半平面交的面积

> ##### 算法步骤
>
> 1. 对于两条方向完全一致的直线, 可以发现靠右直线对于半平面交是没有贡献的, 因此可以将靠右直线删去, 相同方向只保留最靠左的直线. 最终剩下的所有直线方向一定都是不同的
> 2. 将所有直线按照角度从小到大排序. 这里对于一个向量 $(x, y)$ 的角度, 可以用 $atan2(y, x)$ 来求, 这是 $arctan$ 函数的一个封装, 可以将所有角度都映射到 $-\pi$ ~ $\pi$ 之间
> 3. 从前往后枚举每条直线, 用一个双端队列来维护当前的半平面交中的所有边
> 4. 找出队头两条直线的交点 $p$ , 如果 $p$ 在当前直线的右侧, 则需要将队头删掉, 再将当前直线入队
> 5. 不仅要维护双端队列的队头, 还要维护双端队列的队尾. 找出队尾两条直线的交点 $u$ , 如果 $u$ 在当前直线的右侧, 那么需要将队尾删掉

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef pair<double,double> PDD;

const double eps = 1e-8;

int cnt;
struct Line
{
    PDD st, ed;
}line[N];
PDD ans[N];
int q[N];

int sign (double x)
{
    if(fabs(x) < eps) return 0;
    if(x < 0) return -1;
    return 1;
}

int dcmp (double x, double y)
{
    if(fabs(x - y) < eps) return 0;
    if(x < y) return -1;
    return 1;
}

double get_angle (const Line& a)
{
    return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);
}

PDD operator - (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

double cross (PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

double area (PDD a, PDD b, PDD c)
{
    return cross(b - a, c - a);
}

bool cmp (const Line& a, const Line& b)
{
    double A = get_angle(a), B = get_angle(b);
    if(!dcmp(A, B)) return area(a.st, a.ed, b.ed) < 0;
    return A < B;
}

PDD get_line_intersection (PDD p, PDD v, PDD q, PDD w)
{
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

PDD get_line_intersection (Line a, Line b)
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}

//bc的交点是否在a的右侧
bool on_right (Line& a, Line& b, Line& c)
{
    auto o = get_line_intersection(b, c);
    return sign(area(a.st, a.ed, o)) <= 0;
}

double half_plane_intersection()
{
    sort(line, line + cnt, cmp);
    int hh = 0, tt = -1;
    for(int i = 0; i < cnt; i++)
    {
        if(i && !dcmp(get_angle(line[i]), get_angle(line[i - 1]))) continue;
        while(hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) tt -- ;
        while(hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) hh ++ ;
        q[ ++ tt] = i;
    }
    while(hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) tt -- ;
    while(hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1]])) hh ++ ;
    
    q[ ++ tt] = q[hh];
    int k = 0;
    for(int i = hh; i < tt; i++)
        ans[k ++ ] = get_line_intersection(line[q[i]], line[q[i + 1]]);
    double res = 0;
    for(int i = 1; i + 1 < k; i++)
        res += area(ans[0], ans[i], ans[i + 1]);
    return res / 2;
}
```



<div style="page-break-after:always;"></div>

# 最小圆覆盖

### 最小圆覆盖的相关概念

> 在二维平面上有若干个点, 求一个最小的圆能将所有的点覆盖, 这就是最小圆覆盖问题. 覆盖住所有点的圆称为最小覆盖圆

<br>

---

### 最小圆覆盖问题

##### 性质 

> 性质 $1$ : 最小覆盖圆是唯一的
>
> 性质 $2$ : 假设已经求出了点集 $S$ 的最小覆盖圆, 如果有一个点 $p$ 不在 $S$ 的最小覆盖圆内部, 则 $p$ 一定在 $\{p\} \cup S$ 的最小覆盖圆的边上

<br>

##### 求最小覆盖圆

> 如果能找出三个点必然在最小覆盖圆的边上, 那么三个点能唯一确定一个圆, 就能找出最小覆盖圆
>
> 1. 将所有点随机排列
> 2. 枚举每个点, 依次将每个点加入到最小覆盖圆中. 对于每个点 $i$ , 如果在圆内, 继续考虑下一个点; 如果在圆外, 那么将 $i$ 加入最小覆盖圆后, $i$ 一定在新的最小覆盖圆的边上, 此时对于前 $i$ 个点的最小覆盖圆来说, 我们已经确定了边上的一个点 $i$ , 接下来需要继续确定剩下的两个点
> 3. 此时我们保证 $i$ 一定在最小覆盖圆的边上, 因此接下来只需要找所有 $i$ 在圆边上的圆, 从最小的圆开始找, 而 $i$ 这个点就是最小的一个 $i$ 在圆边上的圆, 此时圆心就是 $i$ , 半径是 $0$ , 然后依次枚举 $1$ ~ $i - 1$ . 假设现在已经求出了 $1$ ~ $j - 1$ 都已经被覆盖, 且 $i$ 在圆边上的最小覆盖圆, 那么此时将 $j$ 加入圆中, 如果 $j$ 在圆内, 那么 $1$ ~ $j$ 的最小覆盖圆就是 $1$ ~ $j - 1$ 的最小覆盖圆; 如果 $j$ 在圆外, 那个此时 $j$ 一定在覆盖 $1$ ~ $j$ 且 $i$ 在边上的最小覆盖圆的边上
> 4. 此时已经找到了圆上的两个点了, 那么接下来就要找所有 $i$ , $j$ 都在圆边上的最小覆盖圆. 同样从最小的圆开始, 也就是以 $i$ , $j$ 为直径的圆, 然后依次枚举 $1$ ~ $j - 1$ . 假设已经求出了能覆盖 $1$ ~ $k - 1$ , 并且 $i$ , $j$ 都在边上的最小覆盖圆, 然后将 $k$ 加入圆中, 如果 $k$ 在圆内, 那么覆盖 $1$ ~ $k$ 的最小覆盖圆就是覆盖 $1$ ~ $k -1$ 的最小覆盖圆; 如果 $k$ 在圆外, 那么此时 $k$ 一定在覆盖 $1$ ~ $k$ , 且 $i$ , $j$ 都在边上的最小覆盖圆的边上
> 5. 此时已经确定了圆边上的三个点, 那么如何求三个点 $a$ , $b$ , $c$ 的外接圆. 可以分别求 $ab$ 和 $ac$ 的中垂线, 两个中垂线的交点就是圆心, 圆心和圆上任意一点的距离就是半径. 对于 $ab$ 的中垂线, 由于中垂线一定是垂直的, 所以中垂线的方向可以通过 $ab$ 顺时针旋转 $90^。$ 得到, 用点向式表示直线, 可以取 $ab$ 的中点为中垂线的起点

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef pair<double, double> PDD;

const double eps = 1e-12;
const double pi = acos(-1);

PDD q[N];
struct Circle
{
    PDD p;
    double r;
};

int sign (double a)
{
    if(fabs(a) < eps) return 0;
    if(a < 0) return -1;
    return 1;
}

int dcmp (double a, double b)
{
    if(fabs(a - b) < eps) return 0;
    if(a < b) return -1;
    return 1;
}

PDD operator + (PDD a, PDD b)
{
    return {a.x + b.x, a.y + b.y};
}

PDD operator - (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

PDD operator * (PDD a, double t)
{
    return {a.x * t, a.y * t};
}

PDD operator / (PDD a, double t)
{
    return {a.x / t, a.y / t};
}

double operator * (PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

PDD rotate (PDD a, double b)
{
    return {a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)};
}

double get_dist (PDD a, PDD b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

PDD get_line_intersection (PDD p, PDD v, PDD q, PDD w)
{
    auto u = p - q;
    double t = w * u / (v * w);
    return p + v * t;
}

pair<PDD, PDD> get_line (PDD a, PDD b)
{
    return {(a + b) / 2, rotate(b - a, pi / 2)};
}

Circle get_circle (PDD a, PDD b, PDD c)
{
    auto u = get_line(a, b), v = get_line(a, c);
    auto p = get_line_intersection(u.x, u.y, v.x, v.y);
    return {p, get_dist(p, a)};
}

int main()
{
    for(int i = 0; i < n; i++)
        cin >> q[i].x >> q[i].y;
    random_shuffle(q, q + n);
    
    Circle c({q[0], 0});
    for(int i = 1; i < n; i++)
        if(dcmp(c.r, get_dist(c.p, q[i])) < 0)
        {
            c = {q[i], 0};
            for(int j = 0; j < i; j++)
                if(dcmp(c.r, get_dist(c.p, q[j])) < 0)
                {
                    c = {(q[i] + q[j]) / 2, get_dist(q[i], q[j]) / 2};
                    for(int k = 0; k < j; k++)
                        if(dcmp(c.r, get_dist(c.p, q[k])) < 0)
                            c = get_circle(q[i], q[j], q[k]);
                }
        }
    
    printf("%.10lf\n", c.r);
    printf("%.10lf %.10lf\n", c.p.x, c.p.y);
}
```



<div style="page-break-after:always;"></div>

# 三维计算几何基础

```c++
1. 三维向量表示(x, y, z)
2. 向量加减法、数乘运算，与二维相同
3. 模长 |A| = sqrt(x * x + y * y + z * z)
4. 点积
    (1) 几何意义：A·B = |A| * |B| * cos(C)
    (2) 代数求解：(x1, y1, z1) · (x2, y2, z2) = (x1x2, y1y2, z1z2);
5. 叉积
    (1) 几何意义：AxB = |A| * |B| * sin(C)，方向：右手定则
    (2) 代数求解：AxB = (y1z2 - z1y2, z1x2 - x1z2, x1y2 - x2y1)
6. 如何求平面法向量
    任取平面上两个不共线的向量A、B：AxB
7. 判断点D是否在平面里
    任取平面上两个不共线的向量A、B：先求法向量C = AxB，然后求平面上任意一点到D的向量E与C的点积，判断点积是否为0。
8. 求点D到平面的距离
    任取平面上两个不共线的向量A、B：先求法向量C = AxB。然后求平面上任意一点到D的向量E在C上的投影长度即可。即：E·C / |C|
9. 多面体欧拉定理
    顶点数 - 棱长数 + 表面数 = 2
10. 三维凸包
```



<div style="page-break-after:always;"></div>

# 三维凸包

### 增量法求三维凸包

> 三维凸包保证表面积最小, 二维凸包保证周长最小

> 存储三维凸包的方法是将三维凸包的所有面分割成若干个三角形, 然后按任意顺序存下来
>
> 对于一个新加入的点 $p$ , 如果 $p$ 已经在凸包内, 那么不需要额外操作; 如果 $p$ 在凸包外, 那么就需要更新三维凸包. 将 $p$ 想象成一个光点, 散发出光线, 找出三维凸包上所有能被 $p$ 照到的面, 在加入 $p$ 之后这些面都会变成凸包内部的面, 因此这些面都需要被删去, 和光线平行的面也将它删去, 而所有没有被照到的面则需要保留下来. 所有照到的面和没照到的面之间有一条分界线, 每一条分界线和 $p$ 都会构成一个新的面, 我们将这些新的面加入凸包, 这样就得到了一个新的凸包
>
> 按照上述思路将所有点加入凸包, 就能得到一个三维凸包
>
> 如何判断一个面能否被找到. 显然当 $p$ 在当前平面的上方时, 则当前平面会被照到, 当 $p$ 在当前平面的下方时, 则当前平面不会被照到. 判断点和平面的相对位置关系, 可以用点积判断
>
> 如何找出分界线. 可以记录一下每条边对应的面能否被照到, 这里用逆时针顺序存储所有边, 那么对于一条边 $(i, j)$ 在它对应的两个面上存储的分别是 $(i, j)$ 和 $(j, i)$ , 如果 $(i, j)$ 是分界线就意味着它对应的两个中只有一个被照到, 一个没照到. 因此可以枚举所有边 $(i, j)$ , 如果 $(i, j)$ 和 $(j, i)$ 一个被照到, 一个没被照到, 就说明 $(i, j)$ 是分界线之一

<br>

##### 算法模板

```c++
const double eps = 1e-12;

int n, m;	//点的数量, 面的数量
bool g[N][N];

double rand_eps()
{
    return ((double)rand() / RAND_MAX - 0.5) * eps;
}

struct Point	//点
{
    double x, y, z;
    void shake()	//随机扰动
    {
        x += rand_eps(), y += rand_eps(), z += rand_eps();
    }
    Point operator - (Point t)	//向量减法
    {
        return {x - t.x, y - t.y, z - t.z};
    }
    double operator & (Point t)	//向量内积
    {
        return x * t.x + y * t.y + z * t.z;
    }
    Point operator * (Point t)	//向量外积
    {
        return {y * t.z - t.y * z, z * t.x - x * t.z, x * t.y - y * t.x};
    }
    double len()	//模长
    {
        return sqrt(x * x + y * y + z * z);
    }
}q[N];

struct Plane	//面
{
    int v[3];
    Point norm()	//法向量
    {
        return (q[v[1]] - q[v[0]]) * (q[v[2]] - q[v[0]]);
    }
    double area()	//求面积
    {
        return norm().len() / 2;
    }
    bool above (Point a)	//判断点a是否在面的上方
    {
        return ((a - q[v[0]]) & norm()) >= 0;
    }
}plane[N], np[N];

void get_convex_3d()
{
    plane[m ++ ] = {0, 1, 2};
    plane[m ++ ] = {2, 1, 0};
    for(int i = 3; i < n; i++)
    {
        int cnt = 0;
        for(int j = 0; j < m; j++)
        {
            bool t = plane[j].above(q[i]);
            if(!t) np[cnt ++ ] = plane[j];
            for(int k = 0; k < 3; k++)
                g[plane[j].v[k]][plane[j].v[(k + 1) % 3]] = t;
        }
        for(int j = 0; j < m; j++)
            for(int k = 0; k < 3; k++)
            {
                int a = plane[j].v[k], b = plane[j].v[(k + 1) % 3];
                if(g[a][b] && !g[b][a])
                    np[cnt ++ ] = {a, b, i};
            }
        m = cnt;
        for(int j = 0; j < m; j++)
            plane[j] = np[j];
    }
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> q[i].x >> q[i].y >> q[i].z;
        q[i].shake();
    }
    get_convex_3d();
    
    double res = 0;
    for(int i = 0; i < m; i++)
        res += plane[i].area();
    printf("%.6lf\n", res);
}
```



<div style="page-break-after:always;"></div>

# 旋转卡壳

### 旋转卡壳的相关概念

> 对于一类问题, 要求平面上所有点对之间距离最远的点对, 这类问题称为平面最远点对问题. 而旋转卡壳就是一种用来求平面最远点对的思想

<br>

---

### 旋转卡壳

##### 旋转卡壳的思路 

> 距离最远的两个点一定是凸包上的两个点

> 准备两条方向相反的平行线, 一条从凸包的上面向下平移, 一条从凸包的下面向上平移, 然后两条平行线会分别被凸包的某一个点卡住, 然后将两条平行线同时绕着凸包逆时针旋转 $360^。$ , 在旋转的过程中两条平行线之间的距离最大值就是最远点对之间的距离

> 考虑如何枚举所有情况, 这里枚举的是平行线的角度, 而角度是有无穷多种取值的, 因此枚举的时候需要枚举一些离散值, 使得枚举的数量不会太大. 考虑所有能卡住两条平行线的点对, 这种点对被称为对踵点, 对踵点一定是成对出现的. 当平行线旋转的过程中, 对踵点是不断发生变化的

> 只需要找出所有对踵点对, 找出所有对踵点对之间距离的最大值, 就是答案. 由于目标只是找出所有的对踵点对, 因此枚举角度的时候不需要枚举所有的角度, 只需要枚举对踵点发生变化的角度. 而只有其中一条平行线和某一条边 $ab$ 平行时, 对踵点才会发生变化, 假设此时另一条平行线和凸包的交点是 $p$ , 那么此时对踵点对就从 $(p, a)$ 变成了 $(p, b)$ , 只需要找出所有对踵点对变化的时刻, 就能找出所有点对踵点对
>
> 而对于所有对踵点对变化的时刻, 很容易可以看出就是某一条平行线和某一条边重合的时刻, 因此可以直接枚举每一条边, 对于每条边 $ab$ , 将它看作其中一条平行线, 那么此时另一条平行线和凸包的交点就应该是距离 $ab$ 最远的一个点. 由于这是一个凸包, 因此对于凸包上每个点到当前边的距离一定是先增后减, 而此时要找的最大的位置, 相当于是一个顶峰. 由于这个点也是被一条平行线卡住的, 因此如果逆时针枚举每条边, 那么对应的另一条平行线卡住的点也一定只会沿着逆时针方向单调往后走, 所以就可以用双指针算法来找到距离每条边最远的点
>
> 假设距离当前枚举的边最远的点是 $p$ , 则当枚举到下一条边时, 只需要看一下 $p$ 和逆时针的下一个点 $q$ , 哪个点距离这条边更远, 如果 $p$ 更远, 则最远点不变, 如果 $q$ 更远, 则此时最远点应该从 $p$ 变成 $q$ , 然后继续判断 $q$ 和逆时针的下一个点哪个更远, 直到找到一个点距离这条边的距离, 比下一个点更远时, 就找到了对于这条边来说顶峰的一个点
>
> 对于一条边 $ab$ , 如果判断 $p$ 和 $q$ 哪一个离它更远. 可以用叉积来判断, 对于三角形 $abp$ 和 $abq$ 来说, 它们的底边都是 $ab$ , 高分别是 $p$ 和 $ab$ 的距离以及 $q$ 和 $ab$ 的距离, 那么此时 $abp$ 和 $abq$ 哪个三角形的面积更大, 就等价于 $p$ 和 $q$ 哪个点离 $ab$ 更远

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef pair<int,int> PII;

int n;
PII q[N];
int stk[N], top;
bool used[N];

PII operator - (PII a, PII b)
{
    return {a.x - b.x, a.y - b.y};
}

int operator * (PII a, PII b)
{
    return a.x * b.y - a.y * b.x;
}

int area (PII a, PII b, PII c)
{
    return (b - a) * (c - a);
}

int get_dist (PII a, PII b)
{
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return dx * dx + dy * dy;
}

void get_convex()
{
    sort(q, q + n);
    for(int i = 0; i < n; i++)
    {
        while(top >= 2 && area(q[stk[top - 2]], q[stk[top - 1]], q[i]) <= 0)
        {
            if(area(q[stk[top - 2]], q[stk[top - 1]], q[i]) < 0)
                used[stk[ -- top]] = false;
            else top -- ;
        }
        stk[top ++ ] = i;
        used[i] = true;
    }
    used[0] = false;
    for(int i = n - 1; i >= 0; i--)
    {
        if(used[i]) continue;
        while(top >= 2 && area(q[stk[top - 2]], q[stk[top - 1]], q[i]) <= 0)
            top -- ;
        stk[top ++ ] = i;
    }
    top -- ;
}

int rotating_calipers()	//返回最大点对距离的平方
{
    if(top <= 2) return get_dist(q[0], q[n - 1]);
    
    int res = 0;
    for(int i = 0, j = 2; i < top; i++)
    {
        auto d = q[stk[i]], e = q[stk[i + 1]];
        while(area(d, e, q[stk[j]]) < area(d, e, q[stk[j + 1]])) j = (j + 1) % top;
        res = max(res, max(get_dist(d, q[stk[j]]), get_dist(e, q[stk[j]])));
    }
    return res;
}
```



<div style="page-break-after:always;"></div>

# 扫描线

### 扫描线的相关概念

> 扫描线一般运用在图形上面, 它和它的字面意思十分相似, 就是一条线在整个图上扫来扫去, 它一般被用来解决图形面积, 周长, 以及二维点数等问题

<br>

---

### 扫描线求矩形的面积并

##### 解题思路

> 将整个平面根据所有点的横坐标划分成若干个长条区域, 此时所有的顶点都一定在每个区域的边界上, 就能保证每个区域中要么没有面积并, 要么有若干个矩形的面积并, 且这些矩形的宽度和所在区域的宽度相同.
>
> 此时每个区域的宽度都是已知的, 只需要求一下每个长条区域中所有矩形的总长度, 宽度乘上总长度就是这个区域中所有矩形的面积和 (区间和并) 

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef long long LL;
typedef pair<int,int> PII;

int n;
PII l[N], r[N];
PII q[N];

LL range_area (int a, int b)
{
    int cnt = 0;
    for(int i = 0; i < n; i++)
        if(l[i].x <= a && r[i].x >= b)
            q[cnt ++ ] = {l[i].y, r[i].y};
    if(!cnt) return 0;
    
    sort(q, q + cnt);
    LL res = 0;
    int st = q[0].x, ed = q[0].y;
    for(int i = 1; i < cnt; i++)
        if(q[i].x <= ed) ed = max(ed, q[i].y);
    	else
        {
            res += ed - st;
            st = q[i].x, ed = q[i].y;
        }
    res += ed - st;
    return res * (b - a);
}

int main()
{
    cin >> n;
    vector<int> xs;
    for(int i = 0; i < n; i++)
    {
        cin >> l[i].x >> l[i].y >> r[i].x >> r[i].y;
        xs.push_back(l[i].x), xs.push_back(r[i].x);
    }
    
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());
    LL res = 0;
    for(int i = 0; i + 1 < xs.size(); i++)
        res += range_area(xs[i], xs[i + 1]);
    cout << res << endl;
}
```

<br>

---

### 扫描线求三角形的面积并

##### 解题思路

> 将整个平面根据所有点的横坐标划分成若干个长度区间, 保证每个区间内部不存在点
>
> 对于每个长条区间, 求该区间内部的所有三角形的面积并. 由于此时所有的顶点和交点都一定在区间的边界上, 因此每个区间内部一定不存在交点, 并且所有边之间一定不存在交集. 而且由于三角形是封闭图形, 所以所有边一定是成对出现的, 因此每个区间内一定是若干个梯形
>
> 对于每个梯形, 可以用梯形面积公式来求, 只需要求出每个梯形的上底和下底, 又每个区间中所有梯形的高都是相同的, 因此所有梯形的面积就可以用上底的和加上下底的和乘高除以 $2$ . 即对于每个区间, 只需要求出左右边界上交集的长度即可

<br>

##### 算法模板

```c++
#define x first
#define y second

typedef pair<double,double> PDD;

const double eps = 1e-8;
const double INF = 1e6;

int n;
PDD tr[N][3];	//存储三角形
PDD q[N];

int sign (double x)
{
    if(fabs(x) < eps) return 0;
    if(x < 0) return -1;
    return 1;
}

int dcmp (double x, double y)
{
    if(fabs(x - y) < eps) return 0;
    if(x < y) return -1;
    return 1;
}

PDD operator + (PDD a, PDD b)
{
    return {a.x + b.x, a.y + b.y};
}

PDD operator - (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

PDD operator * (PDD a, double t)
{
    return {a.x * t, a.y * t};
}

double operator * (PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

double operator & (PDD a, PDD b)
{
    return a.x * b.x + a.y * b.y;
}

bool on_segment (PDD p, PDD a, PDD b)	//点p是否在线段ab上
{
    return sign((p - a) & (p - b)) <= 0;
}

//求两条线段交点, 无交点返回{INF, INF}
PDD get_line_intersection (PDD p, PDD v, PDD q, PDD w)
{
    if(!sign(v * w)) return {INF, INF};
    auto u = p - q;
    auto t = w * u / (v * w);
    auto o = p + v * t;
    if(!on_segment(o, p, p + v) || !on_segment(o, q, q + w))
        return {INF, INF};
    return o;
}

double line_area (double a, int side)
{
    int cnt = 0; 
    for(int i = 0; i < n; i++)
    {
        auto t = tr[i];
        if(dcmp(t[0].x, a) > 0 || dcmp(t[2].x, a) < 0) continue;
        if(!dcmp(t[0].x, a) && !dcmp(t[1].x, a))
        {
            if(side) q[cnt ++ ] = {t[0].y, t[1].y};
        }
        else if(!dcmp(t[2].x, a) && !dcmp(t[1].x, a))
        {
            if(!side) q[cnt ++ ] = {t[2].y, t[1].y};
        }
        else
        {
            double d[3];
            int u = 0;
            for(int j = 0; j < 3; j++)
            {
                auto o = get_line_intersection(t[j], t[(j + 1) % 3] - t[j], {a, -INF}, {0, INF * 2});
                if(dcmp(o.x, INF))
                    d[u ++ ] = o.y;
            }
            if(u)
            {
                sort(d, d + u);
                q[cnt ++ ] = {d[0], d[u - 1]};
            }
        }
    }
    
    if(!cnt) return 0;
    for(int i = 0; i < cnt; i++)
        if(q[i].x > q[i].y)
            swap(q[i].x, q[i].y);
    sort(q, q + cnt);
    double res = 0, st = q[0].x, ed = q[0].y;
    for(int i = 1; i < cnt; i++)
        if(q[i].x <= ed) ed = max(ed, q[i].y);
    	else
        {
            res += ed - st;
            st = q[i].x, ed = q[i].y;
        }
    res += ed - st;
    return res;
}

double range_area (double a, double b)
{
    return (line_area(a, 1) + line_area(b, 0)) * (b - a) / 2;
}

int main()
{
    cin >> n;
    vector<double> xs;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < 3; j++)
        {
            cin >> tr[i][j].x >> tr[i][j].y;
            xs.push_back(tr[i][j].x);
        }
        sort(tr[i], tr[i] + 3);
    }
    for(int i = 0; i < n; i++)
        for(int j = i + 1; j < n; j++)
            for(int x = 0; x < 3; x++)
                for(int y = 0; y < 3; y++)
                {
                    auto o = get_line_intersection(tr[i][x], tr[i][(x + 1) % 3] - tr[i][x], tr[j][y], tr[j][(y + 1) % 3] - tr[j][y]);
                    if(dcmp(o.x, INF))
                        xs.push_back(o.x);
                }
    
    sort(xs.begin(), xs.end());
    double res = 0;
    for(int i = 0; i + 1 < xs.size(); i++)
        if(dcmp(xs[i], xs[i + 1]))
            res += range_area(xs[i], xs[i + 1]);
    printf("%.2lf\n", res);
}
```



<div style="page-break-after:always;"></div>

# 自适应辛普森积分

### 自适应辛普森积分的相关概念

##### 公式

> $\int_{u}^{v}f(x) dx = \dfrac{f(u) + 4 f(\frac{u + v}{2}) + f(v)}{6} (v - u)$ 

<br>

##### 算法模板

```c++
//求f(x) = sin(x) / x 在[a, b]上积分
const double eps = 1e-12;

double f (double x)
{
    return sin(x) / x;
}

double simpson (double l, double r)
{
    auto mid = (l + r) / 2;
    return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
} 

double asr (double l, double r, double s)
{
    auto mid = (l + r) / 2;
    auto left = simpson(l, mid), right = simpson(mid, r);
    if(fabs(left + right - s) < eps) return left + right;
    return asr(l, mid, left) + asr(mid, r, right);
}

int main()
{
    double l, r;
    cin >> l >> r;
    printf("%lf\n", asr(l, r, simpson(l, r)));
}
```

<br>

---

### 自适应辛普森积分求圆的面积并

##### 无区间和并版本 (处理过于离散的数据会有问题)

```c++
#define x first
#define y second

typedef pair<double,double> PDD;

const double eps = 1e-8;

int n;
struct Cilcle
{
    PDD r;
    double R;
}c[N];
PDD q[N];

int dcmp (double x, double y)
{
    if(fabs(x - y) < eps) return 0;
    if(x < y) return -1;
    return 1;
}

double f (double x)
{
    int cnt = 0;
    for(int i = 0; i < n; i++)
    {
        auto X = fabs(x - c[i].r.x), R = c[i].R;
        if(dcmp(X, R) < 0)
        {
            auto Y = sqrt(R * R - X * X);
            q[cnt ++ ] = {c[i].r.y - Y, c[i].r.y + Y};
        }
    }
    if(!cnt) return 0;
    
    sort(q, q + cnt);
    double res = 0, st = q[0].x, ed = q[0].y;
    for(int i = 1; i < cnt; i++)
        if(q[i].x <= ed) ed = max(ed, q[i].y);
    	else
        {
            res += ed - st;
            st = q[i].x, ed = q[i].y;
        }
    return res + ed - st;
}

double simpson (double l, double r)
{
    auto mid = (l + r) / 2; 
    return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}

double asr (double l, double r, double s)
{
    auto mid = (l + r) / 2;
    auto left = simpson(l, mid), right = simpson(mid, r);
    if(fabs(s - left - right) < eps) return left + right;
    return asr(l, mid, left) + asr(mid, r, right);
}

int main()
{
    cin >> n;
    double l = 2000, r = -2000;
    for(int i = 0; i < n; i++)
    {
        cin >> c[i].r.x >> c[i].r.y >> c[i].R;
        l = min(l, c[i].r.x - c[i].R), r = max(r, c[i].r.x + c[i].R);
    }
    printf("%.3lf\n", asr(l - 100, r + 100, simpson(l, r)));
}
```

<br>

##### 添加区间和并预处理版本

```c++
#define x first
#define y second

typedef pair<double,double> PDD;

const double eps = 1e-8;
const double INF = 1e9;

int n;
vector<PDD> segs;
struct Circle
{
    PDD r;
    double R;
}c[N];
PDD q[N];

int dcmp (double x, double y)
{
    if(fabs(x - y) < eps) return 0;
    if(x < y) return -1;
    return 1;
}

double f (double x)
{
    int cnt = 0;
    for(int i = 0; i < n; i++)
    {
        auto X = fabs(x - c[i].r.x), R = c[i].R;
        if(dcmp(X, R) < 0)
        {
            auto Y = sqrt(R * R - X * X);
            q[cnt ++ ] = {c[i].r.y - Y, c[i].r.y + Y};
        }
    }
    if(!cnt) return 0;
    
    sort(q, q + cnt);
    double res = 0, st = q[0].x, ed = q[0].y;
    for(int i = 1; i < cnt; i++)
        if(q[i].x <= ed) ed = max(ed, q[i].y);
    	else
        {
            res += ed - st;
            st = q[i].x, ed = q[i].y;
        }
    return res + ed - st;
}

double simpson (double l, double r)
{
    auto mid = (l + r) / 2;
    return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}

double asr (double l, double r, double s)
{
    auto mid = (l + r) / 2;
    auto left = simpson(l, mid), right = simpson(mid, r);
    if(fabs(s - left - right) < eps) return left + right;
    return asr(l, mid, left) + asr(mid, r, right);
}

void merge()	//区间和并
{
    sort(segs.begin(), segs.end());
    vector<PDD> new_segs;
    double l = -INF, r = -INF;
    for(auto& seg: segs)
    {
        if(dcmp(seg.x, r) <= 0) r = max(r, seg.y);
        else
        {
            if(dcmp(l, -INF)) new_segs.push_back({l, r});
            l = seg.x, r = seg.y;
        }
    }
    new_segs.push_back({l, r});
    segs = new_segs;
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> c[i].r.x >> c[i].r.y >> c[i].R;
        segs.push_back({c[i].r.x - c[i].R, c[i].r.x + c[i].R});
    }
    
    merge();
    
    double res = 0;
    for(auto& seg: segs)
        res += asr(seg.x, seg.y, simpson(seg.x, seg.y));
    printf("%.3lf\n", res);
}
```



<div style="page-break-after:always;"></div>

# 模拟退火

### 模拟退火的由来

> 模拟退火算法 (Simulate Anneal, SA) 是一种通用概率演算法, 用来在一个大的搜寻空间内找寻命题的最优解
>
> 模拟退火算法是解决TSP问题的有效方法之一
>
> 模拟退火的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性
>
> 模拟退火算法是一种通用的优化算法, 其物理退火过程由加温过程、等温过程、冷却过程这三部分组成

<br>

> 简单说, 模拟退火是一种随机化算法. 当一个问题的方案数量极大 (甚至无穷) 而且不是单峰函数时, 常使用模拟退火求解

<br>

---

### Metropolis接受原则

> 每次随机出一个新解, 如果这个解更优, 则接受它, 否则以一个与温度和与当前最优解的差相关的概率接受它

<br>

> 设这个新的解与最优解的差为 $\Delta$E , 温度为 T , k 为一个随机数, 那么这个概率为 $e^{\frac{\Delta E}{kT}}$
>
> 具体来说: 设 P 为接受当前这个解的概率, 那么
>
> 若 $\Delta$E > 0 , 那么 P = 1, 也就是必定接受更优解
>
> 若 $\Delta$E < 0 , 那么 P = $exp(-\frac{\Delta E}{kT})$ , 也就是以一个和差相关的概率接受这个不优的解

<br>

---

### SA的简要流程

> 所需参数: 初始温度 Tb, 降温的系数 D, 最终温度 Te

<br>

> 温度即步长, 温度越高, 在考虑邻域时考虑的范围就越大. 温度是不断降低的, 即每一次随机的区间是不断缩小的, 最终随机的区间会趋近于一个极小的值, 即固定住最终答案
>
> 衰减系数 D 一般取一个 (0, 1) 之间的数, 越接近于1, 温度衰减得越慢, 找到最优解的概率越大
>
> 初始温度根据搜索空间范围而定, 一般取搜索空间的维度

<br>

> 一般来讲, Tb 会比较大, D 是一个小于1且接近1的 $double$ , 比如 $0.97$, Te 是一个接近0的正值, 如 $1e-10$, 这些都是程序中自定的常数, 但是在实际情况中这些参数需要不断调优, 也就是所谓的调参. 调参也是有迹可循的, 比如 **TLE** 的时候可以考虑把初温调小, **WA** 的时候调大

<br>

> 流程如下: 
>
> 1. 令 T = Tb
> 2. 进行转移
> 3. T *= D
> 4. 重复步骤2、3, 直到 T < Te

<br>

---

### 转移

> 设估价函数为 $f(x)$ (其实就是对随机出来的方案计算答案的一个函数), x 为原先得到的解, $x_1 = x + T_0 * rand()$ 为新得到的随机出来的解 $(-1 \le R \le 1, 且 R\neq 0)$ , $\Delta E = f(x_1) - f(x)$

<br>

> 伪代码如下 (以求全局最大值为例, 即当 $\Delta E > 0$ 时必定更新最优解, 根据题目具体问题进行修改)

```c++
if (DelE > 0) 更新解;
else if (exp(DelE/sqrt(T)) > (double)rand()/1215) 更新解;
```

<br>

> `exp(DelE/sqrt(T))` , 由于前面的 `if` 语句, `DelE/sqrt(T)` 显然小于0, $exp$ 之后也就是一个 $0$ ~ $1$ 的小数. 根据简单的数学知识, `DelE/sqrt(T)` 越大, $exp$ 之后的结果越大. 而 `DelE/sqrt(T)` 的结果, 当 `DelE` 较大或者 `T` 较大的时候都会变大, 也就是说, 当退火过程刚刚开始, 或者当前结果和目前的最优解差距较小时, `exp(DelE/sqrt(T))` 越大, 也就更容易 `>rand()/1215` 成立, 这个解更容易被接受, 反之亦然

<br>

---

### 细节处理

> 1. 随机的初始化真的很重要
>
> 2. 调参这个东西有时候很靠经验
>
> 3. 其实模拟退火可以解决基本所有最优解问题
>
> 4. 有时候为了求得最优解, 需要多次SA, 这里有个不 **TLE** 的好办法: 
>
>    `while ( (double)clock()/CLOCKS_PER_SEC <= 0.8 ) SA();`
>
>    $0.8$ 根据时限而定, 一般比时限小一点点

<br>

---

### 基本框架

```c++
simulate_anneal()
{
    随机一个初始点
       
    for(T = Tb ; T > Te ; T *= D)
    {
        在当前点周围随机一个点
        Delta = f(新) - f(当前)
        if(Delta > 0) 跳到新的点
        else if (与T相关的一定概率) 跳到新的点
    }
}
```

<br>

---

### 例子

> [AcWing 3167. 星星还是树](https://www.acwing.com/problem/content/3170/)

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 110;

int n;
PDD q[N];
double ans = 1e9;  //全局最优解

//计算两点距离
double get_dist(PDD p, PDD q) 
{
    double dx = p.x - q.x;
    double dy = p.y - q.y;
    return sqrt(dx * dx + dy * dy);
}

//计算结果
double calc(PDD p) 
{
    double res = 0;
    for (int i = 1; i <= n; i++) 
        res += get_dist(p, q[i]);

    //更新全局最优解
    ans = min(ans, res);

    return res;
}

//随机产生一个[l,r]中的数
double rand(double l, double r) 
{
    return (double)rand() / RAND_MAX * (r - l) + l;
}

//模拟退火
void simulate_anneal() 
{
    //随机一个初始点
    PDD cur(rand(0, 1e4), rand(0, 1e4));

    //初始化三个参数Tb,Te,D
    double Tb=1e4,Te=1e-4,D=0.99;

    for (double t = Tb; t > Te; t *= D) 
    {
        //在步长内随机产生一个新点
        PDD np(rand(cur.x - t, cur.x + t), rand(cur.y - t, cur.y + t));

        double dt = calc(np) - calc(cur);

        // np 更优，dt小于0，exp(-dt / t)大于1，cur必然转移到np
        // cur更优，dt大于0，cur有概率转移到np
        if (exp(-dt / t) > rand(0, 1)) cur = np;
    }
}

int main() 
{
    cin >> n;

    for (int i = 1; i <= n; i++) 
        cin >> q[i].x >> q[i].y;

    //在时限内不断循环模拟退火
    while ((double) clock() / CLOCKS_PER_SEC <= 0.8) simulate_anneal();  

    printf("%.0lf\n", ans);

    return 0;
}
```

<br>

> [AcWing 2424. 保龄球](https://www.acwing.com/problem/content/2426/)

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 55;

int n, m;
PII q[N];
int ans;    //全局最优解

//计算当前状态的分数
int calc()
{
    int res = 0;
    for (int i = 0; i < m; i ++ )
    {
        res += q[i].x + q[i].y;
        if (i < n)
        {
            if (q[i].x == 10) res += q[i + 1].x + q[i + 1].y;
            else if (q[i].x + q[i].y == 10)
                res += q[i + 1].x;
        }
    }

    //更新全局最优解
    ans = max(ans, res);

    return res;
}

//模拟退火
void simulate_anneal()
{
    for (double t = 1e4; t > 1e-4; t *= 0.99)
    {
        //随机生成两个范围内的下标
        int a = rand() % m, b = rand() % m;

        //计算原状态分数
        int x = calc();

        //随机生成的新状态
        swap(q[a], q[b]);
        if (n + (q[n - 1].x == 10) == m)    //新状态合法
        {
            //计算新状态分数
            int y = calc();

            int delta = y - x;
            if (exp(delta / t) < (double)rand() / RAND_MAX)
                swap(q[a], q[b]);   //不转移到新状态，需要恢复现场
        }
        else swap(q[a], q[b]);  //新状态不合法，需要恢复现场
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> q[i].x >> q[i].y;
    if (q[n - 1].x == 10) m = n + 1, cin >> q[n].x >> q[n].y;
    else m = n;

    //在时限内不断循环模拟退火
    while ((double) clock() / CLOCKS_PER_SEC <= 0.8) simulate_anneal();

    cout << ans << endl;

    return 0;
}
```



<div style="page-break-after:always;"></div>

# 启发式合并

> 类似于并查集中的按秩合并
>
> 启发式合并指的是, 对于两个集合 `x` 和 `y` 合并的操作, 每次把元素个数更少的集合合并到元素个数更多的集合中, 即: 设 `x` 为元素更少的集合, 那么就把 `x` 合并到 `y` 内
>
> 可以证明, 启发式合并的时间复杂度为 `O(nlogn)` . 这可以从贡献的角度来理解, 对于每个元素, 它所处的集合被合并k次, 那么这个元素就被合并k次, 但是每次合并都会使得集合的大小乘以2, 那么一个集合最多被合并 `logn` 次, 所以一个元素最多被合并 `logn` 次, 因此n个元素被合并的复杂度为 `O(nlogn)`

<br>

> 例题: [AcWing 2154. 梦幻布丁](https://www.acwing.com/problem/content/2156/)

> 思路:
>
> 枚举所有颜色是 `x` 的布丁, 对每个判断其左右两边的布丁是不是即将变成的颜色 `y` , 如果左颜色恰好是 `y` , 那么当前布丁变成 `y` 后, 段数就会减少1, 如果右颜色也是 `y` , 那么段数会再减少1
>
> 每次将 `x` 变成 `y` 的时候, 我们遍历颜色是 `x` 的所有布丁, 判断 `x` 左右两边是否为 `y` , 如果是, 那么答案减一
>
> 如果暴力合并, 时间复杂度为 $O(n^2)$ , 因此可用启发式合并优化成 $O(nlogn)$
>
> 进行颜色变化时, 我们是将 `x` 变成 `y` , 且看成将 `x` 和 `y` 合并, 合并时有可能将 `x` 变成 `y` , 是符合题意的, 也有可能将 `y` 变成 `x` , 这样 `x` 和 `y` 两种颜色映射关系会发生变化, 因此我们需要分析一下如何存储:
>
> 开一个数组来存储所有颜色, 用编号表示某种颜色, 一开始每种颜色对应编号即为自己, 对于每种编号, 由于我们需要方便的将两个集合合并, 我们可以用单链表存所有集合, 每种颜色编号我们下拉一个单链表, 用于存储所有这种颜色的布丁所在位置, 每次根据题目要求将 `x` 合并至 `y` 时, 假如 `x` 所在集合大小比 `y` 所在集合大小更大, 我们实际操作时应该将 `y` 集合合并至 `x` 集合中, 所以还应该将映射关系颠倒一下

```c++
#include<bits/stdc++.h>

using namespace std;

const int N=100010,M=1000010;	//节点个数  颜色个数
int n,m;
int h[M],e[N],ne[N],idx;	//h[M]为每种颜色头节点,这些数组存所有节点
int col[N],sz[M],p[M];	//每个节点颜色  每种颜色集合大小  映射:每种颜色对应哪个编号
int ans;

void add (int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

//地址引用,修改映射关系时,直接将p指向的方向也一并更改
void merge (int &x,int &y)
{
    if(x==y)return;
    
    //按照启发式合并的原理,小集合合并到大集合
    if(sz[x]>sz[y])swap(x,y);
    
    //将x全部修改为y
    for(int i=h[x];i!=-1;i=ne[i])
    {
        //如果颜色x出现的位置,周围有颜色y,那么分段减少
        int j=e[i];
        ans-=(col[j-1]==y)+(col[j+1]==y);
    }
    
    for(int i=h[x];i!=-1;i=ne[i])
    {
        //将颜色x集合内的所有元素的颜色都修改成y
        int j=e[i];
        col[j]=y;
        
        if(ne[i]==-1)
        {
            //到修改到了x集合的尾元素,ne指针指向y的头指针指向的位置
            //然后,将y头指针的指向,指向x头指针指向的位置
            //然后,x串没了,h[x]=-1,表示不指向任何位置
            //将x集合中元素个数加到y集合元素个数中,x集合中元素个数为x
            ne[i]=h[y],h[y]=h[x],h[x]=-1;
            sz[y]+=sz[x],sz[x]=0;
            break;
        }
    }
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<=n;i++)
    {
        cin>>col[i];
        if(col[i]!=col[i-1])ans++;
        add(col[i],i);
    }
    
    for(int i=0;i<M;i++)p[i]=i;
    while(m--)
    {
        int op;
        cin>>op;
        if(op==1)
        {
            int x,y;
            cin>>x>>y;
            merge(p[x],p[y]);
        }
        else cout<<ans<<'\n';
	}
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# Manacher算法

> Manacher算法是处理回文串的利器, 可在线性时间复杂度求解出最长回文子串

<br>

---

### 字符串预处理

> 为了解决奇数长度的回文串, 与偶数长度的回文串的不统一的问题, 我们对给定字符串 `S` 预处理, 即间隔插入分隔符 `#` , 如下所示:

````
原串  abaa  -->  新串  $#a#b#a#a#^
原串  abaabc  -->  新串  $#a#b#a#a#b#c#^
````

> 哨兵: 下标 `0` 的位置和末尾取了没有出现过的字符且首尾不相等, 就不用考虑边界了

<br>

---

### 引入p数组, rt, mid

> 预处理后的新串表示为 `Str` , 定义数组 `p[]` , `p[i]` 表示 `Str` 中以下标 `i` 为回文中心的最大回文半径
>
> 如果我们得到了 `p[i]` , 那么 `p[i] - 1` 就是新串 `Str` 以 `i` 为回文中心的对应回原串 `S` 的最大回文长度
>
> 现在我们来求解 `p[i]` , 定义 `rt` 表示已经计算过的回文串能达到的最远右边界的下一个位置. 即 `rt = max (j + p[j])` , `mid` 表示 `rt` 所对应的最左侧的回文中心, 有 `mid + p[mid] = rt` . 如下图所示:

![1](E:\个人博客\博客内容\算法竞赛\进阶算法\基础算法\Manacher算法\1.png)

<br>

---

### 计算p数组, 更新rt, mid

> 如何计算 `p[i]` , 显然有 `i > mid` (因为 `p[mid]` 已经计算过)
>
> 下面再分两种情况讨论:

<br>

##### 情况一: i < rt

![2](E:\个人博客\博客内容\算法竞赛\进阶算法\基础算法\Manacher算法\2.png)

此时我们发现, 可以用已知的 `p[j]` 的信息来辅助计算 `p[i]` 

`p[j]` 又有两种情况, 讨论如下:

<br>

一. 以 `j` 为中心的最大回文串被包含在以 `mid` 为中心的最大回文串中

![3](E:\个人博客\博客内容\算法竞赛\进阶算法\基础算法\Manacher算法\3.png)

二. 以 `j` 为中心的最大回文串没有被包含在以 `mid` 为中心的最大回文串中

![4](E:\个人博客\博客内容\算法竞赛\进阶算法\基础算法\Manacher算法\4.png)

根据以上两种情况, 可以写出如下代码:

```c++
if (i < rt) p[i] = min(p[2*mid-i],rt-i);
while (str[i + p[i]] == str[i - p[i]]) p[i]++;	//暴力扩展
```

<br>

##### 情况二: i >= rt

此时, 没有已知信息可以辅助计算了, 令 `p[i] = 1` 然后暴力扩展

根据上述分析, 可以写出如下代码:

```c++
if (i >= rt) p[i] = 1;
while (str[i + p[i]] == str[i - p[i]]) p[i]++; 	//暴力扩展
```

<br>

求解出 `p[i]` 后, 需要更新 `mid` 和 `rt` , 代码如下:

```c++
if (i + p[i] > rt)	//如果以i为中心的最大回文串能更新rt
{
    rt = i + p[i];
    mid = i;
}
```

<br>

---

### 算法模板

```c++
//预处理字符串
void init()
{
    int k = 0;
    str[k++] = '$', str[k++] = '#';
    for(int i = 0;i < n;i ++) str[k++] = s[i], str[k++] = '#';
    str[k++] = '^';
    n=k;
}

//马拉车算法
void manacher()
{
    int rt = 0, mid;
    for(int i = 0;i < n;i ++)
    {
        if(i < rt) p[i] = min(p[mid*2 - i], rt - i);
        else p[i] = 1;
        while(str[i - p[i]] == str[i + p[i]]) p[i]++;
        if(i + p[i] > rt)
        {
            rt = i + p[i];
            mid = i;
		}
    }
}
```



<div style="page-break-after:always;"></div>

# 最小表示法

> 给定一个字符串 `S` , 如果我们不断把最后一个字符放到开头, 最终会得到n个字符串, 我们称这n个字符串是循环同构的. 在这些字符串中, 字典序最小的一个, 即是 `S` 的最小表示

> 字符串最小表示法, 用于求循环同构串中字典序最小的字符串

<br>

---

### $O(n^2)$做法

> 将字符串 `a[n]` 扩大两倍, 得到 `b[2n]`
>
> 通过枚举所有起点, 得到长度为n的子串, 记录字典序最小的子串
>
> 就可以得到字符串的最小表示

<br>

---

### $O(n)$做法

> 用双指针维护, 可以将时间复杂度优化到 $O(n)$

```c++
void get_min (char a[])
{
    int n = strlen(a);	//原串长度
    static char b[N*2];		//注意:数组b[]的大小必须是常量const
    
    //获得2倍序列
    for(int i = 0;i < n*2;i++)b[i] = a[i % n];
    
    //设i为0, j为1, k记录长度
    int i = 0, j = 1, k;
    
    //如果i>=n或j>=n循环结束
    while(i < n && j < n)
    {
        //向后扫描
        for(k = 0;k < n && b[i+k] == b[j+k];k++)
            
        //如果k等于n,说明扫描了n个字符仍然相同,说明已经找到了最小表示
        if(k == n)break;
        
        //如果i+k位置的字符,大于j+k位置的字符,则跳过i后k个字符
        //因为这时以i~i+k为起点的长度为n的字符串一定都不是最小表示
        //j同理
        if(b[i+k] > b[j+k])
        {
            i += k+1;
            if(i == j)i++;
        }
        else
        {
            j += k+1;
            if(i == j)j++;
        }
    }
    
    //最终得到i和j的最小值,就是该字符串最小表示的起点
    k = min(i,j);
    
    for(int i = 0;i < n;i++)a[i] = b[i+k];
}
```



<div style="page-break-after:always;"></div>

# 打表

> 打表, 是一个信息学专用术语, 意指对一些题目, 通过打表技巧获得一个有序表或常量表, 来执行程序某一部分, 优化时间复杂度. 这种算法也可用于在对某种题目没有最优解法时, 用来得到分数的一种策略

<br>

> 因为交上去的程序运行时间有严格限制, 但是本机运行则时间可以很长. 所以提前用本机算出所有可能的数据的答案, 拷贝到代码里. 交上去的程序只用查表格就能得到答案
>
> 这种方法适用于数据范围较小的情况. 当然, 本机的运行时间也要可以接受
>
> 打表的代码, 一般来说是时间可以接受, 但又过不了的题目. 比如跑 $10^9$ , 一般跑 $10s$ , 对于时限 $1s$ 的测评机显然是不行的, 但是本机可以. 可是假如跑 $2^{100}$ 那本机也无法在有意义的时间内跑完
>
> 如果正解相当复杂, 而打表又可以获得较高的分数甚至满分, 在时间紧迫的赛场上是非常有用的
>
> 一般来说打表分为两部分: 打表程序和提交程序

<br>

> 例子: [洛谷 P1035 级数求和](https://www.luogu.com.cn/problem/P1035)

数据范围只有 $[1, 15]$ 且是正整数. 所以可以写出这样的打表代码:

```c++
#include<bits/stdc++.h>

using namespace std;

int f (int k)
{
    double i = 1, s = 0;
    while(s <= k)
    {
        s = s + 1/i;
        i++;
    }
    return i - 1;
}

int main()
{
    for(int i = 1;i <= 15;i++)
        cout << f(i) << ',';
}
```

运行后得到这样的结果:

```
2,4,11,31,83,227,616,1674,4550,12367,33617,91380,248397,675214,1835421,
```

拷贝到代码里:

```c++
#include<bits/stdc++.h>

using namespace std;

int a[] = {2,4,11,31,83,227,616,1674,4550,12367,33617,91380,248397,675214,1835421};
int k;

int main()
{
    cin >> k;
    cout << a[k-1] << endl;
    return 0;
}
```

<br>

---

> 打表是一种典型的用空间换时间的技巧, 一般指将所有可能需要用到的结果事先计算出来, 这样后面需要用到时就可以直接查表获得
>
> 打表常见的用法有如下几种:

<br>

> **① 在程序中一次性计算出所有需要用到的结果, 之后的查询直接取这些结果**
>
> 这个是最常用的用法, 例如在一个需要查询大量 $Fibonacci$ 数 `F(n)` 的问题中, 显然每次从头开始计算是非常耗时的, 对m次查询会产生 $O(nm)$ 的时间复杂度; 而如果进行预处理, 即把所有 $Fibonacci$ 数预先计算并存在数组中, 那么每次查询就只需 $O(1)$ 的时间复杂度, 对m次查询就只需要 $O(n+m)$ 的时间复杂度, 其中 $O(n)$ 是预处理的时间

<br>

> **② 在程序B中分一次或多次计算出所有需要用到的结果, 手动把结果写在程序A的数组中, 然后在程序A中就可以直接使用这些结果**
>
> 这种用法一般是当程序的一部分过程消耗的时间过多, 或是没有想到好的算法, 因此在另一个程序中使用暴力算法算出结果, 这样就能直接在源程序中使用这些结果. 例如对n皇后问题来说, 如果使用的算法不够好, 就容易超时, 而可以在本地用程序计算出对所有n来说n皇后的方案数, 然后把算出的结果直接写在数组中, 就可以根据题目输入的n来直接输出结果

<br>

> **③ 对一些感觉不会做的题目, 先用暴力程序计算小范围数据的结果, 然后找规律, 或许就能发现一些"蛛丝马迹"**
>
> 这种用法在数据范围非常大的时候容易用到, 因为这样的题目可能不是能用算法解决的, 而需要找到一些规律才能得到结果

<br>

---

> 打表适用的几种类型:
>
> ① 输入种数很少 (全部打表)
>
> ② $code$ 处理大部分情况, 少数处理不了的特判 (部分打表)
>
> ③ 配合打表, 常用于完成 `TLE` , `代码长` , `固定的` , `容易手算` 的预处理过程. 如 `矩阵乘法 + 快速幂`, `状态压缩` , `数位DP` , `字符串`

<br>

> 注意:
>
> ① 打表的题目尽早做
>
> 如采用模拟退火, 打表完成最优化问题, 程序跑的次数越多, 得到最优解的概率越大, 先完成这题的退火代码, 让程序在后台跑的时候, 再去完成其他题目, 最后再将模拟退火跑出来的数据打表提交
>
> ② 压缩代码长度



<div style="page-break-after:always;"></div>

# 最短路问题路径保存

### 单源最短路

> `pre[]` 数组记录路径, `pre[i] = j` 表示节点 `i` 取得最短路径时, 其最后一段走的是 `j ---> i`

<br>

##### 朴素dijkstra + 路径打印

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 510;
int g[N][N], dist[N], pre[N];
bool st[N];
int n,m;

void print (int pre[])
{
    int i = n;
    vector<int> tmp;
    tmp.push_back(n);
    
    while(pre[i] != -1)
    {
        tmp.push_back(pre[i]);
        i = pre[i];
    }
    
    int len = tmp.size();
    for(int i = len - 1; i >= 0; i--)
        if(i != 0) printf("%d -> ",tmp[i]);
    	else printf("%d",tmp[i]);
}

int dijkstra()
{
    memset(pre, -1, sizeof pre);
    memset(dist, 0x3f, sizeof dist);
    
    dist[1] = 0;	//节点1到自身的距离为0
    for(int i = 0; i < n; i++)
    {
        int t = -1;
        for(int j = 1; j <= n; j++)
        //找到此时dist数组中距源点距离最小的点(也就是dist数组中没有被标记的点中最小值的下标)
            if(!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        for(int j = 1; j <= n; j++)
        {
            //更新dist数组,从此时找到的点t开始扩展
            //dist[j] = min(dist[j],dist[t] + g[t][j]);
            if(dist[j] > dist[t] + g[t][j])
            {
                dist[j] = dist[t] + g[t][j];
                pre[j] = t;
            }
        }
        
        st[t] = true;	//标记已经访问过的点
    }
    
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    cin >> n >> m;
    
    memset(g, 0x3f3f3f3f, sizeof g);
    
    while(m--)
    {
        int a,b,c;
        cin >> a >> b >>c;
        g[a][b] = min(g[a][b], c);
    }
    
    printf("最短路径之和: %d\n",dijkstra());
    printf("最短路径: ");
    print(pre);
    
    return 0;
}
```

<br>


##### spfa + 路径保存

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1000010;

typedef long long LL;

LL dist[N];
int e[N], ne[N], h[N], w[N], idx;
bool st[N];
int pre[N], n, m;

void add (int a,int b,int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    queue<int> q;
    q.push(1);
    st[1] = true;
    pre[1] = -1;
    
    while(q.size())
    {
        int t = q.front();
        q.pop();
        
        st[t] = true;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                pre[j] = t;
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

void print (int x)	//递归求路径,适用于任何最短路算法的保存输出路径
{
    if(pre[x] == -1)
    {
        printf("%d",x);
        return;
    }
    
    print(pre[x]);
    printf(" -> %d",x);
}

int main()
{
    memset(h, -1, sizeof h);
    memset(pre, -1, sizeof pre);
    cin >> n >> m;
    
    while(m--)
    {
        int a,b,c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    int t = spfa();
    if(t == -1) cout << -1 << endl;
    else print(n);
    
    return 0;
}
```

<br>

---

### 多源汇最短路

> 矩阵p存储路径, `p[i][j] = k` 表示从 `i` 到 `j` 的最短路径要经过 `k` , 只需要在加入 `k` 时记录一下. 如 `p[1][3] = 2` 表示 `1 ---> 3` 要经过 `2` , 即顶点 `2` 是从 `1` 到 `3` 要经过的一个桥梁, 然后再考虑从 `1` 到 `2` 和从 `2` 到 `3` 需要经过哪些桥梁, 路径的输出可以用递归实现

<br>

##### Floyd + 路径输出

```c++
#include<bits/stdc++.h>

const int N = 1010;
int dist[N][N];
int p[N][N];
int n,m;

void path (int u, int v)
{
    if(p[u][v] == 0) return;
    
    path(u, p[u][v]);
    printf("%d -> ",p[u][v]);
    path(p[u][v],v);
}

int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++)
        for(int j = 1 ;j <= n; j++)
            if(i == j) dist[i][j] = 0;
    		else dist[i][j] = 0x3f;
    
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(dist[i][j] > dist[i][k] + dist[k][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    p[i][j] = k;
                }
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
        {
            printf("%d ---> %d\n",i,j);
            printf("dist[%d][%d] = %d\n",i,j,dist[i][j]);
            printf("path: ");
            
            if(p[i][j] == 0)
            {
                printf("%d -> %d\n\n",i,j);
                continue;
            }
            printf("%d -> ",i);
            path(i,j);
            printf("%d\n\n",j);
        }
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 数据读入

### 单行读入个数未知的多个数据

> [AcWing 920. 最优乘车](https://www.acwing.com/problem/content/description/922/)

![AcWing 920. 最优乘车](E:\个人博客\博客内容\杂谈\AcWing 920. 最优乘车.jpeg)

```c++
string line;
getline (cin, line);
while (m--)
{
    getline (cin, line);
    stringstream ssin (line);
    int cnt = 0, p;
    while (ssin >> p) stop[cnt++] = p;
}
```



<div style="page-break-after:always;"></div>

# 算法竞赛文件读写

> 【题目描述】 对于任意输入的三个整数中, 找出大小顺序处于中间的那个数
>
> 【输入格式】输入文件为 mid.in , 共一行, 即三个整数, 以空格间隔
>
> 【输出格式】 输出文件为 mid.out , 共一行, 即中间数
>
> 【输入样例】 1 2 3
>
> 【输出样例】 2
>
> 【时间限制】 1秒

<br>

```c++
#include <bits/stdc++.h>

using namespace std;

int main()
{
    freopen("mid.in", "r", stdin);	//从文件 mid.in 中读取数据
    freopen("mid.out", "w", stdout);	//程序运行会创建文件 mid.out 将结果写入
    
    int a, b, c;
    cin >> a >> b >> c;
    if((a - b) * (a - c) >= 0) cout << b << endl;
    else if((b - a) * (a - c) >= 0) cout << a << endl;
    else cout << c << endl;
    
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 求逆元的四种方法

### 逆元的定义

> 给定正整数 $a$ , $p$ , 如果有 $ax \equiv 1 (mod\ p)$ , 且 $a$ 与 $p$ 互质, 则称 $x$ 的最小正整数解为 $a$ 模 $p$ 的逆元

<br>

---

### 扩展欧几里得算法

> **使用条件:** 基本上通用, 不要求 $p$ 为质数, 且效率高, 时间复杂度为 $O(\log{n})$ 

> **证明过程:** $ax \equiv 1(mod \ p)$ 有解的条件是 $gcd(a, p) = 1$ , 即 $a$ , $p$ 互质, 所以根据扩展欧几里得原理, 就把问题等价于求解 $ax + py = 1$ , 就可以使用欧几里得算法了

```c++
void extend_gcd (LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1, y = 0;
        return;
    }
    extend_gcd (b, a % b, x, y);
    LL tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

LL mod_inverse (LL a, LL mod)
{
    LL x, y;
    extend_gcd (a, mod, x, y);
    return (x % mod + mod) % mod;
}
```

<br>

---

### 费马小定理

> **定理内容:** 如果 $p$ 是一个质数, 而整数 $a$ 不是 $p$ 的倍数, 则有 $a^{p - 1} \equiv 1 (mod \ p)$ 

> **使用条件:** 要求 $p$ 为质数, 效率也挺高, 但由于扩展欧几里得算法通常情况下更优, 因此该方法使用情况较少, 时间复杂度为 $O(\log{n})$ 

```c++
LL qmi (LL a, LL b, LL mod)
{
    LL res = 1;
    while(b)
    {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

LL fermat (LL a, LL mod)
{
    return qmi (a, mod - 2, mod);
}
```

<br>

---

### 欧拉定理

> **定理内容:** 设 $m, n \in N^{+}$ , 且 $gcd(a, m) = 1$ , 则有 $a^{\varphi(m)} \equiv 1 (mod \ m)$ , 其中 $\varphi(m)$ 称为对模 $m$ 缩系的元素个数

> **使用条件:** 不要求 $p$ 为质数, 这相当于费马小定理求逆元的扩展, 先求出欧拉函数, 再求逆元, 时间复杂度为 $O(\sqrt{n})$ 

```c++
LL qmi (LL a, LL b, LL mod)
{
    LL res = 1;
    while(b)
    {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

LL get_phi (LL n)
{
    LL res = n;
    for(int i = 2; i <= n / i; i++)
    {
        if(n % i == 0)
        {
            res = res / i * (i - 1);
            while(n % i == 0)
                n /= i;
        }
    }
    if(n > 1)
        res = res / n * (n - 1);
    return res;
}

LL mod_inverse (LL a, LL mod)
{
    if(a % mod != 0)
        return qmi (a, get_phi(mod) - 1, mod);
    else 
        return -1;
}
```

<br>

---

### 递推打表

> **递推公式:** $inv[i] = (mod - mod / i) * inv[mod \  \% \  i]$ 

> **使用条件:** 要求 $p$ 为质数, 时间复杂度为 $O(n)$ 

```c++
LL inv[N];	//逆元表

void mod_inverse (LL n, LL mod)
{
    inv[0] = inv[1] = 1;
    for(int i = 2; i <= n; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}
```



<div style="page-break-after:always;"></div>

# 扩展欧几里得求解不定方程

### 扩展欧几里得算法

> **裴蜀定理:** 若 $a$ , $b$ 是整数, 且 $gcd(a, b) = d$ , 那么对于任意的整数 $x$ , $y$ , $ax + by = m$ 中的 $m$ 一定是 $d$ 的倍数. (特别地, 如果 $a$ , $b$ 是整数, 那么一定存在整数 $x$ , $y$ 使得 $ax + by = gcd(a, b)$ )
>
> 裴蜀定理的直接应用: 如果 $ax + by = 1$ 有解, 那么 $gcd(a, b) = 1$ 

> 扩展欧几里得算法用来解决这样一个问题: 给定两个非零的整数 $a$ 和 $b$ , 求一组整数解 $(x, y)$ 使得 $ax + by = gcd(a, b)$ 成立, 其中 $gcd(a, b)$ 表示 $a$ 和 $b$ 的最大公约数
>
> 回忆我们知道的欧几里得算法, 它总是把 $gcd(a, b)$ 转化为求解 $gcd(b, a \%b)$ , 而当 $b$ 变为 $0$ 时返回 $a$ , 此时的 $a$ 就等于 $gcd$ . 也就是说, 欧几里得算法结束时变量 $a$ 中存放的是 $gcd$ , 变量 $b$ 中存放的是 $0$ , 因此此时显然有 $a \times 1 + b \times 0 = gcd$ , 此时有 $x = 1, y = 0$ 成立
>
> 我们不妨利用上面的欧几里得算法的过程来计算 $x$ 和 $y$ , 目前已知的是递归边界成立时为 $x = 1, y = 0$ , 需要想办法反推出最初始的 $x$ 和 $y$ 

> 当计算 $gcd(a, b)$ 时, 有 $ax_1 + by_1 = gcd$ 成立
>
> 而在下一步计算 $gcd(b, a \ \% \ b)$ 时, 又有 $bx_2 + (a \ \% \ b)y_2 = gcd$ 成立
>
> 因此 $ax_1 + by_1 = bx_2 + (a \ \% \ b)y_2$ 成立
>
> 又考虑到有关系 $a \ \% \ b = a - (a \ / \ b) \times b$  成立, 因此 $ax_1 + by_1 = ay_2 + b(x_2 - (a \ / \ b)y_2)$ 
>
> 对比等号左右两边可以得到下面的递推公式
> $$
> \begin{cases}
> x_1 = y_2 \\
> y_1 = x_2 - (a \ / \ b)y_2
> \end{cases}
> $$
> 由此便可以通过 $x_2$ 和 $y_2$ 来反推出 $x_1$ 和 $y_1$ 了

<br>

```c++
int exgcd (int a, int b, int &x, int &y)	//返回值是gcd(a, b)
{
    if(b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}
```

<br>

> 在得到一组解后, 可以通过下面的式子得到全部解 (其中 $K$ 为任意整数) :
> $$
> \begin{cases}
> x' = x + \dfrac{b}{gcd} \times K \\
> y' = y - \dfrac{a}{gcd} \times K 
> \end{cases}
> $$
> 假设新的解为 $x + s_1$ , $y - s_2$ , 即有 $a \times (x + s_1) + b \times (y - s_2) = gcd$ 成立
>
> 与 $ax + by = gcd$ 联立可以得到 $as_1 = bs_2$ , 于是 $\dfrac{s_1}{s_2} = \dfrac{b}{a}$ 成立
>
> 为了让 $s_1$ 和 $s_2$ 尽可能小, 可以让分子和分母同时除以一个尽可能大的数, 同时保证它们仍是整数. 显然, 由于 $\dfrac{b}{gcd}$ 和 $\dfrac{a}{gcd}$ 互质, 因此 $gcd$ 是允许作为除数的最大数, 于是 $\dfrac{s_1}{s_2} = \dfrac{b}{a} = \dfrac{b / gcd}{a / gcd}$ 
>
> 得 $s_1$ 和 $s_2$ 的最小取值就是 $\dfrac{b}{gcd}$ 和 $\dfrac{a}{gcd}$ 

> 也就是说, $x$ 和 $y$ 的所有解分别以 $\dfrac{b}{gcd}$ 与 $\dfrac{a}{gcd}$ 为周期
>
> 其中 $x$ 的最小非负整数解为 $(x \ \% \ \dfrac{b}{gcd} + \dfrac{b}{gcd}) \ \% \ \dfrac{b}{gcd}$ 
>
> 如果 $gcd = 1$ , 即 $ax + by = 1$ 时, 全部解的公式简化为下式, 且 $x$ 的最小非负整数解也可以简化为 $(x \% b + b) \% b$ 
> $$
> \begin{cases}
> x' = x + b \times K \\
> y' = y - a \times K
> \end{cases}
> $$

<br>

---

### 扩展欧几里得求方程 $ax + by = c$ 的通解

> 当知道 $ax + by = gcd$ 的解后, 最主要的应用就是: 求解 $ax + by = c$ 的通解, 其中 $c$ 为任意整数
>
> 方程 $ax + by = c$ 有解的充要条件是: $c \  \% \  gcd ==  0$ 

> 首先, 假设 $ax + by = gcd$ 有一组解 $(x_0, y_0)$ , 现在在其等号的左右两边同时乘以 $\dfrac{c}{gcd}$ 
>
> 即有 $a\dfrac{cx_0}{gcd} + b\dfrac{cy_0}{gcd} = c$ 成立, 因此 $(x, y) = ( \dfrac{cx_0}{gcd} , \dfrac{cy_0}{gcd})$ 是 $ax + by = c$ 的一组解
>
> 为了获取全部解的公式, 我们模仿前面的做法, 假设新的解为 $x + s_1$ , $y - s_2$ , 然后将 $a \times (x + s_1) + b \times (y - s_2) = c$ 与 $ax + by = c$ 联立, 发现同样可得 $\dfrac{s_1}{s_2} = \dfrac{b}{a}$ 成立, $s_1$ 和 $s_2$ 的最小取值仍然是 $\dfrac{b}{gcd}$ 和 $\dfrac{a}{gcd}$ 
>
> 因此 $ax + by = c$ 的通解为
> $$
> \begin{cases}
> x' = x + \dfrac{b}{gcd} \times K = \dfrac{cx_0}{gcd} + \dfrac{b}{gcd} \times K \\
> y' = y - \dfrac{a}{gcd} \times K = \dfrac{cy_0}{gcd} - \dfrac{a}{gcd} \times K
> \end{cases}
> $$



<div style="page-break-after:always;"></div>

# 三分

> 二分查找适用于单调函数中求逼近求解某点的值
>
> 三分查找用于求解单峰函数的凸点或凹点

![三分](E:\个人博客\博客内容\杂谈\三分.png)

> 如图所示, 已知左右端点 $L$ , $R$ , 要求找到凸点的位置
>
> 思路: 通过不断缩小 $[L, R]$ 的范围, 无限逼近凸点
>
> 做法: 先取 $[L, R]$ 的中点 $mid$ , 再取 $[mid, R]$ 的中点 $mmid$ , 通过比较 $f(mid)$ 和 $f(mmid)$ 的大小来缩小范围
>
> 但最后 $L = R + 1$ 时, 再比较下这两个点的值, 就找到了答案
>
> 以求凸点为例: 
>
> 1. 当 $f(mid) > f(mmid)$ 的时候, $mmid$ 一定在凸点的右边
> 2. 当 $f(mid) < f(mmid)$ 的时候, $mid$ 一定在凸点的左边

<br>

##### 算法模板

```c++
//整数三分 + 找凸点
int three_devide (int l, int r)
{
    while(l < r - 1)
    {
        int mid = (l + r) / 2;
        int mmid = (mid + r) / 2;
        if(f[mid] > f[mmid]) r = mmid;
        else l = mid;
    }
    return f[l] > f[r] ? l : r;
}
```

```c++
//浮点数三分 + 找凸点
double three_devide (double low, double up)
{
    double m1, m2;
    while(up - low >= eps)
    {
        m1 = low + (up - low) / 3;
        m2 = up - (up - low) / 3;
        if(f(m1) <= f(m2)) low = m1;
        else up = m2;
    }
    return (m1 + m2) / 2;
}
```

<br>

```c++
//整数三分 + 找凹点
int three_devide (int l, int r)
{
    while(l < r - 1)
    {
        int mid = (l + r) / 2;
        int mmid = (mid + r) / 2;
        if(f[mid] > f[mmid]) l = mmid;
        else r = mid;
    }
    return f[l] > f[r] ? r : l;
}
```

```c++
//浮点数三分 + 找凹点
double three_devide (double low, double up)
{
    double m1, m2;
    while(up - low >= eps)
    {
        m1 = low + (up - low) / 3;
        m2 = up - (up - low) / 3;
        if(f(m1) <= f(m2)) up = m2;
        else low = m1;
    }
    return (m1 + m2) / 2;
}
```



<div style="page-break-after:always;"></div>

# __int128 输入输出模板

```c++
#include <iostream>

using namespace std;

inline __int128 read()
{
    __int128 x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch - '0');
        ch = getchar();
    }
    return x * f;
}

void print (__int128 x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}

int main()
{
    __int128 x = read();
    print(x);
    return 0;
}
```



<div style="page-break-after:always;"></div>

# 求解斐波那契数列的若干方法

首先定义斐波那契数列问题:

> 定义 $a_0 = 1$ , $a_1 = 1$ , $a_n = a_{n - 1} + a_{n - 2}$ , 求 $a_n$ 是多少
>
> 为了避免考虑整数溢出问题, 我们求 $a_n \ \% \ p$ 的值, $p = 10^9 + 7$ 

<br>

---

### 算法1

递归

递归计算的节点个数是 $O(2^n)$ 的级别的, 存在大量重复计算.

时间复杂度是 $O(2^n)$ , 一秒内大约能算到第三四十项. 

```c++
const int mod = 1e9 + 7;
int f (int n)
{
    if(n <= 1) return 1;
    return (f(n - 1) + f(n - 2)) % mod;
}
```

<br>

---

### 算法2

记忆化搜索

开一个数组记录中间结果, 如果一个状态被计算过, 则直接查表, 否则再递归计算. 

总共有 $n$ 个状态, 计算每个状态的复杂度是 $O(1)$ , 所以时间复杂度是 $O(n)$ .

一秒内算 $n = 10^7$ 毫无压力, 但由于是递归计算, 递归层数太多会爆栈, 大约只能算到 $n = 10^5$ 级别.

```c++
const int N = 100010, mod = 1e9 + 7;
int a[N];
int f (int n)
{
    if(a[n]) return a[n];
    if(n <= 1) return 1;
    a[n] = (f(n - 1) + f(n - 2)) % mod;
    return a[n];
}
```

<br>

---

### 算法3

递推

开一个大数组, 记录每个数的值. 用循环递推计算.

总共计算 $n$ 个状态, 所以时间复杂度是 $O(n)$ .

但需要开一个长度是 $n$ 的数组, 内存将成为瓶颈, 当 $n = 10^8$ 时, 需要的内存是 $\dfrac{4 \times 10^8}{1024 \times 1024} \approx 381 MB$ .

分子中乘 $4$ 是因为 $C++$ 中 `int` 类型占 $4$ 字节.

```c++
const int N = 1e8, mod = 1e9 + 7;
int a[N];
int f (int n)
{
    a[0] = a[1] = 1;
    for(int i = 2; i <= n; i++)
        a[i] = (a[i - 1] + a[i - 2]) % mod;
    return a[n];
}
```

<br>

---

### 算法4

递推 + 滚动变量

仔细观察会发现, 递推时只需要记录前两项的值即可, 没有必要记录所有值, 所以可以用滚动变量递推.

时间复杂度还是 $O(n)$ , 但空间复杂度变成了 $O(1)$ .

```c++
const int mod = 1e9 + 7;
int f (int n)
{
    int x, y, z;
    x = y = 1;
    for(int i = 2; i <= n; i++)
    {
        z = (x + y) % mod;
        x = y, y = z;
    }
    return z;
}
```

<br>

---

### 算法5

矩阵运算 + 快速幂

用 **算法4** $1$ 秒内最多可以算到 $10^8$ 级别, 那当 $n$ 更大时该怎么办呢 ?

可以先利用矩阵运算的性质将通项公式变成幂次形式, 然后用平方倍增 (快速幂) 的方法求解第 $n$ 项.

首先定义向量 $X_n = [a_n \quad a_{n - 1}]$ , 边界: $X_1 = [a_1 \quad a_0]$ 

然后可以找出矩阵: $A = \begin{bmatrix}
 1 & 1 \\
 1 & 0
\end{bmatrix}$ , 则有: $X_n = X_{n - 1} \times A$ 

所以: $X_n = X_1 \times A^{n - 1}$ 

由于矩阵具有结合律, 所以可以先求出 $A^{n - 1} \ \% \ p$ , 然后再用 $X_1$ 左乘, 即可求出 $X_n$ , 向量 $X_n$ 的第一个元素就是 $a_n$ .

时间复杂度分析: 快速幂的时间复杂度是 $O(\log n)$ , 所以 **算法5** 的时间复杂度也是 $O(\log n)$. 

```c++
const int mod = 1e9 + 7;

void mul (int a[][2], int b[][2], int c[][2])
{
    int temp[][2] = {{0, 0}, {0, 0}};
    for(int i = 0; i < 2; i++)
        for(int j = 0; j < 2; j++)
            for(int k = 0; k < 2; k++)
            {
                LL x = temp[i][j] + (LL)a[i][k] * b[k][j];
                temp[i][j] = x % mod;
            }
    for(itn i = 0; i < 2; i++)
        for(int j = 0; j < 2; j++)
            c[i][j] = temp[i][j];
}

int f_final (LL n)
{
    int x[2] = {1, 1};
    
    int res[][2] = {{1, 0}, {0, 1}};
    int t[][2] = {{1, 1}, {1, 0}};
    LL k = n - 1;
    while(k)
    {
        if(k & 1) mul(res, t, res);
        mul(t, t, t);;
        k >>= 1;
    }
    
    int c[2] = {0, 0};
    for(int i = 0; i < 2; i++)
        for(int j = 0; j < 2; j++)
        {
            LL r = c[i] + (LL)x[j] * res[j][i];
            c[i] = r % mod;
        }
    
    return c[0];
}

int main()
{
    LL n;
    cin >> n;
    cout << f_final(n) << endl;
}
```



<div style="page-break-after:always;"></div>


# 动态规划专题

动态规划（简称dp），是指把一个问题分解为若干个子问题，通过局部最优解得到全局最优的一种算法策略或者说一种思想方法。简单来讲，就是用一个数组表示我们要求的问题的答案，如果你知道前一个问题的答案，你就可以推出后一个问题的答案。

 

---

### 1. 概述

在算法竞赛中，动态规划是一种非常重要且常见的算法或思想。动态规划常用于求解最优化问题，其核心在于将一个问题分解成若干个子问题，并且在对于这些分解的子问题自身就是最优的基础上，得到我们需要解决的问题的最优方案。这种由子问题最优推出全局最优的思想方法能用于解决许多问题，如背包问题、约瑟夫环问题等。

 

___

### 2. 简介

动态规划是一个典型的“空间换时间”的算法思想，将需要解决的问题分解成若干个子问题，用数组存储每个子问题的答案，并且确保每个子问题只被处理一遍，再由子问题的答案推出我们需要求解的问题的答案。

> 动态规划有以下三个常见的概念：
>
> 1. 状态：指当前所考虑的子问题的情况。例如背包的已用体积、区间的起止点，以及用状态压缩手段压缩后的状态。
> 2. 状态转移：指由前一个子问题的答案推出当前问题的答案。一般来讲，会由一个表示赋值的等式给出，成为状态转移方程。
> 3. 无后效性：指当前子问题的处理策略与后面问题的解答无关。

 

> 下面介绍处理动态规划问题常用的一个技巧——记忆化搜索。
>
> 搜索的低效在于没有能够很好地处理重叠子问题；动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起。
>
> 可以简单的理解为，记忆化搜索=搜索的形式+动态规划的思想
>
> 动态规划，就是一个最优化问题，先将问题分解为子问题，并且对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案，要不然的话就能找到一个更优的解来替代这个解，得出新的最优子问题，这当然是和前提是矛盾的。动态规划不同于贪心算法，因为贪心算法是从局部最优来解决问题，而动态规划是全局最优的。用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策，而是必须等待子问题得到了最优解之后才对当下的情况做出决策，所以往往动态规划都可以用一个或多个递归式来描述。而贪心算法却是先做出一个决策，然后再去解决子问题。这就是贪心和动态规划的不同。
>
> 动态规划的一种变形就是记忆化搜索，就是根据动态规划方程写出递归式，然后在函数的开头直接返回以前计算过的结果，当然这样做也需要一个存储结构记下前面计算过的结果（空间换时间），所以又称为记忆化搜索。

 

---

### 3. 步骤

> 动态规划一般有以下三个步骤：
>
> 1. 设计状态：指设计出合适的dp数组以及规定dp数组的含义。设计出的dp数组要能够形容各种状态并且无后效性地在状态之间进行转移。
> 2. 推理状态转移方程：顾名思义，关键在于如何从已知问题的答案推出当前问题的答案，有的时候需要多个方程，有的时候一个方程要包含多个子状态。
> 3. 确定边界条件：递推的初值或者记忆化搜索的回溯条件，以及各个数组的初值。

 

---

### 4. 经典问题

##### （1）背包问题

背包问题是动态规划问题的一类经典问题，其中包括多种背包问题：01背包问题、完全背包问题、多重背包问题、混合背包问题、二位费用的背包问题、分组背包问题、树上背包问题、背包问题求解方案数、背包问题求解具体方案（俗称背包九讲）。

下面通过[01背包问题](https://www.acwing.com/problem/content/2/)，分析如何用动态规划思想解决背包问题。

 ````
 1. 题目介绍
 有 N件物品和一个容量是 V的背包。每件物品只能使用一次。第 i件物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
 
 输入格式
 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i件物品的体积和价值。
 
 输出格式
 输出一个整数，表示最大价值。
 
 数据范围
 0<N,V≤1000
 0<vi,wi≤1000
 ````

````
2. 代码分析

（Ⅰ）状态f[i][j]定义：前i个物品，背包容量j下的最优解（最大价值）：

·当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0]=0开始决策，有N件物品，则需要N次决策，每一次对第i件物品的决策，状态f[i][j]不断由之前的状态更新而来。

（Ⅱ）当前背包容量不够（j＜v[i]），没得选，因此前i个物品最优解即为前i-1个物品最优解：

        ·对应代码：f[i][j]=f[i–1][j]

（Ⅲ）当前背包容量够，可以选，因此需要决策选与不选第i个物品：

       ·选：f[i][j]=f[i–1][j–v[i]]+w[i] 

       ·不选：f[i][j]=f[i–1][j] 

       ·我们的决策是如何取到最大价值，因此以上两种情况取max（）
````

 ````c++
 //3. 代码实现
 #include<bits/stdc++.h>
 
 using namespace std;
 
 const int N = 1005;
 int v[N];    // 体积
 int w[N];    // 价值 
 int f[N][N];  // f[i][j], j体积下前i个物品的最大价值 
 
 int main() 
 {
     int n, m;   
     cin >> n >> m;
     for(int i = 1; i <= n; i++) 
         cin >> v[i] >> w[i];
 
     for(int i = 1; i <= n; i++) 
         for(int j = 1; j <= m; j++)
         {
             //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
             if(j < v[i]) 
                 f[i][j] = f[i - 1][j];
             // 能装，需进行决策是否选择第i个物品
             else    
                 f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
         }           
 
     cout << f[n][m] << endl;
 
     return 0;
 }
 ````

````
4. 代码优化

将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。我们定义的状态f[i][j]可以求得任意合法的i与j的最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。

（Ⅰ）状态f[j]定义：N件物品，背包容量j下的最优解。

（Ⅱ）注意枚举背包容量j必须从m开始。

（Ⅲ）一维状态下枚举背包容量需要逆序枚举。在二维情况下，状态f[i][j]是由上一轮i–1的状态得来的，f[i][j]与f[i–1][j]是独立的。而优化到一维后，如果我们还是正序枚举，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i–1轮的状态却用的第i轮的状态。

状态转移方程为：f[j]=max(f[j], f[j–v[i]]+w[i])
````

````c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1005;
int v[N];    // 体积
int w[N];    // 价值 
int f[N];  // f[j], j体积下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = m; j >= 1; j--)		 //一维状态下需要逆序枚举背包容量 
            f[j] = max(f[j], f[j - v[i]] + w[i]); 

    cout << f[m] << endl;

    return 0;
}
````



##### （2）线性DP问题

>  线性dp往往指在一个序列上进行的dp，当然也可能由两个甚至多个序列。一般来讲，线性dp的三个步骤分别有以下特点：
>
>  设计状态：至少有一维表示当前考虑的对象在数列上的位置。
>
>  状态转移：必须找到这条线上前面的位置的dp值来推出当前位置的dp值。
>
>  边界条件：第一个位置单独讨论。

 

常见的线性dp问题有：数字三角形模型、最长上升子序列、最长公共子序列、最短编辑距离等。下面以[最短编辑距离](https://www.acwing.com/problem/content/904/)为例，介绍线性dp的思想方法。

 ````
 1. 题目介绍
 给定两个字符串 A 和 B，现在要将 A经过若干操作变为 B，可进行的操作有：
 1.删除–将字符串 A中的某个字符删除。
 2.插入–在字符串 A的某个位置插入某个字符。
 3.替换–将字符串 A中的某个字符替换为另一个字符。
 现在请你求出，将 A变为 B至少需要进行多少次操作。
 
 输入格式
 第一行包含整数 n，表示字符串 A的长度。
 第二行包含一个长度为 n的字符串 A。
 第三行包含整数 m，表示字符串 B 的长度。
 第四行包含一个长度为 m的字符串 B。
 字符串中均只包含大小写字母。
 
 输出格式
 输出一个整数，表示最少操作次数。
 
 数据范围
 1≤n,m≤1000
 ````

````
2. 代码分析
状态定义：f[i][j]表示第一个字符串的前i个字符变为第二个字符串的前j个字符所用的最少操作次数。

分析状态转移方程：把第一个字符串的前i个字符变成第二个字符串的前j个字符，有三种方法：

·把第一个字符串的前i个字符变成第二个字符串的前j–1个字符，然后在第一个字符串后面添加第二个字符串的第j个字符。

这种情况下，f[i][j]=f[i][j–1]+1

·把第一个字符串的前i–1个字符变成第二个字符串的前j个字符，然后去掉最后一个字符。

这种情况下，f[i][j]=f[i–1][j]+1

·把第一个字符串的前i–1个字符变成第二个字符串的前j–1个字符。变化之后，对比最后一个字符，如果相等，则变化完成，如果不同，把第一个字符串的最后一个字符变成第二个字符串的最后一个字符。

这种情况下，f[i][j]=f[i–1][j–1]+1（最后一个字符不同）或f[i][j]=f[i–1][j+1] （最后一个字符相同）

取三种情况的最小值，就是f[i][j] 
````

 ````c++
 //3. 代码实现
 #include <bits/stdc++.h> 
 
 using namespace std;
 
 const int N = 1010;
 
 int n , m;
 char a[N] , b[N];
 int f[N][N];//f[i][j]表示把a[1~i]变成b[1~j]需要的最少操作数
 
 int main()
 {
     cin >> n >> a + 1 >> m >> b + 1;
     //需要初始化边界情况
     for(int i = 0 ; i <= m ; i++)   f[0][i] = i;//把a[0]变成b[1~i]需要i步
     for(int i = 0 ; i <= n ; i++)   f[i][0] = i;//把a[1~i]变成b[0]需要i步
 
     //因为初始了边界情况，因此直接从1开始
     for(int i = 1 ; i <= n ; i++)
         for(int j = 1 ; j <= m ; j++)
         {
             f[i][j] = min(f[i - 1][j] + 1 , f[i][j - 1] + 1);//①②情况不需要判断直接执行
             if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]);
             else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
         }
 
     cout << f[n][m] << endl;
     return 0;
 }
 ````



##### （3）区间DP问题

区间dp可以视作线性dp的一个分支，之所以把它单独列出来是因为区间dp的解法比较特殊，同时也比较固定。区间dp与其他线性dp不同的地方在于它的状态是以序列上的一个区间来表示的，而且大区间的答案可以从小区间的答案得到。

 

> 区间dp的基本思路：
>
> 设计状态：至少要有dp [ l ] [ r ] 两维分别表示区间的左端点和右端点。
>
> 状态转移：一般通过枚举区间[ l , r ] 之间的点k把[ l , r ] 分成[ l , k ] 和[ k + 1 , r ] ，然后用dp [ l ] [ k ] 和dp [ k + 1 ] [ r ] 推出dp [ l ] [ r ]。
>
> 边界条件：区间l == r 时dp [ l ] [ r ] 可以从a [ l ] 得出（或者为初值）。



> 区间dp的枚举顺序往往很有趣。根据dp顺序的原则，执行赋值时等号右边的dp值一定要是已经算出来了的结果。所以如果只是简单地从1~n分别枚举l，r，k就会出错，这里给出两种常用的枚举方法：
>
> Ⅰ.首先枚举长度len：1\~n；然后枚举起点l：1\~n；这样可以算出终点r = l + len - 1；最后枚举断点k：l\~r。注意终点r不等大于序列总长度n。
>
> Ⅱ.首先倒序枚举起点l：n\~1；然后枚举终点r：l\~n；最后枚举断点k：l\~r。
>
> 如果两种枚举都不喜欢，那么也可以用记忆化搜索。

 

下面通过一道[区间dp](https://www.acwing.com/problem/content/284/)的题目，介绍区间dp与线性dp的区别，以及区间dp的思想方法。

 ````
 1. 题目介绍
 设有 N堆石子排成一排，其编号为 1,2,3,…,N。
 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。
 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
 例如有 4堆石子分别为 1 3 5 2， 我们可以先合并 1、2堆，代价为 4，得到 4 5 2， 又合并 1、2堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；
 如果第二步是先合并 2、3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。
 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。
 
 输入格式
 第一行一个数 N表示石子的堆数 N。
 第二行 N 个数，表示每堆石子的质量(均不超过 1000)。
 
 输出格式
 输出一个整数，表示最小代价。
 
 数据范围
 1≤N≤300
 ````

````
2. 代码分析
状态定义：f[i][j]表示将第i堆石子到第j堆石子合并成一堆石子的合并方式所需要的最小代价。

推导状态转移方程：我们需要思考的是，在确定集合为将i到j堆石子合并的方式后，需要考虑如何堆这个集合进行划分，使得其是我们可以表示出来的。我们可以发现，不管集合是如何划分的，最后一定会剩下两堆，然后把这两堆合并成一堆，所以我们可以以最后一次合并的分界线的位置来进行集合的分类。我们将集合分成若干类是以最后一步是将左边的哪一部分与右边的哪一部分进行了合并，以这个分界线来分类，总共的代价就是每一类的最小代价再取一个min，每一步的最小代价就是左边的最小代价加上右边的最小代价再加上最后一步的最小代价。
````

 ````c++
 //3. 代码实现
 #include < bits/stdc++.h > 
 
 using namespace std;
 
 const int N = 1010;
 int s[N]; // 维护前缀和数组 
 int f[N][N];	//f[i][j]表示将第i堆石子到第j堆石子合并成一堆石子的合并方式 
 
 int main()
 {
     int n;
     cin >> n;
     for(int i = 1; i <= n; i++) cin >> s[i];
 
     // 计算前缀和
     for(int i = 1; i <= n; i++) s[i] += s[i-1];
 
     // 枚举所有状态
     // 长度从小到大来枚举所有状态
     // 区间长度为1时合并不要代价,所以区间长度从2开始
     for(int len = 2; len <= n; len++)
     // 枚举完长度枚举一下起点
         for(int i = 1; i <= n-len+1; i++)
         {
 
             int l = i, r = i + len -1; 
             // 因为是取min值,所以先将f[l][r]置为无穷
             f[l][r] = 0x3f3f3f3f;
             // 枚举一下分界点,构造状态转移方程
             for(int k = l; k < r; k++) // k从l到r-1
                 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
         }
     cout << f[1][n] << endl;
     return 0;
 }
 ````



##### （4）状态压缩DP问题

dp的时候需要设计状态，但是有的状态会很复杂。对于复杂的状态，也许就不能再像其他题目那样用一个i简单表示。或许这个状态表示一个有n（n≤16）个元素的集合，甚至包含了每一个元素的情况。为了应对这种情况，我们可以利用状态压缩和位运算，让一个数字表示一个集合。

> 状压dp也需要三个步骤：
>
> 设计状态：至少有一维是用一个数字（二进制）表示一个集合。
>
> 状态转移：考察每一个决策对集合的影响，经常使用位运算进行位移。
>
> 边界条件：当集合为空或者只有一个元素之类的。
>
> 特别注意：状压是指数级算法，所以适合状压的题往往有一个维度的数字很小。



接着通过一道[例题](https://www.acwing.com/problem/content/293/)，介绍状态压缩dp的解题方法。

 ````
 1. 题目介绍
 求把 N×M的棋盘分割成若干个 1×2的长方形，有多少种方案。
 例如当 N=2，M=4时，共有 5种方案。当 N=2，M=3时，共有 3种方案。
 如下图所示：
 ````

![Acwing 291.蒙德里安的梦想](E:\个人博客\博客内容\杂谈\Acwing 291.蒙德里安的梦想.jpg)

 ````
 输入格式
 输入包含多组测试用例。
 每组测试用例占一行，包含两个整数 N 和 M。
 当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。
 
 输出格式
 每个测试用例输出一个结果，每个结果占一行。
  
 数据范围
 1≤N,M≤11
 ````

````
2. 代码分析
本题等价于找到所有横放1×2小方格的方案数，因为所有横放确定了，那么竖放方案是唯一的。

用f [i][j]记录第i列第j个状态。J状态位等于1表示上一列有横放格子，本列有格子捅出来。转移方程即为，本列的每一个状态都由上列所有“合法”状态转移过来，f[i][j]+=f[i–1][k]。

两个转移条件：i列和i-1列同一行不能同时捅出来；本列捅出来的状态j和上一列捅出来的状态k求异或，得到上一列的连续空行的奇偶性，只有连续空行都是偶数材能放置竖放小方格，即合法。

初始化条件f[0][0]=1，第0列只能是状态0，无任何格子捅出来。最终答案存储在f[m][0]中，第m+1列不能有任何格子捅出来。

 
````

````c++
//3. 代码实现
#include<bits/stdc++.h>

using namespace std;

const int N = 12, M = 1 << N;
int st[M];
long long f[N][M];

int main()
{
    int n, m;
    while (cin >> n >> m && (n || m))
    {
        for (int i = 0; i < 1 << n; i ++)
        {
            int cnt = 0;
            st[i] = true;
            for (int j = 0; j < n; j ++)
                if (i >> j & 1)
                {
                    if (cnt & 1) st[i] = false; 	
                    // cnt 为当前已经存在多少个连续的0
                    cnt = 0;
                }
                else cnt ++;
            if (cnt & 1) st[i] = false; 	// 扫完后要判断一下最后一段有多少个连续的0
        }

        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i <= m; i ++)
            for (int j = 0; j < 1 << n; j ++)
                for (int k = 0; k < 1 << n; k ++)
                    if ((j & k) == 0 && (st[j | k])) 
                    // j & k == 0 表示 i 列和 i - 1列同一行不同时捅出来
                    // st[j | k] == 1 表示在i列状态 j ,i - 1列状态 k 的情况下是合法的
                        f[i][j] += f[i - 1][k];      
        cout << f[m][0] << endl;
    }
    return 0;
}
````

 

##### （5）树形DP问题

> 树形dp是一类基于树形结构的动态规划的问题，树形dp也和其他动态规划题目相同，一般需要经过三个步骤。
>
> 状态设计：至少有一维表示当前正在考虑的树上节点p
>
> 状态转移：一般使用递归（深搜）由p的子节点的dp值得出p的dp值
>
> 边界条件：叶子节点没有子节点，可以只由叶子节点的值得出叶子的dp值

 

通过一道经典的[树形dp问题](https://www.acwing.com/problem/content/287/)，介绍树形dp的思想。

 ````
 1. 题目介绍
 Ural 大学有 N名职员，编号为 1∼N。
 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。
 每个职员有一个快乐指数，用整数 Hi给出，其中 1≤i≤N。
 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。
 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。
 
 输入格式
 第一行一个整数 N。
 接下来 N 行，第 i 行表示 i 号职员的快乐指数 Hi。
 接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。
 
 输出格式
 输出最大的快乐指数。
 
 数据范围
 1≤N≤6000，−128≤Hi≤127
 ````

````
2. 代码分析
状态定义：每个人只有两种状态，则设dp[0][i]为第i个人不来，他的下属所能获得的最大快乐值；dp[1][i]为第i个人来，他的下属所能获得的最大快乐值。
所以容易推出状态转移方程：
````

`dp[0][1] ` = $\sum\limits_{u=son}$max (`dp[1][u]` , `dp[0][u]` ) , 当前节点不选, 那么子节点可以选, 也可以不选; 

`dp[1][i]` = $\sum\limits_{u=son}$ `dp[0][u]` + `happy[i]` , 当前节点选, 子节点不能选.

````
分析可得，每个人的状态要在下属的状态更新完了才能更新，所以用类似拓扑的方法，只记录每个节点的父节点，最后从所有入度为0的点开始搜索即可。
````

 ````c++
 //3. 代码实现
 #include <bits/stdc++.h> 
 
 using namespace std;
 
 const int N = 6010;
 int n;
 int happy[N]; 		//每个职工的高兴度
 int f[N][2]; 		//每一个节点的状态
 int e[N],ne[N],h[N],idx; 
 bool has_father[N]; 	//判断当前节点是否有父节点
 
 void add(int a,int b)	//在节点a，b之间添加一条有向边 
 { 	
     e[idx] = b,ne[idx] = h[a],h[a] = idx ++;
 }
 
 void dfs(int u)		//从入度为0的点开始搜索 
 { 
     f[u][1] = happy[u]; //如果选当前节点u，就可以把f[u,1]先加上他的高兴度
     for(int i = h[u];i != -1;i = ne[i])	//遍历树
     { 
         int j = e[i];
         dfs(j); //回溯
         //状态转移部分
         f[u][0] += max(f[j][1],f[j][0]);
         f[u][1] += f[j][0];
     }
 }
 
 int main()
 {
     cin >> n;
     for(int i = 1;i <= n;i ++) cin >> happy[i]; 
     memset(h,-1,sizeof h); 
     for(int i = 1;i < n;i ++)
     {
         int a,b; //对应题目中的L,K,表示b是a的上司
         cin >> a >> b; 
         has_father[a] = true; 
         add(b,a); //从b向a连一条有向边 
     }
     
     int root = 1; 
     while(has_father[root]) root ++; 
     dfs(root); //从根节点开始搜索
     cout << max(f[root][0],f[root][1]); //输出不选根节点与选根节点的最大值
     return 0;
 }
 ````



---

### 5. 结语

> 动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
>
> 与其说动态规划是某种具体的算法，不如说其是一种解决特定问题的方法，它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。
>
> 能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

 

> 最优子结构
>
> 具有最优子结构也可能是适合用贪心的方法求解。
>
> 注意要确保我们考察了最优解中用到的所有子问题。
>
> 1.证明问题最优解的第一个组成部分是做出一个选择；
>
> 2.对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
>
> 3.给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
>
> 4.证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。
>
> 要保持子问题空间尽量简单，只在必要时扩展。
>
> 最优子结构的不同体现在两个方面：
>
> 1.原问题的最优解中涉及多少个子问题；
>
> 2.确定最优解使用哪些子问题时，需要考察多少种选择。
>
> 子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

> 无后效性
>
> 已经求解的子问题，不会再受到后续决策的影响。

> 子问题重叠
>
> 如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

 

> 基本思路
>
> 对于一个能用动态规划解决的问题，一般采用如下思路解决：
>
> 1.将原问题划分为若干 阶段，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 状态）；
>
> 2.寻找每一个状态的可能 决策，或者说是各状态间的相互转移方式（用数学的语言描述就是 状态转移方程）。
>
> 3.按顺序求解每一个阶段的问题。
>
> 如果用图论的思想理解，我们建立一个 有向无环图，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题。



<div style="page-break-after:always;"></div>

# 交互题专题

## 前言

交互题是一类特殊的算法题, 每次输入数据, 系统都会给出数据进行反馈, 需要通过系统反馈的数据, 得到某个答案. 交互题在蓝桥杯和OI比赛中都不会考察, CF偶尔会有交互题. 交互题的输入输出比较特别, 需要了解交互题独有的输入输出格式. 最近参加的团队程序设计天梯赛, 模拟赛中考察了交互题, 觉得交互题还是有必要记录一下的.



<br>

---

## 交互题介绍

通俗来讲, 交互题与平时题目的输入输出反过来, 是让你设计程序去向用户提出询问, 由用户给出答案, 并且在这基础上由程序推断出正确答案的一种形式.

C++的交互题, 每次输出后都得加 `fflush(stdout)`

<br>

>**交互题的特殊错误:**
>
>+ 选手每一次输出后都需要刷新缓冲区, 否则会引起 Idleness limit exceeded 错误. 另外, 如果题目含多组数据并且数据可以在未读入所有数据前就知道答案, 也仍然要读入所有数据, 否则同样会因为读入混乱引起 ILE (可以一次提出多次询问, 一次接收所有询问的回答). 同时尽量不要使用快读.
>+ 如果程序查询次数过多, 则在 Codeforces 上会给出 Wrong Answer 的评测结果(不过评测系统会说明 Wrong Answer 的原因), 而 UVA 会给出 Protocol Limit Exceeded (PLE) 的评测结果.



<br>

___

## 例题

**[Codeforces Round 356 (Div. 1)  A. Bear and Prime 100](https://codeforces.com/contest/679/problem/A)**

![Codeforces Round 356  A](E:\个人博客\博客内容\题解\交互题专题\Codeforces Round 356  A.jpeg)

<div style="page-break-after:always;"></div>

> 题目大意: 系统生成了一个数, 你需要在20次询问内给出这个数是质数还是合数. 每次询问一个数, 它会回答这个数是不是它的因数.

> 思路: 询问[2, 50] 内的质数, 如果该质数x是它的因数, 则继续询问$x^{2}$是不是它的因数(判断是否这个数就是这个质数x), 若该数在[2, 100] 范围内有两个及以上的因数, 则为合数. 若只有一个因数(它本身), 则为质数.

注意: C++的交互题, 每次输出后都得加 `fflush(stdout)`

<br>

````c++
#include<iostream>
#include<algorithm>

using namespace std;

bool is_prime(int x)
{
    for(int i=2;i<=x/i;i++)
        if(x%i==0)return false;
    return true;
}

bool divisible(int x)
{
    cout<<x<<'\n';
    fflush(stdout);
    string str;
    cin>>str;
    if(str=="yes")return true;
    else return false;
}

int main()
{
    int maxx=100;
    int cnt=0;
    
    for(int i=2;i<=maxx/2;i++)
        if(is_prime(i))
        {
            if(divisible(i))
            {
                cnt++;
                if(i*i<=maxx)
                    if(divisible(i*i))cnt++;
            }
        }
    
    if(cnt>=2)cout<<"composite"<<'\n';
    else cout<<"prime"<<'\n';
    fflush(stdout);
    
    return 0;
}
````



<br>

---

**[Codeforces Round 859 (Div. 4) E. Interview](https://codeforces.com/contest/1807/problem/E)**

![Codeforces Round 859 E](E:\个人博客\博客内容\题解\交互题专题\Codeforces Round 859 E.jpeg)

<div style="page-break-after:always;"></div>

> 题目大意: 给定n堆石头, 并告诉你第i堆石头的重量是a~i~, 但实际上有一堆石头的重量比告知的大1, 需要在30次询问内, 找出这是第几堆石头. 每次询问, 先输入询问的石头堆数, 再输入石头堆的下标, 系统会回答这些石头实际的总重量.

> 思路: 二分、前缀和

<br>

````c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N=200010;
int a[N],s[N];

bool ask(int l,int r)
{
    cout<<"?"<<' ';
    cout<<r-l+1<<' ';
    for(int i=l;i<=r;i++)cout<<i<<' ';
    fflush(stdout);
    
    long long sum=s[r]-s[l-1];
    long long ans;
    cin>>ans;
    return sum==ans;
}

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            s[i]=s[i-1]+a[i];
        }
        
        int l=1,r=n;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(ask(l,mid))l=mid+1;
            else r=mid;
        }
        cout<<"!"<<' '<<l<<'\n';
        fflush(stdout);
    }
    return 0;
}
````



<br>

---

**[Technocup 2017 - Elimination Round 1 (Unofficially Open for Everyone, Rated for Div. 2)](https://codeforces.com/contest/727/problem/C)**

![Technocup 2017 - Elimination Round 1  C](E:\个人博客\博客内容\题解\交互题专题\Technocup 2017 - Elimination Round 1  C.jpeg)

<div style="page-break-after:always;"></div>

> 题目大意: 系统生成了一个长度为n ($n\ge$ 3) 的数列, 你需要经过不超过n次询问, 猜出这个数列. 每次询问, 你可以输入两个下标 i 和 j (i $\neq$ j , 且 i , j 都属于1到n) , 系统会回复a~i~ + a~j~ 的和. 

> 思路: 先询问 a~1~ + a~2~ , a~2~ + a~3~ , a~3~ + a~1~ , 得到 a~1~ , a~2~ , a~3~ 的值, 之后(n - 3)次, 每次询问a~1~ 和 a~i~ , 得到 a~i~ 的值.

<br>

````c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N=5010;
int a[N];
int n;

int main()
{
    cin>>n;
    
    int one,two,three,sum;
    cout<<"? 1 2"<<'\n';
    fflush(stdout);
    cin>>three;
    cout<<"? 1 3"<<'\n';
    fflush(stdout);
    cin>>two;
    cout<<"? 2 3"<<'\n';
    fflush(stdout);
    cin>>one;
    sum=(one+two+three)/2;
    a[1]=sum-one;
    a[2]=sum-two;
    a[3]=sum-three;
    
    for(int i=4;i<=n;i++)
    {
        cout<<"? 1 i"<<'\n';
        fflush(stdout);
        int x;
        cin>>x;
        a[i]=x-a[1];
    }
    
    cout<<"!"<<' ';
    for(int i=1;i<=n;i++)cout<<a[i]<<' ';
    fflush(stdout);
    
    return 0;
}
````



<br>

---

**[Codeforces Round 878 (Div. 3) G. In Search of Truth](https://codeforces.com/contest/1840/problem/G2)**

![G2. In Search of Truth (Hard Version)](E:\编程\CodeForces\Codeforces Round 878 (Div. 3)\G2. In Search of Truth (Hard Version).jpeg)

<div style="page-break-after:always;"></div>

> 题目大意: 有一个幸运大转盘, 分成 $n$ 块. 每块上面都有一个 $1$ 到 $n$ 的数字, 每块的数字都不同. 一开始, 指针指向数字 $x$ , 但你不知道 $n$ 是多少. 你可以询问评测机, 顺时针/ 逆时针旋转 $k$ 次后, 指针指向的数字是多少. 你可以询问至多 $2023(easy)$ 或 $1000(hard)$ 次. 你需要找到 $n$ 是多少.

> 思路: 
>
> $easy$ 版本$(2023次询问)$ : 先询问 $999$ 次 `+ 1` , 得到 $a_1, a_2, a_3 \dots , a_{1000}$ 的值, 然后询问 $1000$ 次 `+ 1000` , 由于后面询问的跨度为 $1000$ , 所以如果遇到重复的数, 一定会落在 $[a_1, a_{1000}]$ 区间内. 
>
> $hard$ 版本$(1000次询问)$ : 先随机走 $333$ 次, 确定 $n$ 的大致范围, 记录走到的最大的数字为 $m$ ,  那么最终的 $n$ 不会比 $m$ 大很多, 有 $n - m \le 333 \times 333$ . 然后走 $333$ 次 `+ 1` . 随后利用性质, 逆时针转 $n - m$ 次等价于顺时针转 $m$ 次, 走 $1$ 次 `+ m` . 最后走 $333$ 次 `+ 333`.

<br>

```c++
/*****************************************************
                      easy版本
*****************************************************/
#include<bits/stdc++.h>

#define endl '\n'

using namespace std;

int main()
{
    map<int,int>a;

    int x;
    cin >> x;
    a[x] = 1;

    for(int i = 2; i <= 1000; i++)
    {
        cout << "+ 1" <<endl;
        fflush(stdout);

        cin >> x;
        if(a[x])
        {
            cout << "! " << i - 1 <<endl;
            fflush(stdout);
            return 0;
        }

        a[x] = i;
    }

    for(int i = 1; i <= 1000; i++)
    {
        cout << "+ 1000" <<endl;
        fflush(stdout);

        cin >> x;
        if(a[x])
        {
            int ans = (i + 1) * 1000 - a[x] ;
            cout << "! " << ans << endl;
            return 0;
        }
    }
}

/*****************************************************
                      hard版本
*****************************************************/
#include<bits/stdc++.h>

#define endl '\n'

using namespace std;

const int N = 333;
int m = 1;

int main()
{
    map<int,int>a;

    int x;
    cin >> x;
    m = max(x, m);

    for(int i = 0; i < N; i++)
    {
        int p = (int)(1.0 * rand() / RAND_MAX * 1e9);
        cout << "+ " << p << endl;
        cin >> x;
        m = max(x, m);
    }

    for(int i = 1; i <= N ; i++)
    {
        cout << "+ 1" <<endl;
        fflush(stdout);

        cin >> x;
        if(a[x])
        {
            cout << "! " << i - 1 <<endl;
            fflush(stdout);
            return 0;
        }

        a[x] = i;
    }

    cout << "+ " << m <<endl;
    fflush(stdout);
    cin >> x;
    if(a[x])
    {
        int ans = N + m - a[x] ;
        cout << "! " << ans <<endl;
        fflush(stdout);
        return 0;
    }

    for(int i = 1; i <= N; i++)
    {
        cout << "+ " << N << endl;
        fflush(stdout);

        cin >> x;
        if(a[x])
        {
            int ans = (i + 1) * N + m - a[x] ;
            cout << "! " << ans << endl;
            return 0;
        }
    }
}
```



<div style="page-break-after:always;"></div>

# 对拍器

### 以01背包问题为例

```c++
//dp.cpp

#include<iostream>
#include<cstdio>

using namespace std;

const int N=1010;
int dp[N];

int main()
{
	int n,m;
	cin>>n>>m;
	
	for(int i=0;i<n;i++)
	{
		int v,w;
		cin>>v>>w;
		for(int j=m;j>=v;j--)
			dp[j]=max(dp[j],dp[j-v]+w);
	}
	
	cout<<dp[m]<<endl;
	
	return 0;
}
```

<br>

```c++
//baoli.cpp

#include<iostream>
#include<cstdio>

using namespace std;

const int N=1010;
int v[N],w[N];

int main()
{
	int n,m;
	cin>>n>>m;
	
	for(int i=0;i<n;i++)
		cin>>v[i]>>w[i];
		
	int res=0;
	for(int i=0;i<1<<n;i++)
	{
		int sumv=0,sumw=0;
		for(int j=0;j<n;j++)
			if(i>>j&1)
			{
				sumv+=v[j];
				sumw+=w[j];
			}
		if(sumv<=m)res=max(res,sumw);
	}
	
	cout<<res<<endl;
	
	return 0;
}
```

<br>

```c++
//check.cpp

#include<iostream>
#include<fstream>

using namespace std;

void generate_data()
{
	ofstream fout("input.txt");
	int n=10,m=rand()%100+50;
	fout<<n<<' '<<m<<endl;
	
	for(int i=0;i<n;i++)
	{
		int v=rand()%50+10,w=rand()%50+10;
		fout<<v<<' '<<w<<endl;
	}
	fout.close();
}

int main()
{
	for(int i=0;i<100;i++)
	{
		printf("iteration: %d\n",i);
		generate_data();
		system("dp.exe <input.txt> dp_output.txt");
		system("baoli.exe <input.txt> baoli_output.txt");
		system("fc dp_output.txt baoli_output.txt");
		getchar();
	}
}
```



<div style="page-break-after:always;"></div>

# 算法竞赛及OJ题面常用英文单词整理

### A

abbreviation [数学] 约分;
activity on edge AOE网
activity on vertex AOV网
add, subtract, multiply and divide 加减乘除
adjacency list 邻接表（adjacency multilist 邻接多重表）
adjacency matrix 邻接矩阵
adjacent sequence elements 相邻的元素串
adjacent vertex 相邻顶点
algebraic term 代数项
alphabetical order 字典序
alternately rise and fall 交替上升和下降
Ambiguous 模糊不清
ancestor 祖先
anticlockwise 逆时针
Approximate String Matching 模糊匹配
Arbitrary Precision Arithmetic 高精度计算
arc 弧
arithmetic mean 算数平均值
arithmetic progression 等差数列（geometric progression 等比数列）
array 数组
articulation point 连接点
ascending lexicographical order 词典顺序升序排列
ascending order 升序（descending order降序）
aspect ratio 固定长宽比
assemble 组合
assess 评定，评估
assigned adj指定的，赋值的
augmenting path graph 增广路径图（augmenting path 增广路径）
average search length 平均查找长度
average temperature 顺时针
axis axes 轴

---

### B

balance merging sort 平衡归并排序
balance two-way merging 二路平衡归并排序
Bandwidth Reduction 带宽压缩
banlanced binary tree 平衡二叉树
base 底边；幂的底数
biconnected graph 重连通图
bidirectional 双向的
binary search tree 二叉查找树
binary search 二分查找
binary sort tree 二叉排序树
binary 二进制
bipartite graph 二部图
Bishop 主教（象）只斜走。格数不限不能越子。每方有两象，黑白格各占1个
blank string 空白（空格）串
block search 分块查找
boundary 界限

---

### C

calculate 计算
Calendrical Calculations 日期
carpet 地毯
chariot 战车（中国象棋）
checkmate (国际象棋） 将死; 输棋，将死; 败局; 败北，挫败;
circular linked list 循环链表
cirular queue 循环队列
Clique 最大团
clockwise order 顺时针方向顺序（anticlockwise 逆时针）
Coefficient 系数，率，程度
Collinear 共线的
column major order 以列为主的顺序分配
columns 列
Combinatorial Problems 组合问题
comma 逗号
common superstring 公共父串
compile v编译，汇编
complete binary tree 完全二叉树
complete graph 完全图
composite numbers 合数
Computational Geometry 计算几何
concave 凹的
connected component 连通分量（Connected Components 连通分支）
consecutive 连续的
constant n常数，常量 adj不变的，始终如一的，持续不断的
Constrained and Unconstrained Optimization 最值问题
Convex Hull 凸包
coordinates坐标
corrupt 腐烂，破坏
counterclockwise 逆时针
critical path 关键路径
Cryptography 密码
Cube root 立方根

---

### D

Data Structures 基本数据结构
data type 数据类型
decimal n小数 adj小数的，十进制的
decimal 十进制
decision tree 判定树
Deck 甲板
define v定义，明确，使规定
deformed 变形的
Denominator 分母
denote 代表; 指代; 预示; 意思是;标志；象征
dense graph 稠密图
Deployed 部署
depth 深度
deque(double-ended queue) 双端列表
descentdant 子孙
destination 终点
Determinants and Permanents 行列式
diagonal 对角（diagonally 斜对角线的）
dial 钟面，拨打
dialing 拨号音 打电话，拨电话号码( dial的现在分词 )
Dictionaries 字典
difference 差
digital analysis method 数字分析法
digital search tree 数字查找树
digit 位数;数字
digraph(directed graph) 有向图
Dimensional 尺寸
diminishing increment sort 随小增量排序
direct access file 直接存取文件
directed acyclic graph 有向无环图
directory structure 目录结构
directory（计算机文件或程序的）目录;指导的咨询的; 管理的
discrete Fourier transform 离散傅里叶变换
disjoint 不相交的
Distinct values 独一无二的值
distinct 不同的；独一无二的
division method 除法
divisor 因子;分母
doubly linked list 双向链表
doubly linked tree 双链树
Drawing Graphs Nicely 图的描绘
Drawing Trees 树的描绘
duplicated 复制；打印的
duplicates 完全一样的东西，复制品( duplicate的名词复数 )

---

### E

Edge and Vertex Connectivity 割边/割点
Edge Coloring 边染色
embed 插入
enable 启用
Entry 进口
equation 方程式;等式
equivalent equation 同解方程;等价方程
equivalent 相等的，等效的
estimate 预测
Eulerian Cycle / Chinese Postman Euler 回路/中国邮路
evaluate v评价，估价
evaluated adj求···的值
even 偶数的
excluding 排除，拒绝( exclude的现在分词); 驱逐;除…外，不包括
execute v执行，完成
executed 执行的；生效的
exponent 指数；幂
external sort 外部排序

---

### F

Facility 设备，设施
factorial 阶乘; 因子的，阶乘的
Factoring and Primality Testing 因子分解/质数判定
Feedback Edge/Vertex Set 最大无环子图
Finite State Machine Minimization 有穷自动机简化
fixed-aggregate data type 固定聚合数据类型
foggiest idea 概念
folding method 折叠法
follow by 跟随，其后
forest 森林
formula n公式
fraction 分数;小部分
front 队头
full binary tree 满二叉树

---

### G

gcd （greatest common divisor） 最大公约数
generalized list 广义表
Generating Graphs 图的生成
Generating Partitions 划分生成
Generating Permutations 排列生成
Generating Subsets 子集生成
geometric progression 等比数列
grabh 图
Graph Data Structures 图
Graph Isomorphism 同构
Graph Partition 图的划分
Graph Problems — hard 图论-NP问题
Graph Problems — polynomial 图论-多项式算法
greatest integer 最大整数
grid 网格；方格；（地图上的）坐标方格

---

### H

Hamiltonian Cycle Hamilton回路
hash search 散列查找(hash table 散列表)
head node 头结点(head pointer 头指针)
heap sort 堆排序
horizontal or vertical direction 水平和垂直方向
horizontally adv水平地 horizontal adj水平的
Huffman tree 哈夫曼树

---

### I

Identifier n标识符，识别码
immediate predecessor 直接前趋（immediate successor 直接后继）
immediately allocating method 直接定址法
improper fraction 假分数
in the range of 在…范围内
in the shape of a cross 十字形
incident edge 关联边
indegree 入度
indent n缩进
indentical 相同的
Independent Set 独立集
indexed file 索引文件
indexed non-sequential file 索引非顺序文件（indexed sequential file 顺序）
indicating adj指示的，标志的
inequality 不等式
infinite 无限的
initial adj最初的，词首的，开始的 n首字母
initial node 初始结点
initialization n初始化，赋初值 initialize v初始化
inorder traversal 中序遍历
insertion sort 插入排序
insertion 插入
integer 整数
Interior 内部，本质
internal sort 内部排序
Interpret 解释，执行
intersect v相交，交叉
intersection 横断，横切; 交叉，相交; 交叉点，交叉线; [数] 交集;
Intersection Detection 碰撞测试
intersection 横断;横切;交叉
intersect 相交
intervals 间隔时间; 间隔( interval的名词复数 ); 区间
Invade 侵略
invalid 无效的
inverted file 倒排文件
irreparably 不能恢复地

---

### J

Job Scheduling 工程安排
justified adj合理的，合法化的

---

### K

Kd-Trees 线段树
Knapsack Problem 背包问题
Knight 骑士（马）每步棋先横走或直走一格，然后再往外斜走一格；或者先斜走一格，最后再往外横走或竖走一格（即走“日”字）。可以越子，没有象棋中的“蹩马腿”限制。

---

### L

lcm (Least Common Multiple) 最小公倍数
left or right-justified 左对齐or右对齐
lexicographically 字典序
like terms ,similar terms 同类项
linear algebra 线性代数(linear equation线性方程linear linked list 线性链表)
Linear Programming 线性规划
linear structure 线性结构
link field 链域 linked list 链表
literal coefficient 字母系数
logarithm 对数
logical structure 逻辑结构
Longest Common Substring 最长公共子串
loop 环

---

### M

Maintaining Line Arrangements 平面分割
master file 主文件
Matching 匹配
Matrix Multiplication 矩阵乘法
maximum matching 最大匹配
meadow 草坪
mean 平均值
Medial-Axis Transformation 中轴变换
Median and Selection 中位数
memorable 值得纪念的; 显著的，难忘的; 重大的，著名的
merge sort 归并排序
mid-square method 平方取中法
minimal adj最小限度的
minimal volume 最小体积
minimum(cost)spanning tree 最小（代价）生成树
mixed number 带分数
mod v求余 modulus n系数，模数
Motion Planning 运动规划
motion 多边形
multi-dimentional array 多维数组
multilinked list 多重链表
multilist file 多重链表文件
multiple adj多重的多样的，许多的 n倍数
multiplication 乘法
municipal 市政的

---

### N

Nearest Neighbor Search 最近点对查询
negative ，positive 负 ，正
Network Flow 网络流
no special punctuation symbols or spacingrules 无特殊标点符号或间距的规则
non-intersecting 非相交的; 不相交的;
nonlinear structure 非线性结构
notation 标记
numerator 分子
numerical coefficient 数字系数
Numerical Problems 数值问题

---

### O

Obesity 肥胖
octal adj八进制的 binhex 十六进制
odd and even 奇和偶
optimal 最佳的
optimally 最佳
Orbit 轨道
ordered pair 有序对(ordered tree 有序树)
Ordinal 有次序的
original equation 原方程
origin 原点
orthogonal list 十字链表
Out degree 出度
Over brim 溢出
overflow 上溢
Overlapping 覆盖

---

### P

palindrome 回文
palindromic 回文的
parallel 平行的
parity property 奇偶性
partical order 偏序
Pawn 禁卫军（兵）只能向前直走，每次只能走一格。但走第一步时，可以走一格或两格。兵的吃子方法与行棋方向不一样，它是直走斜吃，即如果兵的斜进一格内有对方棋子，就可以吃掉它而占据该格
phyical structure 物理结构
Pipe 管道
Planarity Detection and Embedding 平面性检测和嵌入
ploygon-shaped faces/ polygon 多边形
ployphase merging sort 多步归并排序
Point Location 位置查询
pointer field 指针域
Polygon Partitioning 多边形分割
positive and negative integers 正整数和负整数
postorder traversal 后序遍历
precision n精密，精确度精确
predecessor 前趋
prefix 前缀
preorder traversal 先序遍历
prime 质数
Priority Queues 优先队列
proceed 运行
process v加工，处理 n程序，进程
process a sequence of n distinct integers 处理一串n 个不同的整数
profile 轮廓
proper fraction 真分数
proportional 成比例的
Protrusions 凸起物
Pyramid 金字塔，渐增

---

### Q

quadrant 象限，四分之一圆
Queen 皇后 横、直、斜都可以走，步数不受限制，但不能越子
quotient 商

---

### R

radix sort 基数排序
Random Number Generation 随机数生成
random number method 随机数法
Range Search 范围查询
rat, ox, tiger, rabbit, dragon, snake,horse, sheep, monkey, rooster, dog pig 十二生肖
rate of convergence 收敛速度
rear 队尾
rectangular 矩形的，成直角的
Relates 叙述，讲述
replacement selection sort 置换选择排序
respectively adj各自的，分别的，独自的
robustness 鲁棒性
Rook 战车 横竖均可以走，步数不受限，不能斜走。除王车易位外不能越子。
rooster 鸡
root sign 根号
round() 四舍五入（当取舍位为5时，若取舍位数前的小数为奇数则直接舍弃，若为偶数则向上取舍）
rounded to n decimal places 精确到小数点后n位
row major order 以行为主的顺序分配
Rows and columns 行与列

---

### S

Satisfiability 可满足性
scenario 方案；(可能发生的)情况；
search (sequential search)  线性查找（顺序查找）linear
searching 查找，线索
segment 段;分割
segment 环节; 部分;分段; 分割，划分;
selection sort 选择排序
semicolon n分号
sequence n顺序，序列，连续
serial 连续的; 连载的; 顺序排列的;
series 连续的同类事物，系列
series 系列
Set and String Problems 集合与串的问题
Set Cover 集合覆盖
Set Data Structures 集合
Set Packing 集合配置
Shape Similarity 相似多边形
Shell 贝壳，脱壳
shelter 遮蔽物
Shortest Common Superstring 最短公共父串
Shortest Path 最短路径
simple cycle 简单回路（simple path 简单路径）
Simplifying Polygons 多边形化简
simultaneously 同时的
single linked list 单链表
sink 汇点
solution n解决方案
Solving Linear Equations 线性方程组
source 源点
spanning forest 生成森林
spanning tree 生成树
spares graph 稀疏图
sparse matrix 稀疏矩阵
specify 指定
square root 平方根
square 平方，正方形，广场，方格
Squared 平方
Stack Overflow 堆栈溢出通常是您的程序陷入了无穷递归，或递归嵌套层数过多。
statistical 统计的
Steiner Tree Steiner 树
stem 词根
String Matching 模式匹配
strongly connected graph 强连通图
subgraph 子图
subsequent adj随后的，后来的
substring 子串（subtree 子树）
successor 后继
sufficient 充足的；足够的；
suffix 后缀
Supervisor 监督人
symmetric matrix 对称矩阵

---

### T

tail pointer 尾指针
terminal node 终端结点
Text Compression 压缩
threaded binary tree 线索二叉树
times 乘
Topological Sorting 拓扑排序
toss 扔（硬币）
Transitive Closure and Reduction 传递闭包
transposed matrix 转置矩阵
traversal of tree 树的遍历
traversing binary tree 遍历二叉树
traversing graph 遍历图
tree index 树型索引
triangle n三角形
triangle inequality 三角不等式
Triangulation 三角剖分
triple 三倍的，三方的，三部分的; 增至三倍;三倍的数[量]; 三个一组;
Tromino 三格骨牌
Troop 军队，组群
truangular matrix 三角矩阵
two adjacent sequence elements 两个相邻的元素串
two-dimensional array 二维数组
two-dimensional 维数

---

### U

ultimate 基本的，终极的
unconnected graph 非连通图
underflow 下溢
undigraph(undirected graph) 无向图
union 并集
unique identifier 唯一的标识符
unordered pair 无序对（unordered tree 无序树）
uppercase 大写字母盘;以大写字母印刷;大写字母的
uppercase（Capital） 大写字母（Lowercase letters小写字母）

---

### V 

variable-aggregate data type 可变聚合数据类型
variable 变量
Vertex Coloring 点染色（Vertex Cover 点覆盖）
vertex n顶点，最高点
vertical n垂直线，垂直面 adj垂直的，顶点的
volume n数量，容量
Voronoi Diagrams Voronoi 图
vulnerable 容易受到攻击的

---

### W

weakly connected graph 弱连通图
weight 权
weighted average 加权平均值
weighted graph 加权图
wooden planks 木板



<div style="page-break-after:always;"></div>

```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <bits/stdc++.h>

#define x first
#define y second
#define endl '\n'

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
typedef pair<int,string> PIS;
typedef pair<char,string> PCS;
typedef pair<double,double> PDD;

const int N = 100010, INF = 0x3f3f3f3f;
const double eps = 1e-8;

int dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};
//int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};

/*
inline __int128 read()
{
	__int128 x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch - '0');
		ch = getchar();
	}
	return x * f;
}

void print (__int128 x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		print(x / 10);
	putchar(x % 10 + '0');
}
*/

bool is_prime(int x)
{
	if(x < 2) return false;
	for(int i = 2; i <= x / i; i ++)
		if(x % i == 0) return false;
	return true;
}

int gcd(int a, int b)
{
	return b ? gcd(b, a % b) : a;
}

int exgcd(int a, int b, int &x, int &y)
{
	if(b == 0)
	{
		x = 1, y = 0;
		return a;
	}

	int d = exgcd(b, a % b, y, x);
	y -= (a / b) * x;
	return d;
}

int qmi(int m, int k, int p)
{
	int res = 1 % p, t = m;
	while(k)
	{
		if(k & 1) res = res * t % p;
		t = t * t % p;
		k >>= 1;
	}
	return res;
}

int n, m;

void solve()
{
	
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int T = 1;
	//cin >> T;
	while(T --)
		solve();

	return 0;
}
```

