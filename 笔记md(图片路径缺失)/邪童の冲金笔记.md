<h1 align = "center"> 邪童 の 冲金笔记</h1>

<br>

<img src="E:\编程\acm\codeforces\头像.jpg" alt="头像" style="zoom:50%;" />

![7-第48届ICPC国际大学生程序设计竞赛亚洲区域赛（杭州） 铜奖](E:\编程\acm\evilboy_ 程序设计类竞赛里程碑\7-第48届ICPC国际大学生程序设计竞赛亚洲区域赛（杭州） 铜奖.png)

<div style="page-break-after:always;"></div>

![12-2024年广东省大学生程序设计竞赛 银奖](E:\编程\acm\evilboy_ 程序设计类竞赛里程碑\12-2024年广东省大学生程序设计竞赛 银奖.png)

![13-2024年CCPC中国大学生程序设计竞赛全国邀请赛（广东） 铜奖](E:\编程\acm\evilboy_ 程序设计类竞赛里程碑\13-2024年CCPC中国大学生程序设计竞赛全国邀请赛（广东） 铜奖.jpg)

<div style="page-break-after:always;"></div>

## 目录

### 动态规划专题

> + 线性DP
> + 背包问题
> + 区间DP
> + 树型DP
> + 状压DP
> + 数位DP
> + 概率DP
> + DP优化——DP的优化思路
> + DP优化——单调队列斜率优化

<br>

---

### 图论专题

> + 图论基础
> + 图匹配
>   + 二分图
>     + 二分图性质
>     + 最大匹配
>       + 匈牙利算法
>       + HK算法
>     + 最优匹配
>       + KM算法
>     + 稳定婚姻问题
>   + 一般图最大匹配
>     + 带花树
> + 连通性
>   + 有向图强连通分量
>   + 无向图双连通分量
>   + 无向图割点和桥
> + 网络流
>   + 最大流算法
>     + FF方法思想
>     + SAP
>     + DINIC
>   + 费用流算法
>   + 模型运用
>     + 最大流模型
>     + 最小割模型
>     + 费用流模型
> + 特殊性质和模型的运用
>   + 分层图思想
>   + 最短路思想
>   + 平面图思想
> + 其他算法介绍
>   + Kruskal重构树

<br>

---

### 数据结构专题

> + 区间信息维护
>   + 前缀和、差分 (前缀和的变形、高维前缀和、多阶前缀和)
>   + 树状数组、线段树 (比赛中的小技巧、多TAG后效性、带修改的动态规划DDP)
>   + 线段树 (带暴力成分的线段树、李超线段树)
>   + 平衡树、伸展树
>   + 跳表、数组分块、莫队
> + 数据结构的可持久化
>   + 可持久化线段树
> + 统计类算法
>   + CDQ分治
> + 树上信息维护
>   + 树的DFS序、树上差分、树上倍增
>   + 树链剖分 (轻重树链剖分)
>   + 维护树链剖分 (DSU ON TREE, 长链剖)
> + 动态树
>   + LCT
> + 无根树子树信息统计
>   + 树分治
> + 无根树子树信息维护
>   + 点分树

<br>

---

### 数学专题

> + 整数分解与筛法 (GCD、exGCD、埃氏筛、欧拉筛、质因数分解)
> + 同余与模 (逆元、费马小定理、欧拉定理、孙子定理)
> + 简单排列和组合 (排列组合问题、阶乘、组合数)
> + 容斥原理
> + 积性函数 (积性函数概念、欧拉筛求积性函数、莫比乌斯反演)
> + 矩阵与高斯消元 (矩阵乘法、高斯消元求线性方程组、求行列式)
> + 生成函数Ⅰ (线性递推关系、生成函数概念与公式推导、暴力计算)
> + FFT与拉格朗日插值 (FFT、快速多项式乘法、拉格朗日插值)
> + 原根与NTT (原根、指标、NTT、分治FFT/NTT、多项式牛顿迭代)
> + 生成函数Ⅱ (集合分拆、置换、整数分拆、它们的递推公式、生成函数和快速计算)
> + Polya定理 (Burnside引理、Polya定理)
> + 数论问题杂谈 (大素数判定、大整数分解、二次剩余等)
> + 集合幂级数与FWT
> + 树与图上的计数问题 (Prufer序列、生成树计数、LGV引理等)
> + 概率与期望

<br>

---

### 字符串专题

> + KMP1 (字符串基本概念、KMP算法和简单应用)
>
> + Hash (Hash的三种姿势及应用)
>
> + Trie (字典树多模式匹配)
>
> + ACAM (多模式匹配)
>
> + Trie2 (Trie图, 01Trie)
>
> + KMP2 (KMP自动机, Border树)
>
> + Manacher (提取回文串)
>
> + PAM (回文自动机的构造和应用)
>
> + SA (后缀数组nlogn构造和应用)
>
> + SAM (后缀自动机简单应用)

<br>

---

### 计算几何专题

> + 导论
> + 二维基础
> + 极角序
> + 凸包
> + 半平面交
> + 扫描线
> + 圆
> + 三角剖分
> + 三维
> + 其他

<br>

---

### 博弈专题

> + Introduction (组合游戏基本概念、对抗搜索、Bash游戏、Nim游戏)
> + Sprague-Grundy函数 (SG函数、图游戏、Nim和)
> + 经典的组合游戏 (Fibonacci游戏、Wythoff游戏、Chomp游戏等)
> + Nim积与Green Hackenbush游戏
> + 不公平组合游戏

<br>

---

### 其他

> + 初始与杂类模板
> + 斜率优化DP板子
> + 扩展卢卡斯定理
> + DP求本质不同子序列个数
> + k进制异或哈希

<div style="page-break-after:always;"></div>

# 图论基础

### 图的存储

+ $vector$ 
+ 邻接表
+ 伪邻接表 (链式前向星)

```c++
int n, m, cnt;
struct Edge
{
    int to, w, next;
}edge[N];
int head[N];

void init()
{
    for(int i = 0; i <= n; i++)
        head[i] = -1;
    cnt = 0;
}

void add_edge(int u, int v, int w)
{
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt ++;
}

int main()
{
    cin >> n >> m;
    init();
    
    for(int i = 1; i <= m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        add_edge(u, v, w);
    }
    
    for(int i = 1; i <= n; i++)
        for(int j = head[i]; j != -1; j = edge[j].next)
            cout << i << ' ' << edge[j].to << ' ' << edge[j].w << endl;
}
```

<div style="page-break-after:always;"></div>

# 图匹配

### 二分图最大匹配

**匈牙利算法**

+ 邻接矩阵 $O(n^3)$ 
+ 邻接表 $O(nm)$ 

```c++
int dfs(int x)
{
    for(int i = 1; i <= n; i++)
    {
        if(!a[x][i] || vis[i]) continue;
        vis[i] = 1;
        if(link[i] == 0 || dfs(link[i]))
        {
            link[i] = x;
            return 1;
        }
    }
    return 0;
}
```

```c++
for(int i = 1; i <= n; i++)
{
    memset(vis, 0, sizeof vis);
    dfs(i);
}
```

**HK算法**

+ 时间复杂度 $O(m \sqrt{n})$ (优化有限, 应用较少)
+ 有论文证明用 $dinic$ 实现二分图匹配的复杂度是 $O(m \sqrt{n})$ , 跑起来一般比 HK 快

**Konig定理**

二分图最大匹配等于最小点覆盖

<br>

### 二分图最优匹配

**KM算法**

+ 前提: 基于完备匹配的, 若不一定能完美匹配需要加边加点补足

+ 原理: 贪心地执行增广操作, 最开始只有值最大的边是有效边, 增广完成还不能完备匹配后新增一些边作为有效边, 而这些边用于增广会替换掉之前的权值更大的边, 所以新增的边应该是用于替换代价尽量小的边

+ 具体操作: 给每个点预设一个顶标, 只有两个端点的顶标加起来等于边权的边, 我们才认为是有效边, 即 $L[x] + R[y] == w[x][y]$ 的时候才是有效边

  最开始左集合的每个点的顶标为他连出去权值最大的边的权值, 右集合每个点顶标为 $0$ , 当匹配失败的时候, 我们遍历之前的左集合本次尝试匹配遍历过的点, 在他们连向右集合未遍历的点的边中找一个与顶标和差值最小的边, 即 $delta = L[x] + R[y] - w[x][y]$ (可理解为找出一条损失最小的增广路). 找到之后修改顶标: 左侧所有遍历过的点减去 $delta$ , 右边所有遍历过的点加上 $delta$ , 这样原来的有效边还是有效边, 而我们新家的边也已经加上了

  重复找匹配 + 修改顶标的操作, 一直到找到一个完美匹配即可

+ 时间复杂度 $O(n^2m)$ 

```c++
int dfs(int x)
{
    visx[x] = 1;
    for(int i = 1; i <= m; i++)
    {
        if(!visy[i] && lx[x] + ly[i] == w[x][i])
        {
            visy[i] = 1;
            if(link[i] == -1 || dfs(link[i]))
            {
                link[i] = x;
                return 1;
            }
        }
    }
    return 0;
}
```

```c++
memset(ly, 0, sizeof ly);
memset(lx, 0xf7, sizeof lx);
memset(link, -1, sizeof link);
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        lx[i] = max(w[i][j], lx[i]);

for(int i = 1; i <= n; i++)
{
    while(1)
    {
        memset(visx, 0, sizeof visx);
        memset(visy, 0, sizeof visy);
        if(dfs(i)) break;
        int d = 0x7f7f7f7f;
        for(int j = 1; j <= n; j++)
            if(visx[j])
                for(int k = 1; k <= m; k++)
                    if(!visy[k]) d = min(d, lx[j] + ly[k] - w[j][k]);
        if(d == 0x7f7f7f7f) return -1;
        for(int j = 1; j <= n; j++) if(visx[j]) lx[j] -= d;
        for(int j = 1; j <= m; j++) if(visy[j]) ly[j] += d;
    }
}
```

<br>

### 快速判断完美匹配是否存在

**Hall定理** : 对于一个二分图, 如果对于左边任意子集 $S$ , 其对应连接了右边的点集 $T$ , 都有 $|S| \le |T|$ , 那么这个二分图有完美匹配 (充分必要条件)

<br>

### 稳定婚姻系统

已知每个人对他有好感的异性的好感度排序, 求一种匹配使得: 对于每一个人, 他心目中更好的异性搭档都不觉得他是比目前更好的选择(男女人数相同)

即对于一个二分图求一个完美匹配, 使得任意两组配对 $<a, b> $ , $<u, v>$ , 不存在 $w_{a \to v} > w_{a \to b}$ 且 $w_{v \to a} > w_{v \to u}$ 或 $w_{b \to u} > w_{b \to a}$ 且 $w_{u \to b} > w_{u \to v}$ 

**Gale - Shapley算法**

+ ① 每位单身男士去追求他还没尝试过的好感度最高的女性
+ ② 每位被追求的女士选择追求者们和现男友(如果有)中好感度最好的作为男友 (被拒绝的追求者和被抛弃的前男友在下一轮仍单身)
+ 重复①②, 直到完全匹配或全部尝试完了

> **正确性证明:**
>
> + 没有人孤寡:
>
>   若有一个男士未匹配, 他会不懈地表白每一位女士, 即每位女士至少被表白一次, 而女士只要被表白一次就一定有对象, 所以无孤寡女士
>
>   男女人数相等, 所以无孤寡男士
>
> + 稳定:
>
>   随着轮次增加, 男士对象越来越差, 女士越来越好
>
>   设男A和女B各有其对象, 但男A对女B的好感度更好
>
>   所以之前男A一定给女B表白过, 所以女B现对象比男A好

<br>

### 一般图最大匹配

**带花树算法 (Blossom Alogorithm)**

+ 总体思想: 找增广路直到没有为止

+ 算法过程:

  + 多次BFS, 从一个未匹配点出发将它染成黑色 (最开始所有点都是无色)

    + 枚举与它相邻的点 $y$

    + 若这个点没有在这次BFS找增广中访问过

      + 它是一个未匹配点 $\Longrightarrow$ 找到增广路, 返回修改匹配情况
      + 它是一个已匹配点 $\Longrightarrow$ 将它染白, 将它原来的匹配点加入队列并染黑

    + 若这个点在这一次BFS中访问过: 说明找到了一个环

      + 这个点是白色 $\Longrightarrow$ 这是个偶环, 不用管, 跳过这个点即可

      + 这个点是黑色 $\Longrightarrow$ 这是一个奇环

        + 若这个奇环已经缩过了, 则跳过这个点

        + 若这个奇环没有缩过, 去处理它:

          + 找到这个环的环顶 (即搜索中进入环的地方, 也即 $x$ 点和 $y$ 点的 $LCA$ )

          + 将环顶到 $x$ , $y$ 路径上所有的点染黑 (白点染黑后要加入队列)

          + 并将环上的这些点的并查集父亲指向 $lca$ (用并查集来缩环)

            $\Longrightarrow$ 这样就把这个环变成了 "一个点"

            (只需要它们拥有同等的地位, 不需要物理上变成同一个点)

```c++
//match[i]: i匹配的谁
//last[i]: i通过非匹配边连的上一个点是谁
```

```c++
int lca(int x, int y) //求环顶
{
    tmp ++; //为了不清vis数组,每次进入函数时给vis赋的值都不一样就可以了
    while(1)
    {
        if(x != 0)
        {
            x = findfa(x);	//先去x的环顶(处理非简单环的情况)
            if(vis[x] == tmp) return x; //x走过,已经是环顶了,返回
            vis[x] = tmp; //标记走过
            if(match[x]) x = last[match[x]]; //往上跳一条匹配边和非匹配边(BFS一层就是走了一条匹配边和一条非匹配边)
            else x = 0;
        }
        swap(x, y); //交换xy
    }
}
```

```c++
void flower(int a, int r) //缩环(的一半)
{
    while(a != r)
    {
        int b = match[a], c = last[b]; //a是黑点所以先跳匹配边再跳非匹配边
        if(findfa(c) != r) last[c] = b; //因为奇环里到底怎么匹配还不知道,干脆把原来的匹配边也记录一组非匹配边(任意相邻两个点都有可能是最终的匹配)
        if(col[b] == 2) q.push(b), col[b] = 1;
        if(col[c] == 2) q.push(c), col[c] = 1; //环上的白点要变成黑点
        fa[findfa(a)] = findfa(b);
        fa[findfa(b)] = findfa(c); //并查集维护父亲
        a = c; //往上跳
    }
}
```

```c++
int work(int s)
{
    for(int i = 1; i <= n; i++)
        last[i] = col[i] = vis[i] = 0, fa[i] = i; //清数组
    while(!q.empty()) q.pop();
    col[s] = 1; //给起点标成黑色
    q.push(s);
    while(!q.empty()) //广搜
    {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i > 0; i = edge[i].next)
        {
            int y = edge[i].t;
            if(match[x] == y) continue; //走的匹配边(走回去了)
            if(findfa(x) == findfa(y)) continue;
            //两个点在同一个已经缩过的奇环里
            if(col[y] == 2) continue; //偶环
            if(col[y] == 1) //黑点——奇环
            {
                int r = lca(x, y); //r是环顶
                if(findfa(x) != r) last[x] = y;
                if(findfa(y) != r) last[y] = x; //xy都是靠非匹配边接在一起
                flower(x, r);
                flower(y, r); //缩花,每次缩掉花的一半
            }
            else if(!match[y]) //else: col等于0——在这次增广中y没访问过;match为0,这个点是个未匹配的点——增广路已经求到了
            {
                last[y] = x; //y通过非匹配边和x连到一起
                for(int u = y; u != 0;) //顺着交错路走回去
                {
                    int v = last[u]; //last是他通过非匹配边连的上一个点
                    int w = match[v]; //去v原来匹配的点
                    match[v] = u;
                    match[u] = v; //匹配边和非匹配边交换——uv成为新一对
                    u = w; //再从w开始往前走直到把这个增广路修改完
                    //这里之所以没有改last的值是因为用过了就没用了,后面会退出work函数,再次进入就清空了
                }
                return 1;
            }
            else //col等于0——在本次增广中y没访问过,且y原来有匹配
            {
                last[y] = x; //通过未匹配边的y的前一个点为x
                col[y] = 2; //y自己是白点
                col[match[y]] = 1; //y通过匹配边连的前一个点是黑点
                q.push(match[y]); //这个黑点入队
            }
        }
    }
    return 0;
}
```

<div style="page-break-after:always;"></div>

# 连通性

### 无向图割点、桥、双连通分量

**概念**

+ 给定无向连通图 $G = (V, E)$ 
+ 对于一个点 $x$ , 若从图中删除 $x$ 及所有与 $x$ 相连的边, 图不再联通, $x$ 是 $G$ 的割点
+ 对于一条边 $e$ , 从图中删去 $e$ , 图不再联通, $e$ 的 $G$ 的割边
+ 一个图如果不存在割点, 则它是一个点双连通图, 一个图的极大点双连通子图是它的点双连通分量
+ 一个图如果不存在割边, 则它是一个边双连通图, 一个图的极大边双连通子图是它的边双连通分量

**Tarjan算法求割点和桥(割边)**

+ 时间戳 $dfn$ : 第几个搜到这个点
+ 返祖边: 搜索树上一个点连向其祖先节点的边
+ (横插边: 搜索树上一个点连向它另一条支链上的点的边——在无向图中不存在)
+ 追溯值 $low$ : 当前点及其子树的返祖边能连到的 $dfn$ 值最小的点
+ 如果 $<u, v>$ 是搜索树的边: $low[u] = min(low[u], low[v])$ 
+ 如果 $<u, v>$ 是返祖边: $low[u] = min(low[u], dfn[v])$ 

**什么样的点是割点?**

1. 有多个儿子的根节点
2. 子树中不存在跨越自己连向上方的返祖边

```c++
void tarjan(int x)
{
    dfn[x] = low[x] = ++ cnt;
    int flag = 0;
    for(int i = head[x]; i != -1; i = edge[i].next)
    {
        int y = edge[i].t;
        if(!dfn[y])
        {
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if(low[y] >= dfn[x])
            {
                flag ++;
                if(x != root || flag > 1) boo[x] = 1;
            }
        }
        else low[x] = min(low[x], dfn[y]);
    }
}
```

**什么样的边是桥?**

$<u, v>$ 得是树边且下侧的点及其子树中不存在连向上策点及其之上的返祖边

**边双连通分量和点双连通分量**

边双连通分量: 把桥删掉之后的每个联通分量

点双连通分量: 一个割点可能属于多个双连通分量

边双连通分量的求法: 标记出桥之后 $dfs$ 一遍即可

点双连通分量的求法: 维护一个栈, 第一次访问某个节点时, 将其入栈. 当割点判断法则中 $dfn[x] \le low[y]$ 成立时, 不断从栈中弹出节点, 直到 $y$ 被弹出, 这些被弹出的点和 $x$ 一起构成一个点双连通分量

边双连通分量的缩点: 每个边双缩成一个点, 再用桥把它们连起来

点双连通分量的缩点: 保留割点, 割点与其点双连通分量中其它点索出来的点连边

<br>

### 有向图强连通分量

**有向图的弱联通与强联通**

+ 在有向图 $G = (V, E)$ 中, 如果对于任意两点 $u$ , $v$ , 存在一条从 $u$ 到 $v$ 或者从 $v$ 到 $u$ 的路径——弱联通
+ 在有向图 $G = (V, E)$ 中, 如果对于任意两点 $u$ , $v$ 都互相可达——强联通

**强连通分量**

+ 有向图强连通分量: 在有向图 $G$ 中, 如果两个顶点 $v_i$ , $v_j$ 间 $(v_i > v_j)$ 有一条从 $v_i$ 到 $v_j$ 的有向路径, 同时还有一条从 $v_j$ 到 $v_i$ 的有向路径, 则称两个顶点强连通
+ 如果有向图 $G$ 的每两个顶点都强联通, 称 $G$ 是一个强连通图
+ 有向图的极大强联通子图, 称为强连通分量

**Kosaraju算法**

+ 对原图进行一次 $dfs$ (任意起点)
+ 在第一次形成的森林的每一棵树里, 以第一次搜索出栈顺序的逆序对反图进行 $dfs$ , 这次搜索 $A$ 能到达的点和 $A$ 都在一个强连通分量里面

**Tarjan算法**

+ $dfn[i]$ 时间戳
+ $low[i]$ 它和它的子树里返祖边和横插边能连到还没出栈的 $dfn$ 最小的点
+ 在 $dfs$ 的时候维护一个栈, 第一次访问到某个点就将其加入到栈中, 当一个点的 $dfn[x] == low[x]$ 时, 它就是这个强连通分量里面在搜索树中最高的点, 将栈里点出栈直到 $x$ 也出栈为止, 这些点组成一个强连通分量

```c++
void tarjan(int x)
{
    dfn[x] = low[x] = ++ cnt;
    stack[++ top] = x;
    vis[x] = 1; 
    for(int i = head[x]; i != -1; i = edge[i].next)
    {
        int y = edge[i].t;
        if(!dfn[y])
        {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        }
        else if(vis[y]) low[x] = min(low[x], dfn[y]);
    }
    if(dfn[x] == low[x])
    {
        ans ++;
        do
        {
            int cur = stack[top --];
            vis[cur] = 0;
            num[cur] = ans;
        }while(x != cur);
    }
}
```

<div style="page-break-after:always;"></div>

# 网络流

### 最大流算法

**Ford-Fulkerson方法**

+ Ford-Fulkerson方法, 该方法也成为"扩充路径方法", 该方法是大量算法的基础, 有多种实现方法
+ Ford-Fulkerson算法是一种迭代算法, 首先图中所有边的流过的流量大小为 $0$ , 此时的网络流大小也为 $0$ . 在每次迭代中, 通过寻找一条"增广路径"来增加流的值. 增广路径可以看作是源点 $s$ 到汇点 $t$ 的一条路径, 并且沿着这条路径可以增加更多的流. 迭代直至无法再找到增广路径位置, 此时必然从源点到汇点的所有路径中至少有一条满边(即边的流的大小等于边的容量大小)

**FF方法具体步骤**

+ $1)$ 初始化网络流中各个边的容量, $c<u, v>$ 为该边的容量, $c<u, v>$ 为零. 初始化最大流为零
+ $2)$ 在残留网络中找到一条从 $s$ 到 $t$ 的增广路 $p$ . 能找到转步骤 $3$ , 不能转步骤 $5$ 
+ $3)$ 在增广路中找到"瓶颈边"(即容量最小的边)记下其容量 $x$ , 加入到最大流中
+ $4)$ 将增广路中所有边的流量减去 $x$ , 反向边加上 $x$ , 构成新的残量网络, 转步骤 $2$ 
+ $5)$ 得到最大流, 退出

**Edmond-Karp算法**

+ EK算法是FF方法中最简单的一个, 当然效率也就比较低
+ EK算法的流程与FF方法完全相同, 只是在寻找增广路的时候使用了BFS
+ 时间复杂度 $O(nm^2)$ 
+ 空间复杂度 $O(n^2)$ (邻接矩阵)
+ 注意要退流

```c++
int EK(int s, int t)
{
    int i, j;
    int ans = 0;
    while(1)
    {
        memset(res, 0, sizeof res);
        res[s] = MAX; //源点的残留网络要置为无限大!否则下面找增广路出错
        pre[s] = -1;
        qq.push(s);
        //bfs找增广路
        while(!qq.empty())
        {
            int x = qq.front();
            qq.pop();
            for(int i = 1; i <= t; i++)
            {
                if(!res[i] && f[x][i] < c[x][i])
                {
                    qq.push(i);
                    pre[i] = x;
                    res[i] = min(c[x][i] - f[x][i], res[x]); //这里类似dp,如果有增广路,那么res[t]就是增广路的最小权
                }
            }
        }
        if(res[t] == 0) break; //找不到增广路就退出
        int k = t;
        while(pre[k] != -1)
        {
            f[pre[k]][k] += res[t]; //正向边加上新的流量
            f[k][pre[k]] -= res[t]; //反向边要减去新的流量,反向边的作用是给程序一个后悔的机会
            k = pre[k];
        }
        ans += res[t];
    }
    return ans;
}
```

**Sap算法**

+ sap算法是采用了距离标号的方法求最短增广路, 而距离标号的思想来源于 push__relable (压入重标记) 类算法

+ 所谓距离标号, 就是某个点到汇点的最少的弧的数量 (另外一种距离标号是从源点到该点的最少的弧的数量, 本质上没什么区别)

+ 设点 $i$ 的标号为 $D[i]$ , 那么如果将满足 $D[i] = D[j] + 1$ 的弧 $(i, j)$ 叫做允许弧, 且增广时只走允许弧, 那么就可以达到"怎么走都是最短路"的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向边的 $BFS$ 求出, 实践中可以初始设全部点的距离标号为 $0$ , 问题就是如何在增广过程中维护这个距离标号

+ 维护距离标号的方法是这样的: 当找到增广路过程中发现某点出发没有允许弧时, 将这个点的距离标号设为由它出发的所有弧的终点的距离标号的最小值加一. 由于距离标号的存在, 由于"怎么走都是最短路", 所以就可以采用 $DFS$ 找增广路, 用一个栈保存当前路径的弧即可. 当某个点的距离标号被改变时, 栈中指向它的那条弧肯定已经不是允许弧了, 所以就让它出栈, 并继续用栈顶的弧的端点增广

+ 在实际操作中, 可以更加简单 (无脑)

  ——最开始给所有的点标号记为 $0$ 

  如果当前点无法走出去, 就给他提高一级

  出现断层就不行了

```c++
//SAP板子 (以邻接矩阵为例)

int dfs(int x, int flow) //x:当前点, flow:源点到x的最大流量
{
    if(x == t) return flow; //已到汇点,直接返回
    int sum = 0; //存x往后流能流多少
    for(int i = 1; i <= m; i++)
    {
        if(g[x][i] && (d[x] == d[i] + 1)) //x到i有一条边且是可允许弧
        {
            int tmp = dfs(i, min(g[x][i], flow - sum)); //能从x流到i的流量不超过x到i的边权,也不超过x在流完前面的点之后的剩余流量
            g[x][i] -= tmp;
            g[i][x] += tmp; //更改残量网络
            sum += tmp; //更改x流出的流量
            if(sum == flow) return sum; //流满了就不用再搜后面了
        }
    }
    if(d[1] >= m) return sum; //出现了断层,直接返回
    //正常提级d[1]是不可能大于等于m的,把它当成一个flag在用
    //cntd[i]: 表示i层的点的个数
    cntd[d[x]] --;
    if(!cntd[d[x]]) d[1] = m; //出现了断层,改"flag",让它一层一层返回
    d[x] ++; //给x提级
    cntd[d[x]] ++;

    return sum; //返回x能流出多少流量
}
```

+ 如果不用邻接矩阵而是用链式前向星

  每条边建边时同时给它建一个反向边 (0流量), 让原边的编号为 $2i$ , 新边的编号为 $2i + 1$ 

  这样编号为 $i$ 的反向边即为 $i \oplus 1$ 

+ 如使用 `vector` $\longrightarrow$ 需要再开一个域存反向边的位置 (不需要判断是否本身有和当前边相反的边再去找它的位置, 建一个新的就行了) $\Longrightarrow$ 不推荐使用

**Dinic算法**

+ Dinic算法是一个基于"层次图"的时间效率优先的最大流算法
+ 层次, 其实就是从源点走到那个点的最短路径长度
+ 于是乎, 我们得到一个定理: 从源点开始, 在层次图中沿着边不管怎么走, 经过的路径一定是终点在剩余图中的最短路
+ Dinic算法也有类似于sap的以顶点定标的过程——通常用 $BFS$ 实现
+ 每次从源点开始遍历, 如果一次 $bfs$ 可以从源点到汇点, 整个网络都会变成一个层次网络
+ 在一个分层网络中, 只有 $a[i] == a[j]$ 或 $a[i] == a[j] - 1$ 时 $<i, j>$ 才有边存在
+ 当且仅当 $a[i] == a[j] - 1$ 时, 两点之间的边才被称为有用边, 在接下来的寻找增广路的过程中只会走这样的有用边
+ 因此, $dfs$ 的时候只要遍历到汇点即可, 因为同一层和下一层都更新不了汇点了
+ 当残量网络分层后就可以进行多路增广了, 用 $dfs$ 从前一层到后一层反复找增广路. $dfs$ 过程中, 如果碰到了汇点说明找到了一条增广路, 此时要增加总流量, 削减各个边的流量, 添加反向边容量
+ 然后继续回溯 $dfs$ 找下一个增广路, 回溯到的节点 $u$ 满足——搜索树上的边 $u \to v$ 容量已经变为零
+ 如果回溯到了源点而且没法往下走了, $dfs$ 结束
+ 所以, 一次 $dfs$ 可以找到多条增广路
+ $dfs$ 结束后, 对残余网络再次分层, 当 $BFS$ 分层操作不能到达汇点, 算法结束, 最大流求出

```c++
//Dinic板子 (以链式前向星为例)

bool makelevel(int s, int t) //广搜标号
{
    memset(d, 0, sizeof d); //标号
    memset(q, 0, sizeof q); //手工队列
    d[s] = 1;
    int l = 0, r = 0;
    q[r ++] = s;
    while(l < r)
    {
        int x = q[l ++];
        if(x == t) return true;
        for(int i = head[x]; i != -1; i = edge[i].next)
        {
            if((d[edge[i].t] == 0) && (edge[i].w != 0)) //为了存反向边有权为0的边也在数组里,这种不能流流量不能算
            {
                q[r ++] = edge[i].t;
                d[edge[i].t] = d[x] + 1;
            }
        }
    }
    return false; //走不到汇点了,分层图没了
}

int dfs(int x, int flow, int t) //当前点,流入当前点流量
{
    if(x == t) return flow;
    int sum = 0;
    for(int i = head[x]; i != -1; i = edge[i].next)
    {
        if((edge[i].w != 0) && (d[edge[i].t] == d[x] + 1)) //是沿分层图在走
        {
            int tmp = dfs(edge[i].t, min(flow - sum, edge[i].w), t); //向下一个点流,最多能流给它的流量
            edge[i].w -= tmp;
            edge[i ^ 1].w += tmp; //更改残量网络
            sum += tmp;
            if(sum == flow) return sum; //已满,返回上一层
        }
    }
    return sum;
}

while(makelevel(1, m)) //如果还能分层标号
{
    ans += dfs(1, INF, m); //在分层图中进行增广
}
```

<br>

### 最小费用最大流

+ 带有费用的网络流图: $G = (V, E, C, W)$ 

  $V$ : 顶点; $E$ : 弧; $C$ : 弧的容量; $W$ : 单位流量费用

  在保证 $s$ 到 $t$ 流量最大的前提下, 所需的费用最小, 这就是最小费用最大流问题

+ 基本思路:

  把弧 $<i, j>$ 的单位费用 $w[i, j]$ 看作弧 $<i, j>$ 的路径长度, 每次找从源点 $s$ 到汇点 $t$ 长度最短 (费用最小) 的可增广路径进行增广

  1. 最小费用可增广路
  2. 路径 $s$ 到 $t$ 的长度即单位流量的费用'

+ 其实就是把ek算法中的广搜改成spfa (因为存在负权边所以得用bellman-ford或spfa)

```c++
bool spfa(int s, int t)
{
    queue<int> q;
    for(int i = 0; i < N; i++)
    {
        //每次spfa都要清数组
        dis[i] = INF; vis[i] = false; pre[i] = -1; //记前驱
    }
    dis[s] = 0; vis[s] = true;
    q.push(s);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(edge[i].cap > dege[i].flow && dis[v] > dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                pre[v] = i;
                if(!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    if(pre[t] == -1) return false; //汇点没走到的话就没有增广路了
    else return true;
}

//返回的是最大流,cost存的是最小费用
int minCostMaxflow(int s, int t, int &cost)
{
    int flow = 0;
    cost = 0;
    while(spfa(s, t)) //找到了一条增广路
    {
        int Min = INF;
        //从汇点沿前驱指针找回去
        for(int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])
        {
            if(Min > edge[i].cap - edge[i].flow)
                Min = edge[i].cap - edge[i].flow; //维护瓶颈边
        }
        //从汇点沿前驱回去更改残量网络和计算费用
        for(int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])
        {
            edge[i].flow += Min;
            edge[i ^ 1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
    return flow;
}
```

<br>

### 模型运用

**最大流模型**

**[网络流24题]最小路径覆盖**

+ 给定有向图 $G = (V, E)$ . 设 $P$ 是 $G$ 的一个简单路 (顶点不相交) 的集合. 如果 $V$ 中每个顶点恰好在 $P$ 的一条路上, 则称 $P$ 是 $G$ 的一个路径覆盖. $P$ 中路径可以从 $V$ 的任何一个顶点开始, 长度也是任意的, 特别地, 可以为 $0$ . $G$ 的最小路径覆盖是 $G$ 的所含路径条数最少的路径覆盖

  设计一个有效算法求一个有向无环图 $G$ 的最小路径覆盖

+ $1 \le n \le 150$ , $1 \le m \le 6000$ 

+ 把一个点拆成一个入点和一个出点

+ $s$ 向左集合的边容量也为 $1$ , 右集合向 $t$ 的容量也为 $1$ ——表示每个点最多只能有一个前驱和一个后继

+ 如果 $a$ 到 $b$ 有边, 就将 $a$ 的出点向 $b$ 的入点连边, 容量为 $1$ ——表示 $b$ 可以是 $a$ 的后继

+ 如果最终 $a$ 出 $\to$ $b$ 入的流量流过去了, 说明 $b$ 点在路径覆盖中放在了 $a$ 的后面, 那么 $b$ 不是一条路径覆盖的起点 ($a$ 也有可能不是起点, 要看之前有没有流量留到 $a$ 的入点)

+ 这样, 最大流就等于不作为路径覆盖的点数

+ $n$ $-$ 最大流就是答案

**[网络流24题]魔术球问题**

+ 假设有 $n$ 根柱子, 现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1, 2, 3, \dots$ 的球

  (1) 每次只能在某根柱子的最上面放球

  (2) 在同一根柱子中, 任何 $2$ 个相邻球的编号之和为完全平方数

  试设计一个算法, 计算出在 $n$ 根柱子上最多能放多少个球

+ $1 \le n \le 55$ 

+ 如果 $B$ 能放在 $A$ 的后面, 显然 $B$ 就可以接在 $A$ 上方而不用柱子

+ 一个点一个点添加, 如果能增加一点流量, 这个点就不需要柱子, 否则就需要柱子

+ 直到需要的柱子数大于 $n$ 就不能再加了

+ 注意: 本题因为题目的性质可以不做退流操作

+ 原因分析: 

+ 每加入一个数, 最大流要么不变, 要么 $+1$ 

+ 最大流 $+1$ 的条件: 当前这个数能接在之前的某个柱子最后一个数的后面

+ 最大流不变: 它不能接在之前的任意一个点的后面(给它开了个新柱子); 或者它接在了原来的某个点后面, 而原来那个点后面还有一串需要新开一个柱子

+ 以上无论哪种操作之后在每个柱子上的最后一个元素都还是那些, 所以不会影响后面的数怎么放

**[网络流24题]最长递增子序列问题**

+ 给定正整数序列 $x_1, x_2, \dots , x_n$ 

  (1) 计算其最长递增子序列的长度 $s$ 

  (2) 计算从给定的序列中最多可取出多少个长度为 $s$ 的递增子序列 (每个数只能用一次)

  (3) 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ , 则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列

+ $1 \le n \le 500$ 

+ 第一问: $f[i]$ 第 $i$ 个数作为最长递增子序列结尾的时候的长度

+ 第二问: $s$ 向 $f[i] = 1$ 的点的入点连容量为 $INF$ 的边, $f[i] = k$ 的点的出点向它能转移过去的 $f[j] = k+ 1$ 的点的入点连容量为 $1$ 的边, $f[i] = s$ 的点的出点向 $t$ 连容量为 $INF$ 的边. $i$ 的入点向 $i$ 的出点连容量为 $1$ 的边, 最大流即为答案

+ 第三问: $x_1$ 和 $x_n$ 的入点到出点的边容量限制改为 $INF$ 即可

+ (实现的时候可以直接在第二问求出的残量网络的基础上在 $x_1$ , $x_n$ 的入点和出点间加一条容量为 $INF$ 的边, 直接增广即可)

**[网络流24题]飞行员匹配方案问题**

+ 第二次世界大战期间, 英国皇家空军从沦陷国征募了大量外籍飞行员. 由皇家空军派出的每一架飞机都需要配备在航行技术和语言上能互相配合的 $2$ 名飞行员, 其中 $1$ 名是英国飞行员, 另 $1$ 名是外籍飞行员. 在众多的飞行员中, 每一名外籍飞行员都可以与其他若干名飞行员很好地配合. 如何选择配对飞行的飞行员才能使一次派出最多的飞机. 对于给定的外籍飞行员与英国飞行员的配合情况, 试设计一个算法找出最佳飞行员配对方案, 使皇家空军一次能派出最多的飞机
+ $2 \le n \le 100$ 
+ 二分图最大匹配
+ 用网络流可以这样建图
+ $S$ 向二分图左集合建一条容量为 $1$ 的边
+ 二分图右集合向 $T$ 建一条容量为 $1$ 的边
+ 匹配边的容量也是 $1$ 
+ 最大流就等于最大匹配

**[网络流24题]圆桌问题**

+ 假设有来自 $n$ 个不同单位的代表参加一次国际会议. 每个单位的代表数分别为 $r_i$ , $i = 1, 2, \dots, n$ . 会议餐厅共有 $m$ 张餐桌, 每张餐桌可容纳 $c_i$ $(i = 1, 2, \dots, m)$ 个代表就餐

  为了使代表们充分交流, 希望从同一个单位来的代表不在同一个餐桌就餐. 试设计一个算法, 给出满足要求的代表就餐方案

+ $1 \le m \le 150$ , $1 \le n \le 270$ , $1 \le r_i, c_i \le 10^3$ 

+ 二分图多重匹配——转换为最大流

+ $S$ 向餐桌连餐桌容量的边

+ 单位向 $T$ 连单位人数的边

+ 每个餐桌到每个单位连 $1$ 的边

+ 最大流等于总人数则可以

**[网络流24题]星际转移问题**

+ 由于人类对自然资源的消耗, 人们意识到大约在 $2300$ 年之后, 地球就不能再居住了. 于是在月球上建立了新的绿地, 以便在需要时移民. 令人意想不到的是, $2177$ 年冬由于未知的原因, 地球环境发生了连锁崩溃, 人类必须在最短的时间内迁往月球. 现有 $n$ 个太空站位于地球与月球之间, 且有 $m$ 艘公共交通太空船在期间来回穿梭. 每个太空站可容纳无限多的人, 而每艘太空船 $i$ 只可容纳 $H[i]$ 个人. 每艘太空船将周期性地停靠一系列的太空站, 例如: $(1, 3, 4)$ 表示该太空船将周期性地停靠太空站 $134134134\cdots$ . 每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$ . 人们只能在太空船停靠太空站(或月球、地球)时上、下船. 初始时所有人全在地球上, 太空船全在初始站. 试设计一个算法, 找出让所有人尽快地全部转移到月球上的运输方案
+ $1 \le n \le13$ , $1 \le m \le 20$ , $1 \le k \le50$ 
+ 枚举天数, 把每个太空站拆成天数个
+ 如果有一个线路为 $(1, 3, 4)$ 的太空船
+ 第一天的 $1$ 号太空站向第二天的 $3$ 号太空站连边, 第二天的 $3$ 号太空站向第三天的 $4$ 号太空站连边, 第三天的 $4$ 号太空站向第四天的 $1$ 号太空站连边 $\cdots$ 容量为该太空船容量
+ 因为太空站可以留人, 第 $i$ 天的第 $x$ 个太空站向第 $i + 1$ 天的第 $x$ 个太空站连容量为 $inf$ 的边即可
+ 不断加边增广, 当 $maxflow \ge$ 总人数就满足要求了

<br>

**最小割模型**

**[网络流24题]方格取数问题**

+ 在一个有 $m \times n$ 个方格的棋盘中, 每个方格中有一个正整数. 现要从方格中取数, 使任意 $2$ 个数所在的方格没有公共边, 且取出的数的总和最大. 试设计一个满足要求的取数算法, 找出最大和
+ $1 \le n, m \le 100$ , $1 \le a_{i, j} \le 10^5$ 
+ 黑白染色之后就是二分图最大点权独立集
+ $s$ 向黑点连边, 白点向 $t$ 连边, 边都为该点的权值
+ 相邻的黑白点之间, 连权值为 $inf$ 的值
+ 这样最小割是不可能割断黑白点之间的边的
+ 也就是说: 当 $AB$ 两个点相邻的时候, 要么隔断 $A$ 和 $s$ , 要么隔断 $B$ 和 $t$ 
+ 如果割断就表示这个点不选, 那么这就是 $AB$ 不能同时选
+ 要让选的数量最大, 就要让不选的数最小——刚好对应最小割
+ 答案 = 总和 - 最小割

**最大权闭合子图**

+ 有一个有向图, 每一个点都有一个权值(可以为正或负或0), 选择一个权值和最大的子图, 使得每个点的后继都在子图里面, 这个子图就叫最大权闭合子图
+ 解决方法:
+ 从源点 $s$ 向每个正权点连一条容量为权值的边, 每个负权点向汇点 $t$ 连一条容量为权值的绝对值的边, 有向图原来的边容量全部为无限大
+ 求它的最小割, 割掉后, 与源点 $s$ 连通的点构成最大权闭合子图, 权值为 (正权值之和 - 最小割)

<br>

**费用流模型**

**[网络流24题]运输问题**

+ $W$ 公司有 $m$ 个仓库和 $n$ 个零售商店. 第 $i$ 个仓库有 $a_i$ 个单位的货物; 第 $j$ 个零售商店需要 $b_j$ 个单位的货物. 货物供需平衡, 即 $a_1 + a_2 + \cdots + a_m = b_1 + b_2 + \cdots + b_n$ . 从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $w_{ij}$ . 试设计一个将仓库中所有货物运送到零售商店的有几年书方案, 使运输费用最少
+ $n, m \le 100$ 
+ 多源多汇——加超级源/汇

**[网络流24题]航空路线问题**

+ 给定一张航空图, 图中顶点代表城市, 边代表 $2$ 城市间的直通航线. 现要求找出一条满足下述限制条件的且途经城市最多的旅行路线
+ (1) 从最西端城市出发, 单向从西往东途径若干城市到达最东端城市, 然后再单向从东向西飞回起点(可途径若干城市)
+ (2) 除起点城市外, 任何城市只能访问 $1$ 次
+ $n < 100$ 
+ 一来一回等于从起点到终点走两次
+ 除了起点和终点, 一个点拆成两个点, 入点向出点连容量为 $1$ 费用为 $0$ 的边
+ 原来的边容量为 $1$ 费用为 $1$ 
+ 起/终点的入点向出点连容量为 $2$ 费用为 $0$ 的边
+ 求最大费用最大流

**[网络流24题]数字梯形问题**

+ 给定一个由 $n$ 行数字组成的数字梯形如下图所示. 梯形的第一行有 $m$ 个数字. 从梯形的顶部的 $m$ 个数字开始, 在每个数字处可以沿左下或右下方向移动, 形成一条从梯形的顶至底的路径
+ 规则1: 从梯形的顶至底的 $m$ 条路径互不相交
+ 规则2: 从梯形的顶至底的 $m$ 条路径仅在数字节点处相交
+ 规则3: 从梯形的顶至底的 $m$ 条路径允许在数字节点相交或边相交
+ 对于给定的数字梯形, 分别按照规则1, 规则2, 规则3计算出从梯形的顶至底的 $m$ 条路径, 使这 $m$ 条路径经过的数字总和最大
+ $m, n \le 20$ 

 ![](https://cdn.luogu.com.cn/upload/pic/12216.png)

+ 梯形的顶至底的 $m$ 条路径互不相交——一个点拆成两个点, 入点到出点连一条容量为 $1$ 费用为 $a[i]$ 的边, 每个点的出点向其下方的两个点的入点连一条容量为 $inf$ 费用为 $0$ 的边, $s$ 向最上方的 $m$ 个点连容量为 $1$ 费用为 $0$ 的边, 最下方的点向 $t$ 连容量为 $inf$ 费用为 $0$ 的边
+ 从梯形的顶至底的 $m$ 条路径仅在数字节点处相交——除了起点外其余点的入点和出点之间的容量为 $inf$ 
+ 从梯形的顶至底的 $m$ 条路径允许在数字节点和边相交—— $s$ 到起点连容量为 $1$ 的边, 剩下的边容量都为 $inf$ 

**[网络流24题]最长k可重区间集问题**

+ 给定实直线 $L$ 上 $n$ 个开区间组成的集合 $I$ , 和一个正整数 $k$ , 试设计一个算法, 从开区间集合 $I$ 中选取出开区间集合 $S \subseteq I$ , 使得在实直线 $L$ 的任何一点 $x$ , $S$ 中包含点 $x$ 的开区间个数不超过 $k$ , 且 $\sum_{z \in S}|z|$ 最大. 这样的集合 $S$ 称为开区间集合 $I$ 的最长 $k$ 可重区间集
+ $\sum_{z \in S}|z|$ 称为最长 $k$ 可重区间集的长度
+ 对于给定的开区间集合 $I$ 和正整数 $k$ , 计算开区间集合 $I$ 的最长 $k$ 可重区间集的长度
+ $1 \le n \le 500$ , $1 \le k \le 3$ , $1 \le l < r \le 10^5$ 
+ 其实就是最大权不相交路径问题
+ 按左端点排序所有区间, 把每个区间拆做两个顶点 $L_i$ , $R_i$ , 加一个顶点 $X$ 
+ $s$ 到 $X$ 连一条容量为 $k$ , 费用为 $0$ 的边——最后要找到 $k$ 个区间. 从 $X$ 到每个 $L_i$ 连一条容量为 $1$ , 费用为 $0$ 的边, 每个 $R_i$ 连一条容量为 $1$ , 费用为 $0$ 的边——这个区间只能提供 $1$ 的贡献度
+ $L_i$ 到 $R_i$ 连接一条容量为 $1$ , 费用为区间长度的边
+ 对于每个区间 $i$ , 它的 $R_i$ 与它右边的不相交的所有区间 $j$ 的 $L_j$ 各连一条容量为 $1$ , 费用为 $0$ 的边
+ 求最大费用最大流, 最大费用就是最长 $k$ 可重区间集的长度

**[网络流24题]深海机器人问题**

+ 深海资源考察探险队的潜艇将到达深海的海底进行科学考察. 潜艇内有多个深海机器人. 潜艇到达深海海底后, 深海机器人将离开潜艇向预定目标移动. 深海机器人在移动中还必须沿途采集海底生物标本. 沿途生物标本由最先遇到它的深海机器人完成采集. 每条预定路径上的生物标本的价值是已知的, 而且生物标本只能被采集一次. 本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动, 且多个深海机器人可以在同一时间占据同一位置
+ 用一个 $P \times Q$ 网格表示深海机器人的可移动位置. 西南角的坐标为 $(0, 0)$ , 东北角的坐标为 $(Q, P)$ . 给定每个深海机器人的出发位置和目标位置, 以及每条网格边上生物标本的价值. 计算深海机器人的最优移动方案, 使深海机器人到达目的地后, 采集到的生物标本的总价值最高
+ $1 \le P, Q \le 15$ , $1 \le a \le 4$ , $1 \le b \le 6$ 
+ 构图过程:
+ 每个点拆分成入点和出点, 之间建两种边, 分别是费用为该点相反数流量为 $1$ , 费用为 $0$ 流量为 $k - 1$ 
+ 路过这点时, 可以通过第一条边拿到数字
+ 以后再从这点经过时, 就没有数字可拿了, 走的就是第二条边
+ 每一个点向右和下连一条费用为 $0$ 容量为 $k$ 的边
+ $s$ , $t$ 分别连接左上角和右下角
+ 最大费用最大流即为最高总价值

**[网络流24题]负载平衡问题**

+ $G$ 公司有 $n$ 沿铁路运输线环形排列的仓库, 每个仓库存储的货物数量不等. 如何用最少搬运量可以使 $n$ 个仓库的库存数量相同. 搬运货物时, 只能在相邻的仓库之间搬运
+ $1 \le n \le 100$ 
+ 高于平均值的点都是要流出流量的
+ 低于平均值的点都是要流入流量的
+ 每个点可以向相邻的点留任意的流量
+ $s$ 向高于平均值的点连容量为 $delta$ , 费用为 $0$ 的边, 表示这个点多了这么多流量要流出来
+ 相邻的点之间连容量为 $inf$ , 费用为 $1$ 的双向边 (两条)
+ 低于平均值的点向 $t$ 连容量为 $delta$ , 费用为 $0$ 的边, 表示这个点流入了这么多流量

**[网络流24题]餐巾计划问题**

+ 一个餐厅在相继的 $N$ 天里, 每天需用的餐巾数不尽相同. 假设第 $i$ 天需要 $r_i$ 块餐巾 $(i = 1, 2, \cdots, n)$ . 餐厅可以购买新的餐巾, 每块餐巾的费用为 $p$ 分; 或者把旧餐巾送到快洗部, 洗一块需要 $m$ 天, 其费用为 $f$ 分; 或者送到慢洗部, 洗一块需要 $n$ 天 $(n > m)$ , 其费用为 $s$ 分 $(s < f)$ . 每天结束时, 餐厅必须决定将多少块脏的餐巾送到快洗部, 多少块餐巾送到慢洗部, 以及多少块保存起来延期送洗. 但是每天洗好的餐巾和购买的新餐巾数之和, 要满足当天的需求量. 试设计一个算法为餐厅合理地安排好 $N$ 天种餐巾使用计划, 使总的花费最少
+ $N \le 2000$ , $r_i \le 10000000$ , $p, f, s \le 10000$ 
+ 够用就行不用多买 (到哪天不够用了在哪一天买就行)
+ 每天需要的餐巾和用完的餐巾显然不是一样的东西 (有不同的来源和去向) 所以拆成两个点
+ 每天早上需要的餐巾
  + 必须有 $r_i$ 张, 即要保证这一天一定要接收 $r_i$ 的流量——向 $T$ 连容量为 $r_i$ 费用为 $0$ 的边
  + 来源为在今天买—— $S$ 向它连容量为 $INF$ 费用为 $p$ 的边
  + 之前某天洗干净送过来—— $i - m$ 天的脏毛巾向今天的需要的餐巾连容量为 $INF$ 费用为 $f$ 的边, 代表在 $m$ 天前送去快洗, $i - n$ 天的脏毛巾向今天的需要的餐巾连容量为 $INF$ 费用为 $s$ 的边, 代表在 $n$ 天前送去慢洗
+ 每天晚上的藏餐巾
  + 一定会产生 $r_i$ 张——直接从 $S$ 向这个点连容量为 $r_i$ 费用为 $0$ 的边
  + 送洗——向第 $i + m$ 天的需要的餐巾连容量为 $INF$ 费用为 $f$ 的边, 代表在这天送去快洗, 向第 $i + n$ 天的需要的餐巾连容量为 $INF$ 费用为 $s$ 的边, 代表在这天送去慢洗
  + 延迟送洗——向下一天的藏餐巾连容量为 $INF$ 费用为 $0$ 的边

<div style="page-break-after:always;"></div>

# 特殊性质和模型的运用

### 分层图思想

**[JLOI2011]飞行路线**

+ $Alice$ 和 $Bob$ 现在要乘飞机旅行, 他们选择了一家相对便宜的航空公司. 该航空公司一共在 $n$ 个城市设有业务, 设这些城市分别标记为 $0$ 到 $n - 1$ , 一共有 $m$ 种航线, 每种航线连接两个城市, 并且航线有一定的价格
+ $Alice$ 和 $Bob$ 现在要从一个城市沿着航线到达另一个城市, 途中可以进行转机. 航空公司对他们这次旅行也推出优惠, 他们可以免费在最多 $k$ 种航线上搭乘飞机. 那么 $Alice$ 和 $Bob$ 这次出行最少花费多少?
+ $2 \le n \le 10000$, $1 \le m \le 50000$, $0 \le k \le 10$ 

+ 法一: 分层建图
  + 将原图复制成 $k$ 层
  + 第 $i$ 层表示使用了 $i$ 次免费飞行之后的情况
  + 从第 $i$ 层图走到第 $i + 1$ 层图就是使用免费机票
  + 求最短路即可 (注意: 最终 $ans$ 应取到每一层终点最短路的最小值)
+ 法二: $dp$ 思想
  + 在 $dis$ 上加一维
  + $dis[i][j]$ 表示使用了 $j$ 次免费飞行之后到达 $i$ 点的最近距离是多少
  + 然后照常跑最短路就行 (注意: $vis$ 数组也应该加一维)
  + 实质上还是在分层图上跑最短路, 只是图没建出来

**[CF1473E]Minmum Path**

+ 给你一个无向图, 一条长度为 $k$ 的路径 $e_1, e_2, \cdots, e_k$ 的权值为 $\sum\limits_{i = 1}^{k} w_{e_i} - \max_{i = 1}^{k} w_{e_i} + \min_{i = 1}^{k} w_{e_i}$ , 问从 $1$ 到其他节点的路径权值最小为多少
+ $2 \le n \le 2 \cdot 10^5$ , $1 \le m \le 2 \cdot 10^5$ , $1 \le w_i \le 10^9$ 

+ $\min (\sum\limits_{i = 1}^{k} w_{e_i} - \max_{i = 1}^{k} w_{e_i} + \min_{i = 1}^{k} w_{e_i}) = \min (\sum\limits_{i = 1}^{k} w_{e_i} - w_{e_i} + w_{e_i})$
+ 问题转化为: 求 $1$ 到每一点的路径中都有一条边权值 $\times 2$ 和一条边权值变为 $0$ 的情况下的最短路径
+ 法一: 分层建图
  + 最下层: 什么都没发生过
  + 第 $2$ 层: 已有一条边权值 $\times 2$ $\quad\quad\quad$ 第 $2'$ 层: 已有一条边权值变为 $0$ 
  + 第 $3$ 层: 已有一条边权值 $\times 2$ 和一条边权值变为 $0$ 
+ 法二: $dp$ 思想
  + $dis[i][1/0][1/0]$ 表示走到了 $i$ 点, 有/无一条边权值 $\times 2$ , 有/无一条边权值变为 $0$ 时的最小权值
  + $vis$ 也相同是维数
  + $dis[x][1][1]$ 即点 $x$ 的答案

<br>

### 最短路图的利用

**核心: 与最短路有关的边和无关的边对事情的影响不同**

**求最短路径的条数**

+ 给你一张正权有向图
+ 求不同的最短路的条数
+ 路径 $A$ 经过的边与路径 $B$ 经过的边有一条不相同, 那么路径 $A$ 和路径 $B$ 就不同

> + $dist[v] = dist[u] + edge[u][v]$ 的边保留, 其他边删掉
> + 删掉不可能为最短路的边后的图为有向无环图
> + 求原图的最短路径的条数, 即求新图的路径条数 (累加)
> + $\Longrightarrow$ 拓扑 + $dp$ (一般写记忆化搜索)

**[HAOI2012]ROAD**

+ $C$ 国有 $n$ 座城市, 城市之间通过 $m$ 条单向道路连接. 一条路径被称为最短路, 当且仅当不存在从它的起点到终点的另外一条路径总长度比它小. 两条最短路不同, 当且仅当它们包含的道路序列不同. 我们需要对每条道路的重要性进行评估, 评估方式为计算有多少条不同的最短路经过该道路
+ $n \le 1500$ , $m \le 5000$ , $w \le 10000$ 

+ 删掉和最短路无关的边, 留下最短路图
+ 对于最短路图上的一条边 $<u, v>$ , 若 $s$ 到 $u$ 的最短路条数为 $x$ , $v$ 到 $t$ 的最短路条数为 $y$ , 则经过 $<u, v>$ 的最短路条数为 $x \times y$ 

**[GYM101986F]Pizza Delivery**

+ 一个有向图, $n$ 个点, $m$ 条边, $1$ 为起点, $2$ 为终点

+ 询问每次翻转一条边的方向, 最短路会不会发生改变

+ 如果变短了, 输出 $HAPPY$ 

+ 变长了或者达到不了了输出 $SAD$ 

+ 不变的话输出 $SOSO$ 

+ $ 2 \le n \le 100000$ , $1 \le m \le 10000$ 

+ 原本不在最短路上的边翻转之后只会变好或不变, 不会变坏

+ 原本在最短路上的边翻转后只会变坏或不变, 不会变好

+ 但这样原本 $3$ 种情况就变成 $4$ 种了, 可以但没必要 $\Longrightarrow$ 按 `HAPPY` , `SAD` , `SOSO` 讨论

  + ① `HAPPY` $\Longrightarrow$ 最短路变短

    $Dist[u] > dist[v] + edge[u][v]$ (其中 $Dist[u]$ 表示点 $u$ 要作为最短路上的点, $dist[u]$ 的最小值, $Dist[u] = \min dist_{s \to t} - \min dist_{u \to t}$ )

  + ② `SAD` $\Longrightarrow$ 最短路变更糟

    这条边得是所有最短路的必经之路

  + ③ `SOSO` $\Longrightarrow$ 最短路不变

    虽然这条路不行了, 但其他的最短路仍然是原来的距离

  所以 ② ③ 的判断就是判"经过这条边的最短路径的条数是不是等于总的最短路径的条数"

<br>

### 平面图思想

**[NC209695]狼抓兔子**

+ 在小朋友们最喜欢的"喜羊羊与灰太狼", 话说灰太狼抓不到羊, 但抓兔子还是比较在行的, 而且现在的兔子还比较笨, 它们只有两个窝, 现在你作为狼王, 面对下面这样一个网格的地
+ 左上角点为 $(1, 1)$ , 右下角点为 $(N, M)$ . 有以下三种类型的道路:
+ $(x, y) \rightleftharpoons  (x + 1, y)$ , $(x, y) \rightleftharpoons (x, y + 1)$ , $(x, y) \rightleftharpoons (x + 1, y + 1)$ 

![狼抓兔子](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\图论专题\狼抓兔子.jpg)

+ 道路上的权值表示这条路上最多能通过的兔子数, 道路是无向的. 左上角和右下角为兔子的两个窝, 开始时所有的兔子都聚集在左上角 $(1, 1)$ 的窝里, 现在它们要跑到右下角 $(N, M)$ 的窝中去, 狼王开始伏击这些兔子. 当然为了保险起见, 如果一条道路上最多通过的兔子数为 $K$ , 狼王需要安排同样数量的 $K$ 只狼, 才能完全封锁这条道路, 你需要帮助狼王安排一个伏击方案, 使得在将兔子一网打尽的前提下, 参与的狼的数量要最小. 因为狼还要去找喜羊羊的麻烦
+ $3 \le N, M \le 1000$ 
+ 最大流/最小割——看起来是个网络流模板题
+ 但点数是 $10^6$ , 不能用网络流来解决
+ **平面图的最小割等于其对偶图的最短路**
+ 平面图是什么?
+ 一个无向图 $G = (V, E)$ , 如果能把 $G$ 画在一个平面上, 且除了在节点处外, 边两两不相交, 则图 $G$ 是平面图
+ 如何判断一个图是不是平面图?
+ 拓扑学欧拉公式:
+ 对于连通平面图 $G = (V, E, F)$ 
+ $|V| - |E| + |F| = 2$ 
+ $F$ 指的是面
+ 面是平面图在一般图的点和边之外多出的概念
+ 在平面图中, 如果有一条或多条边界定成的区域, 区域中不包含其他的边, 那么这个区域被称为平面图的一个面, 用 $f$ 表示这些面 (称为面的边界), 边界上边的数量被称为面的度 $d(f)$ , 所以平面图也可以表示为 $G = (V, E, F)$ , $F$ 为平面图上所有面的集合
+ 最外面的无穷大的区域也算一个面
+ 对偶图是什么?
+ 对偶图是与平面图相伴的一种图. 对于给定平面图 $G = <V, E>$ , 设 $G$ 的面为 $F_1, F_2, \cdots , F_e$ , 当图 $G^*$ 满足如下条件时, 则图 $G^* = <V^*, E^*>$ 称为 $G$ 的对偶图:
+ ① 对 $G$ 的每个面 $F_o$ , 内部任选一点 $v^*_o \in V^*$ 
+ ② 对 $F_o$ , $F_x$ 的每一条公共边界 $e_\partial $ , $v_o^*$ 与 $v_x^*$ 间有一条边 $e_\partial^*$ , 并且 $e_\partial ^*$ 与 $e_\partial$ 交于一点
+ ③ 当且仅当 $e_\partial $ 仅是一个面 $F_o$ 的边界时, $v_o^*$ 有一个环(自回路), $e_o^*$ 与 $e_\partial $ 相交

![狼抓兔子 - 副本](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\图论专题\狼抓兔子 - 副本.jpg)

+ 平面图中的面与对偶图中的点一一对应, 平面图中的边与对偶图中的边一一对应, 权值相等
+ 将平面图一分为二后, 平面图的起点和终点分别位于两侧, 对偶图中与无穷大面相连的点, 平面图中左侧的点与左侧的无穷大点相连, 平面图中右侧的点与右侧的无穷大点相连
+ 对偶图的最短路等于平面图的最小割

**[HNOI2010]平面图判定**

+ 给定一个图 $G = (V, E)$ , $G$ 中存在一条哈密尔顿回路 $P$ . 现在要你判断图 $G$ 是不是平面图
+ $T \le 100$ , $n \le 200$ , $m \le 10000$ 
+ $|V| - |E| + |F| = 2$ 
+ 推论: 对于连通图 $G = (V, E, F)$ , 当 $|V| \ge 3$ 时, 有 $|E| \le 3|V| - 6$ , $|F| \le 2|V| - 4$ 
+ 所以本题边数其实小于等于 $600$ 
+ 存在哈密尔顿回路——要想让它还是平面图, 这个回路得化成一个圆
+ 剩下的边可以认为是圆的弦
+ 如果两条弦相交, 那么可以一条放在圆里面, 一条放到圆外面
+ 也就是说, 对于任意两条相交的弦, 要放在两个不同的集合里面——二分图判定问题

<br>

### 其他

**[SCOI2012]滑雪与时间胶囊**

+ $evilboy$ 非常喜欢滑雪. 他来到一座雪山, 这里分布着 $M$ 条供滑行的轨道和 $N$ 个轨道之间的交点(同时也是景点), 而且每个景点都有一编号 $i$ $(1 \le i \le N)$ 和一高度 $H_i$ . $evilboy$ 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边, 且 $i$ 的高度不小于 $j$ 
+ 与其他滑雪爱好者不同, $evilboy$ 喜欢用最短的滑行路径去访问尽量多的景点. 如果仅仅访问一条路径上的景点, 他会觉得数量太少. 于是 $evilboy$ 拿出了他随身携带的时间胶囊
+ 这是一种很神奇的药物, 吃下之后可以立即返回上个经过的景点(不用移动也不被认为是 $evilboy$ 滑行的距离)
+ 请注意, 这种神奇的药物是可以连续食用的, 即能够回到较长时间之前到达的景点(比如上上个经过的景点和上上上个经过的景点)
+ 现在, $evilboy$ 站在 $1$ 号景点望着山下的目标, 心潮澎湃. 他十分想知道在不考虑时间胶囊消耗的情况下, 以最短滑行距离滑行到尽量多的景点的方案(即满足经过景点数最大的前提下使得滑行总距离最小). 你能帮他求出最短距离和景点数吗?
+ $1 \le n \le 10^5$ , $1 \le m \le 10^6$ 
+ 最小树形图
+ 定义: $G = (V, E)$ 满足以下性质
  + $G$ 中不包含有向环
  + 存在一个根节点 $u$ , 它不是任何弧的终点, 而且其他顶点都恰好是唯一一条弧的终点
  + 最小树形图就是权值最小的那个
+ 最小树形图有 朱刘算法 $O(nm)$ , 但复杂度本题不行
+ 观察本题图的特殊性: 是有层次的, 边只能从高的向低(相同高度)连 $\Longrightarrow$ 分层图
+ $\Longrightarrow$ $Kruskal$ / $Prim$ 时, 将边先按入点的高度从从高到低排序, 这样保证高点已经连通之后再连低点

**[CF724E]Goods Transportation**

+ $n$ 个工厂, 每个工厂有生产量 $p_i$ 和最多销售量 $s_i$ . 小编号工厂可以往大编号工厂运送货物, 每对工厂最多传送 $c$ 单位货物. 传送顺序任意
+ 问最终所有工厂的最大总销售量
+ $1 \le n \le 10000$ , $1 \le c \le 10^9$ , $1\le p_i \le 10^9$ , $1 \le s_i \le 10^9$ 
+ 最大流模型
  + 源点向每个工厂连一条容量为 $p_i$ 的边, 每个工厂向汇点连一条容量为 $s_i$ 的边
  + 每个编号小的工厂往编号大的工厂连一条容量为 $c$ 的边
  + 时间复杂度不允许
+ 考虑这个图的特殊性: 每个点向它后面的点连边且边的容量相同, 每个点最开始都与 $S$ 和 $T$ 有边
+ $\Longrightarrow$ 实际上是在想: 能不能不使用网络流的算法来求最大流
+ 最大流 = 最小割 $\Longrightarrow$ 每个点要么和 $S$ 割开, 要么和 $T$ 割开
+ $dp[i][j]$ 表示前 $i$ 个点中有 $j$ 个点并未和 $S$ 隔断时, $i$ 及其之前的点的最小割
  + $i$ 有两种情况: 
    + $i$ 和 $S$ 割开 ($S \to i$ 的边要断掉): $dp[i][j] = dp[i - 1][j] + p_i + j \times c$ 
    + $i$ 和 $T$ 割开 ($i \to T$ 的边要断掉): $dp[i][j] = dp[i - 1][j - 1] + s_i$ 
  + 时间复杂度 $O(n^2)$ 
  + 空间需要用滚动数组

<div style="page-break-after:always;"></div>

# 其他算法介绍

### Kruskal重构树

**用"虚点"来表示 $kruskal$ 连来的树边, 用新的点权来代表边权**

基本思想: 在运行 $Kruskal$ 算法的过程中, 对于两个可以合并的节点 $(x, y)$ , 断开其中的连边, 并新建一个节点 $T$ , 把 $T$ 向 $x$ , $y$ 连边并作为他们的父亲, 同时, 把 $(x, y)$ 之间的边权当作 $T$ 的点权

```c++
void Ex_Kruskal()
{
    int cnt = n;
    sort(e, e + m, cmp);
    for(int i = 1; i < n * 2; i++) p[i] = i;
    
    for(int i = 0; i < m; i++)
    {
        int u = get(e[i].x), v = get(e[i].y);
        if(u != v)
        {
            ++ cnt;
            p[u] = p[v] = cnt;
            val[cnt] = e[i].w;
            add(cnt, u), add(cnt, v);
            if(cnt == 2 * n - 1) break;
        }
    }
}
```

$Kruskal$ 重构树的性质:

1. 节点个数为 $2 \times n - 1$ 
2. 它是一棵二叉树
3. 若边权升序, 则它是一个大根堆
4. 任意两点路径边权最大值为 $Kruskal$ 重构树上 $LCA$ 的点权

<div style="page-break-after:always;"></div>

# 区间信息维护

### 前缀和、差分

#### 前缀和

+ 前缀和是为了解决这样一个问题:
+ 给定一个长度大小为 $N$ 的数组, 进行静态的 $M$ 轮查询. 每轮查询一个连续区间 $l$ ~ $r$ , 问区间元素和

```c++
for(int i = 1; i <= n; i++)
    sum[i] = sum[i - 1] + a[i];

int ans = sum[r] - sum[l - 1];
```

#### 前缀和的变形

+ 广义的 "前缀和" 运算是指连续的进行若干次操作, 产生一个叠加影响, 如果这种影响可以通过某种反向操作 "撤销"
+ 比较常见的, 有满秩矩阵的链乘法、卷积等

**前缀积**

+ 给定一个长度大小为 $N$ 的正整数数组, 查询 $M$ 轮, 每次问一个区间所有元素的连续乘积

  由于这个答案可能很大, 你只用输出结果对 $10^9 + 7$ 取余数后的结果即可

```c++
LL get_inv(LL x) //乘法逆元
{
    return quickpow(x, mod - 2, mod);
}

premul[0] = 1;
for(int i = 1; i <= n; i++)
    premul[i] = premul[i - 1] * a[i] % mod;

LL ans = premul[r] * get_inv(premul[l - 1]) % mod;
```

**前缀置换**

+ 有编号为 $0$ ~ $9$ 的 $10$ 个小球, 按照从左到右编号为 $0, 1, 2, 3 \dots 9$ 的顺序摆在了桌子上, 并把这 $10$ 个球用 $10$ 个不透明的杯子倒扣住

  有一个长度大小为 $n$ 的操作序列

  每次操作都有两个非负整数 $a$ , $b$ , 表示本次操作将会交换从左往右数第 $a$ 个杯子和从左往右数第 $b$ 个杯子 ($a$ 和 $b$ 均从 $0$ 开始数)

  一共进行 $m$ 轮猜球游戏, 在每一轮游戏开始时, 都将杯子中的小球重置到从左往右依次为 $0, 1, 2, 3 \dots 9$ 的状态, 然后在第 $i$ 轮游戏中会按照操作序列中的第 $l_i$ 个操作开始做, 一直做到第 $r_i$ 个操作结束 ($l$ 和 $r$ 的编号从 $1$ 开始计算), 求每一轮游戏结束时, 从左至右的杯子中的小球的编号各是多少

```c++
struct ballList
{
    int pos[10];
};
ballList operator - (const ballList A, const ballList B)
{
    ballList C, temp;
    for(int i = 0; i < 10; i++)
        temp.pos[B.pos[i]] = i;
    for(int i = 0; i < 10; i++)
        C.pos[i] = temp.pos[A.pos[i]];
    return C;
}

for(int i = 0; i < 10; i++)
    presum[0].pos[i] = i;
for(int i = 1; i <= n; i++)
{
    cin >> u >> v;
    presum[i] = presum[i - 1];
    swap(presum[i].pos[u], presum[i].pos[v]);
}

ballList ans = presum[r] - presum[l - 1];
```

**前缀矩阵积**

```c++
struct Mat
{
    LL a[MAX_MAT][MAX_MAT];
    Mat()
    {
        for(int i = 0; i < MAX_MAT; i++)
            for(int j = 0; j < MAX_MAT; j++)
				if(i == j) a[i][j] = 1;
        		else a[i][j] = 0;
    }
    Mat(LL a1, LL a2, LL a3, LL a4)
    {
        a[0][0] = a1;
        a[0][1] = a2;
        a[1][0] = a3;
        a[1][1] = a4;
    }
};
LL A[MAX_MAT][MAX_MAT << 1];

//求逆元
LL get_inv(LL x)
{
    return quickpow(x, mod - 2, mod);
}
//行变换: 第a行减去第b行的k倍
void row_minus(int a, int b, LL k)
{
    for(int i = 0; i < 2 * MAX_MAT; i++)
    {
        A[a][i] = (A[a][i] - A[b][i] * k % mod) % mod;
        if(A[a][i] < 0) A[a][i] + mod;
    }
}
//行变换: 第a行乘以k
void row_multiplies(int a, LL k)
{
    for(int i = 0; i < 2 * MAX_MAT; i++)
        A[a][i] = (A[a][i] * k) % mod;
}
//行变换: 交换第a行和第b行
void row_swap(int a, int b)
{
    for(int i = 0; i < 2 * MAX_MAT; i++)
        swap(A[a][i], A[b][i]);
}

//求逆矩阵
Mat getinv(Mat x)
{
    memset(A, 0, sizeof A);
    for(int i = 0; i < MAX_MAT; i++)
        for(int j = 0; j < MAX_MAT; j++)
        {
            A[i][j] = x.a[i][j];
            A[i][MAX_MAT + j] = i == j;
        }
    for(int i = 0; i < MAX_MAT; i++)
    {
        if(!A[i][j])
        {
            for(int j = i + 1; j < MAX_MAT; j++)
                if(A[j][i])
                {
                    row_swap(i, j);
                    break;
                }
        }
        row_multiplies(i, get_inv(A[i][i]));
        for(int j = i + 1; j < MAX_MAT; j++)
            row_minus(j, i, A[j][i]);
    }
    for(int i = MAX_MAT - 1; i >= 0; i--)
        for(int j = i - 1; j >= 0; j--)
            row_minus(j, i, A[j][i]);
    Mat ret;
    for(int i = 0; i < MAX_MAT; i++)
        for(int j = 0; j < MAX_MAT; j++)
            ret.a[i][j] = A[i][MAX_MAT + j];
    return ret;
}

Mat operator * (Mat x, Mat y)
{
    Mat c;
    for(int i = 0; i < MAX_MAT; i++)
        for(int j = 0; j < MAX_MAT; j++)
            c.a[i][j] = 0;
    for(int i = 0; i < MAX_MAT; i++)
        for(int j = 0; j < MAX_MAT; j++)
            for(int k = 0; k < MAX_MAT; k++)
                c.a[i][j] = (c.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;
    return c;
}

presum[0] = Mat(1, 0, 0, 1);
for(int i = 1; i <= n; i++)
    presum[i] = presum[i - 1] * t[i];

Mat ans = getinv(presum[l - 1]) * presum[r]; //矩阵乘法不能交换顺序
```

#### 前缀和与差分

+ 给定一个长度大小为 $N$ 的数组, 数组元素为整数, 首先进行 $M$ 次修改操作, 每次给 $l$ ~ $r$ 的区间范围的元素同时加上一个数字 $x$ . $M$ 次操作后输出整个数组

```c++
void add(int l, int r, int x)
{
    d[l] += x, d[r + 1] -= x;
}

for(int i = 0; i < m; i++)
    add(l, r, x);
for(int i = 1; i <= n; i++)
    a[i] = a[i - 1] + d[i];
```

+ 给定一个长度大小为 $N$ 的数组, 数组元素为整数, 首先进行 $M$ 次修改操作, 每次给 $l$ ~ $r$ 的区间范围的元素, 给 $l$ ~ $r$ 中的第一个元素 $+1$ , 第二个元素 $+2$ , 第三个元素 $+3$ $\dots$ 依此类推, 第 $r - l + 1$ 个元素 $+ r - l + 1$ . $M$ 次操作后输出整个数组

```c++
void add(int l, int r)
{
    int k = r - l + 1;
    dd[l] ++, dd[r + 1] -= k + 1, dd[r + 2] += k;
}

for(int i = 0; i < m; i++)
    add(l, r);
for(int i = 1; i <= n; i++)
{
    d[i] = d[i - 1] + dd[i];
    a[i] = a[i - 1] + d[i];
}
```

+ 在区间 $[l, r]$ 内加首项为 $a_0$ , 公差为 $d_0$ 的等差数列

```c++
void add(l, r, a0, d0)
{
    int k = r - l + 1;
    ddd[l] += a0, ddd[l + 1] -= a0 - d0;
    ddd[r + 1] -= a0 + k * d0, ddd[r + 2] += a0 + (k - 1) * d0;
}

for(int i = 0; i < m; i++)
    add(l, r, a0, d0);
for(int i = 1; i <= n; i++)
{
    dd[i] = dd[i - 1] + ddd[i];
    d[i] = d[i - 1] + dd[i];
    a[i] = a[i - 1] + d[i];
}
```

+ 从第 $x$ 个位置开始加平方数列 $(1, 4, 9, 16, 25 \dots)$ 

```c++
void add(x)
{
    ddd[x] ++, ddd[x + 1] ++;
}

for(int i = 0; i < m; i++)
    add(x);
for(int i = 1; i <= n; i++)
{
    dd[i] = dd[i - 1] + ddd[i];
    d[i] = d[i - 1] + dd[i];
    a[i] = a[i - 1] + d[i];
}
```

+ 区间加多项式

+ 现在有一个长度大小为 $N$ 的数组, 数组中有一些非负整数, 完成区间加若干次多项式的操作后, 最后进行若干次区间查询和的操作

  具体来讲, 接下来会进行 $M$ 次修改操作, 每次将会给你一个 $k$ 次多项式

  $f(x) = c_0x^k + c_1x^{k - 1} + \dots + c_{k - 1}x^1 + c_k$ , 以及一段需要操作的目标数组区间 $[l, r]$ 

  然后你需要对 $a_l + f(1)$ , $a_{l + 1} + f(2)$ $\dots$ 以此类推, 也就是对目标区间的第一个数字加上一个 $f(1)$ , 第二个数字加上 $f(2)$ $\dots$ 

  在做完这些操作之后, 还会进行 $Q$ 次查询操作, 每次查询一段 $[l, r]$ 的区间元素和, 因为这些数字可能很大, 你只用输出其对 $10^9 + 7$ 取余数后的结果即可

+ 数学定理: 最高次项为 $n$ 次的 $n$ 阶多项式做 $n + 1$ 阶差分后余项为常数

```c++
LL l, r, a[MAXN], ki[MAXK], coef1[MAXK], coed2[MAXK];

//做cnt次前缀和
void P(LL a[], int len, int cnt = 1)
{
    while(cnt --)
    {
        for(int i = 1; i <= len; i++)
        {
            a[i] += a[i - 1];
            if(a[i] >= mod) a[i] -= mod;
        }
    }
}
//做cnt次差分
void D(LL a[], int len, int cnt = 1)
{
    while(cnt --)
    {
        for(int i = len; i; i--)
        {
            a[i] -= a[i - 1];
            if(a[i] < 0) a[i] += mod;
        }
    }
}

//求多项式
LL f(LL x, LL a[], int k)
{
    LL ret = 0;
    LL base = 1;
    for(int i = k; i >= 0; i--)
    {
        ret += base * a[i] % mod;
        if(res >= mod) ret -= mod;
        base = base * x % mod;
    }
    return ret;
}
LL g(LL x, LL a[], int k, LL l, LL r)
{
    return (mod - f(x + r - l + 1, a, k)) % mod;
}

int main()
{
    cin >> n >> m >> q;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    D(a, n, 6);
    
    while(m --)
    {
        cin >> l >> r >> k;
        for(int i = 0; i <= k; i++)
            cin >> ki[i];
        for(int i = 1; i <= 10; i++)
        {
            coef1[i] = f(i, ki, k);
            coef2[i] = g(i, ki, k, l, r);
        }
        D(coef1, 10, 6);
        D(coef2, 10, 6);
        for(int i = 1; i <= 10; i++)
        {
            a[l + i - 1] += coef1[i];
            if(a[l + i - 1] >= mod) a[l + i - 1] -= mod;
            a[r + i] += coef2[i];
            if(a[r + i] >= mod) a[r + i] -= mod;
        }
    }
    P(a, n, 7);
    
    while(q --)
    {
        cin >> l >> r;
        cout << (((a[r] - a[l - 1]) % mod + mod) % mod) << endl;
    }
}
```

#### 高阶前缀和

前面这个算法只适合次数比较低的多项式, 但是可以继续扩展

对于数组 $a$ , 定义 $a$ 数组的前缀和为一阶前缀和, 定义数组 $a$ 前缀和的前缀和为二阶前缀和

如何快速求 $a$ 数组的 $k$ 阶前缀和, 还是要计算贡献, 这个贡献是一个组合数贡献

> 给定一个长度大小为 $N$ 的数组 $a$ 和一个参数 $k$ 
>
> + 当 $k > 0$ 时, 请输出对 $a$ 做 $k$ 次前缀和后的结果
> + 当 $k = 0$ 时, 请直接输出 $a$ 数组
> + 当 $k < 0$ 时, 请输出对 $a$ 做 $k$ 次差分后的结果

```c++
#include<bits/stdc++.h>
using namespace std;
namespace NTT
{
    const long long g = 3;  // 原根 g
    const long long p = 998244353;  // 模数 p
    long long wn[35];  // 原根的幂次数组

    // 快速幂取模
    long long pow2(long long a, long long b)
    {
        long long res = 1;
        while (b)
        {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    // 计算原根的幂次数组
    void getwn()
    {
        for (int i = 0; i < 25; i++) wn[i] = pow2(g, (p - 1) / (1LL << i));
    }

    // 快速数论变换
    void ntt(long long *a, int len, int f)
    {
        long long i, j = 0, t, k, w, id;
        for (i = 1; i < len - 1; i++)
        {
            for (t = len; j ^= t >>= 1, ~j & t;);
            if (i < j) swap(a[i], a[j]);
        }
        for (i = 1, id = 1; i < len; i <<= 1, id++)
        {
            t = i << 1;
            for (j = 0; j < len; j += t)
            {
                for (k = 0, w = 1; k < i; k++, w = w * wn[id] % p)
                {
                    long long x = a[j + k], y = w * a[j + k + i] % p;
                    a[j + k] = (x + y) % p;
                    a[j + k + i] = (x - y + p) % p;
                }
            }
        }
        if (f)
        {
            for (i = 1, j = len - 1; i < j; i++, j--) swap(a[i], a[j]);
            long long inv = pow2(len, p - 2);
            for (i = 0; i < len; i++) a[i] = a[i] * inv % p;
        }
    }

    // 多项式乘法
    void mul(long long *a, long long *b, int l1, int l2)
    {
        int len, i;
        for (len = 1; len <= l1 + l2; len <<= 1);
        for (i = l1 + 1; i <= len; i++) a[i] = 0;
        for (i = l2 + 1; i <= len; i++) b[i] = 0;
        ntt(a, len, 0); ntt(b, len, 0);
        for (i = 0; i < len; i++) a[i] = a[i] * b[i] % p;
        ntt(a, len, 1);
    }
};

const int MAXN = 300005;
const long long mod = 998244353;
int n;
long long a[MAXN], inv[MAXN], ki[MAXN], k;

// 初始化逆元数组
void init(long long n)
{
    inv[0] = inv[1] = 1;
    for (long long i = 2; i <= n; i++)
    {
        inv[i] = ((mod - mod / i) * inv[mod % i]) % mod;
    }
    return;
}

// 计算系数数组 ki
void get_ki(long long k, int len)
{
    k = (k % mod + mod) % mod;
    ki[0] = 1;
    for (int i = 1; i < len; ++i)
    {
        ki[i] = ki[i - 1] * inv[i] % mod * ((k + i - 1) % mod) % mod;
    }
}

int main()
{
    NTT::getwn();
    init(100000);
    scanf("%d %lld", &n, &k);
    get_ki(k, n);
    for (int i = 0; i < n; ++i)
    {
        scanf("%lld", &a[i]);
    }
    NTT::mul(a, ki, n, n);
    for (int i = 0; i < n; ++i)
    {
        printf("%lld%c", a[i], i == n - 1 ? '\n' : ' ');
    }
    return 0;
}
```

#### 高维前缀和 (SOSDP)

```c++
//k维数组, 每维数组大小为2 ——> 二进制
const int MAXN = 25, MAXSIZE = 1 << MAXN;
int n, maxbit;

maxbit = 1 << n;
for(int i = 0; i < n; i++)
    for(int j = 0; j < maxbit; j++)
        if(j & (1 << i)) presum[j] += pre_sum[j ^ (1 << i)];
```

<br>

### 树状数组、线段树

#### 树状数组

+ 树状数组被理解成是"可以修改"的前缀和. 使用时有什么局限性?
  1. 因为树状数组的本质是前缀和, 所以依赖"前缀可减性"
  2. 树状数组的单点修改具有局限性, 例如"带修改的前缀max, min", 修改中必须具有单调性

**树状数组 $O(n)$​ 建树**

```c++
//暴力建树 O(nlogn)
void add(int x, int c)
{
    for(int i = x; i <= n; i += lowbit(i))
        tr[i] += c;
}
void build()
{
    for(int i = 1; i <= n; i++)
        add(i, b[i]);
}

//O(n)建树一
void build()
{
    for(int i = 1; i <= n; i++)
    {
        s[i] = s[i - 1] + b[i]; //s是前缀和数组
        tr[i] = s[i] - s[i - lowbit(i)];
    }
}

//O(n)建树二
void build()
{
    for(int i = 1; i <= n; i++)
    {
        tr[i] += b[i];
        if(i + lowbit(i) <= n)
            tr[i + lowbit(i)] += tr[i];
    }
}
```

#### 线段树

+ 可以用线段树维护信息条件之一就是, 区间信息满足可加性
+ 对于简单问题来说, 没有必要对懒标记做很复杂的设计, 但是当需要维护的信息足够复杂, 或者修改操作足够复杂, 多种懒标记互相影响时, 这是有必要的
+ 在复杂问题中, 至少要为 $lazytag$ 设计如下三个函数
  + `pushdown()` $\quad$ 标记下传
  + `cal_lazy()` $\quad$ 计算懒标记的值
  + `tag_union()` $\quad$ 通过懒标记更新区间信息

>维护四种操作:
>
>+ 询问区间 $[l, r]$ 内的元素和
>+ 询问区间 $[l, r]$ 内的元素的平方和
>+ 将区间 $[l, r]$ 内的每一个元素都乘上 $x$ 
>+ 将区间 $[l, r]$ 内的每一个元素都加上 $x$ 

```c++
struct tnode
{
    long long sum[2], lazy[2];
    int l, r;
};
struct Segment_Tree
{
    tnode t[4 * MAXN];
    void init_lazy(int root)
    {
        t[root].lazy[0] = 1;
        t[root].lazy[1] = 0;
    }
    void union_lazy(int fa, int ch)
    {
        long long temp[2];
        temp[0] = t[fa].lazy[0] * t[ch].lazy[0];
        temp[1] = t[fa].lazy[0] * t[ch].lazy[1] + t[fa].lazy[1];
        t[ch].lazy[0] = temp[0];
        t[ch].lazy[1] = temp[1];
    }
    void cal_lazy(int root)
    {
        t[root].sum[1] = t[root].lazy[0] * t[root].lazy[0] * t[root].sum[1] 
				+ t[root].lazy[1] * t[root].lazy[1] * (t[root].r - t[root].l + 1) 
				+ t[root].lazy[0] * t[root].lazy[1] * 2 * t[root].sum[0];
        t[root].sum[0] = t[root].lazy[0] * t[root].sum[0] 
				+ t[root].lazy[1] * (t[root].r - t[root].l + 1);
        return;
    }
    void push_down(int root)
    {
        if (t[root].lazy[0] != 1 || t[root].lazy[1] != 0)
        {
            cal_lazy(root);
            if (t[root].l != t[root].r)
            {
                int ch = root << 1;
                union_lazy(root, ch);
                union_lazy(root, ch + 1);
            }
            init_lazy(root);
        }
    }
    void update (int root)
    {
        int ch = root << 1;
        push_down(ch);
        push_down(ch + 1);
        t[root].sum[0] = t[ch].sum[0] + t[ch + 1].sum[0];
        t[root].sum[1] = t[ch].sum[1] + t[ch + 1].sum[1];
    }
    void build(int root, int l, int r)
    {
        t[root].l = l;
        t[root].r = r;
        init_lazy(root);
        if (l != r)
        {
            int mid = (l + r) >> 1;
            int ch = root << 1;
            build(ch, l, mid);
            build(ch + 1, mid + 1, r);
            update(root);
        }
        else
        {
            t[root].sum[0] = A[l];
            t[root].sum[1] = A[l] * A[l];
        }
    }
    void change(int root, int l, int r, long long delta, int op)
    {
        push_down(root);
        if (l == t[root].l && r == t[root].r)
        {
            t[root].lazy[op] = delta;
            return;
        }
        int mid = (t[root].l + t[root].r) >> 1;
        int ch = root << 1;
        if (r <= mid)change(ch, l, r, delta,op);
        else if (l > mid)change(ch + 1, l, r, delta,op);
        else 
        {
            change(ch, l, mid, delta,op);
            change(ch + 1, mid + 1, r, delta,op);
        }
        update(root);
    }
    long long sum(int root, int l, int r, int op)
    {
        push_down(root);
        if (t[root].l == l && t[root].r == r)
        {
            return t[root].sum[op];
        }
        int mid = (t[root].l + t[root].r) >> 1;
        int ch = root << 1;
        if (r <= mid)return sum(ch, l, r, op);
        else if (l > mid)return sum(ch + 1, l, r, op);
        else return sum(ch, l, mid, op) + sum(ch + 1, mid + 1, r, op);
    }
};
```

> 维护三种操作:
>
> + 将区间 $[l, r]$ 内的每一个元素都加上 $v$ 
> + 将区间 $[l, r]$ 内的每一个元素都乘上 $v$
> + 查询区间 $[l, r]$ 内两两元素的乘积和 

```c++
struct tnode
{
    long long sum[2], lazy[2];
    int l, r;
};
tnode operator + (const tnode &A, const tnode &B)
{
    tnode C;
    C.l = A.l;
    C.r = B.r;
    C.lazy[0] = 1;
    C.lazy[1] = 0;
    C.sum[0] = A.sum[0] + B.sum[0];
    if (C.sum[0] >= mod)C.sum[0] -= mod;
    C.sum[1] = A.sum[1] + B.sum[1];
    if (C.sum[1] >= mod)C.sum[1] -= mod;
    C.sum[1] += A.sum[0] * B.sum[0] % mod;
    if (C.sum[1] >= mod)C.sum[1] -= mod;
    return C;
}
struct Segment_Tree
{
    tnode t[4 * MAXN];
    void init_lazy(int root)
    {
        t[root].lazy[0] = 1;
        t[root].lazy[1] = 0;
    }
    void union_lazy(int fa, int ch)
    {
        long long temp[2];
        temp[0] = t[fa].lazy[0] * t[ch].lazy[0] % mod;
        temp[1] = ((t[fa].lazy[0] * t[ch].lazy[1] % mod) + t[fa].lazy[1]) % mod;
        t[ch].lazy[0] = temp[0];
        t[ch].lazy[1] = temp[1];
    }
    void cal_lazy(int root)
    {
        long long len = (t[root].r - t[root].l + 1) % mod;
        t[root].sum[1] = (len * (len - 1) / 2 % mod * t[root].lazy[1] % mod * t[root].lazy[1] % mod + t[root].lazy[0] * t[root].lazy[0] % mod * t[root].sum[1] % mod + t[root].lazy[0] * t[root].lazy[1] % mod * (len - 1) % mod * t[root].sum[0] % mod) % mod;
        t[root].sum[0] = (len * t[root].lazy[1] % mod + t[root].lazy[0] * t[root].sum[0] % mod) % mod;
        return;
    }
    void push_down(int root)
    {
        if (t[root].lazy[0] != 1 || t[root].lazy[1] != 0)
        {
            cal_lazy(root);
            if (t[root].l != t[root].r)
            {
                int ch = root << 1;
                union_lazy(root, ch);
                union_lazy(root, ch + 1);
            }
            init_lazy(root);
        }
    }
    void update (int root)
    {
        int ch = root << 1;
        push_down(ch);
        push_down(ch + 1);
        t[root] = t[ch] + t[ch + 1];
    }
    void build(int root, int l, int r)
    {
        t[root].l = l;
        t[root].r = r;
        init_lazy(root);
        if (l != r)
        {
            int mid = (l + r) >> 1;
            int ch = root << 1;
            build(ch, l, mid);
            build(ch + 1, mid + 1, r);
            update(root);
        }
        else
        {
            t[root].sum[0] = A[l] % mod;
            t[root].sum[1] = 0;
        }
    }
    void change(int root, int l, int r, long long delta, int op)
    {
        push_down(root);
        if (l == t[root].l && r == t[root].r)
        {
            t[root].lazy[op] = delta % mod;
            return;
        }
        int mid = (t[root].l + t[root].r) >> 1;
        int ch = root << 1;
        if (r <= mid)change(ch, l, r, delta, op);
        else if (l > mid)change(ch + 1, l, r, delta, op);
        else 
        {
            change(ch, l, mid, delta, op);
            change(ch + 1, mid + 1, r, delta, op);
        }
        update(root);
    }
    tnode sum(int root, int l, int r)
    {
        push_down(root);
        if (t[root].l == l && t[root].r == r)
        {
            return t[root];
        }
        int mid = (t[root].l + t[root].r) >> 1;
        int ch = root << 1;
        if (r <= mid)return sum(ch, l, r);
        else if (l > mid)return sum(ch + 1, l, r);
        else return sum(ch, l, mid) + sum(ch + 1, mid + 1, r);
    }
};
```

#### 带修改的动态规划DDP

本质是线段树维护 $Floyd$ 的矩阵乘法

> 如图所示, 在某个地方有两座层数为 $N$  的高塔, 两座高塔的内部各自有连接到上一层的楼梯, 即每座塔的第 $i$ 层可以直接上楼梯到第 $i + 1$ 层. 
>
> 同时, 在两座高塔之间还会存在一些连接两座高塔的楼梯, 具体来说, 除了顶层以外, 每一层都是以下这两种情况之一
>
> 1. 左侧高塔的第$i$ 层有楼梯连接右侧高塔的第 $i + 1$ 层
> 2. 右侧高塔的第 $i$ 层有楼梯连接左侧高塔的第 $i + 1$ 层
>
> 假设第 $i$ 层塔左侧楼梯、第 $i$ 层塔右侧楼梯、第 $i$ 层两座塔之间的楼梯, 其高度分别为 $val_{i0}$ , $val_{i1}$ , $val_{i2}$ 
>
> 楼梯的高度在这个问题中可能会随时被修改, 同时, 塔的结构也有可能改变, 也就是说除了顶层以外, 每一层都有可能从第 $1$ 种情况变成第 $2$ 种情况, 我们用字符 `/` 表示第 $1$ 种情况, 用字符 `\` 表示第 $2$ 种情况
>
> 现在询问从某座高塔的第 $hs$ 层移动到 $ht$ 层 $(hs < ht)$ , 在只能走楼梯上楼的情况下, 移动的最短路是多少?

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAX_MAT = 2;
const long long mod = 1e9 + 7;
const long long INF = 1LL << 61;
const int MAXN = 100005;
char s[MAXN];
long long val[MAXN][3];
struct Mat
{
    long long a[MAX_MAT][MAX_MAT];
    Mat()
    {
        for (int i = 0; i < MAX_MAT; ++i)
        {
            for (int j = 0; j < MAX_MAT; ++j)
            {
                a[i][j] = INF;
            }
        }
        for (int i = 0; i < MAX_MAT; ++i)
        {
            a[i][i] = 0;
        }
    }
    Mat(long long a1, long long a2, long long a3, long long a4)
    {
        a[0][0] = a1;
        a[0][1] = a2;
        a[1][0] = a3;
        a[1][1] = a4;
    }
};
Mat operator * (Mat x, Mat y)
{
    Mat c;
    for (int i = 0; i < MAX_MAT; ++i) {
        for (int j = 0; j < MAX_MAT; ++j) {
            c.a[i][j] = INF;
        }
    }
    for (int i = 0; i < MAX_MAT; ++i) {
        for (int j = 0; j < MAX_MAT; ++j) {
            for (int k = 0; k < MAX_MAT; ++k) {
                c.a[i][j] = min(c.a[i][j], x.a[i][k] + y.a[k][j]);
            }
        }
    }
    return c;
}
Mat make_dp_mat(int x)
{
    if(s[x]=='/')
    {
        return Mat(val[x][0],val[x][2],INF,val[x][1]);
    }
    else
    {
        return Mat(val[x][0],INF,val[x][2],val[x][1]);
    }
}
struct tnode
{
    Mat mat;
    int l, r;
};
struct Segment_Tree
{
    tnode t[4 * MAXN];
    int pos[MAXN];
    void update (int root)
    {
        int ch = root << 1;
        t[root].mat = t[ch].mat * t[ch + 1].mat;
    }
    void build(int root, int l, int r)
    {
        t[root].l = l;
        t[root].r = r;
        if (l != r)
        {
            int mid = (l + r) >> 1;
            int ch = root << 1;
            build(ch, l, mid);
            build(ch + 1, mid + 1, r);
            update(root);
        }
        else
        {
            t[root].mat = make_dp_mat(l);
            pos[l] = root;
        }
    }
    void change(int x)
    {
        int root = pos[x];
        t[root].mat=make_dp_mat(x);
        while (root >>= 1)update(root);
    }
    Mat query(int root, int l, int r)
    {
        if (t[root].l == l && t[root].r == r)
        {
            return t[root].mat;
        }
        int mid = (t[root].l + t[root].r) >> 1;
        int ch = root << 1;
        if (r <= mid)return query(ch, l, r);
        else if (l > mid)return query(ch + 1, l, r);
        else return query(ch, l, mid) * query(ch + 1, mid + 1, r);
    }
};
Segment_Tree ST;
int n, m, hs, ht, ps, pt, op, x;
char c[5];
int main()
{
    scanf("%d %d", &n, &m);
    scanf("%s", s + 1);
    for(int i=1;i<n;++i)
    {
        scanf("%lld %lld %lld",&val[i][0],&val[i][1],&val[i][2]);
    }
    ST.build(1, 1, n - 1);
    while (m--)
    {
        scanf("%d", &op);
        if (op == 2)
        {
            scanf("%d %d %d %d", &hs, &ht, &ps, &pt);
            long long ans=ST.query(1, hs, ht - 1).a[ps][pt];
            if(ans==INF)ans=-1;
            printf("%lld\n", ans);
        }
        else 
        {
            if(op==0)
            {
                scanf("%d %s", &x, c);
                s[x]=*c;
            }
            else
            {
                scanf("%d",&x);
                scanf("%lld %lld %lld",&val[x][0],&val[x][1],&val[x][2]);
            }
            ST.change(x);
        }
    }
    return 0;
}
```

<br>

### 势能线段树、李超线段树

#### 势能

+ 势能是存储于一个系统内的能力, 也可以释放或转化为其他形式的能量. 势能是状态量, 又称作位能. 势能不是属于单独物体所具有的, 而是相互作用的物体所共有的
+ 在物理学中势能的定义如上所述, 在信息学中, 也会引入一些物理概念来类比
+ 物理学中引入势能的目的是为了忽略复杂过程的影响
+ 信息学中引入势能的根本目的是相同的
+ 一个简单问题: 两个小于 $C$ 的数字求最大公约数 $gcd$ , 时间复杂度是 $O(\log C)$ , 对于 $N$ 个数求最大公约数是多少?
+ 答案是 $O(N + \log C)$ 
+ 原因在于, 我们在计算 $N$ 个数的 $gcd$ 时, 首先令 $ans = a[1]$ 
+ 然后顺次遍历整个数组, 每次令 $ans = gcd(ans, a[i])$ 
+ $ans$ 在这个过程中只会单调的往下减少, 不会上升
+ 在信息学中, 势能被用于计算某一个过程, 或者某一类过程时间复杂度的总和
+ 例如在求解 $gcd$ 的例子中, 就可以定义整个 $gcd$ 函数被调用的总势能为 $C$ . 这个势能只会单调减少, 并且减少的次数是 $\log C$ 次
+ 这个时间复杂度显然就是
+ 总时间复杂度 = 数组循环遍历复杂度 + $gcd$ 函数被调用的总复杂度

#### 势能均摊复杂度

+ 势能均摊复杂度是指把总的时间复杂度摊到操作次数或者循环次数上面

+ 这样做的原因是对于一个循环嵌套结构

  ```c++
  for(i = 1 ... N)
  {
      f(x) ...
  }
  ```

+ 我们比起用 $O($总复杂度$) = \sum O(f)$ 这种和式的表示方式

+ 更喜欢用 $O($总复杂度$) = N * O(f)$ 这种嵌套乘法原理的形式

+ 有了势能均摊这个概念以后, 会使得一些复杂度分系变得简单得多

+ 比如, 用线段树维护区间 $gcd$ , 时间复杂度是 $O(n \log n)$ 

+ 当使用"势能均摊"时, 就必须保证函数调用是均匀的, 或者整个函数的调用状态是不可重现的

#### 势能线段树

+ 所谓势能线段树, 是指在懒标记无法正常使用的情况下, 暴力到叶子将线段树当成数组一样用进行修改
+ 这个时候的复杂度计算就不是很直观了, 所以引入势能的概念
+ 每一个节点都有一个关于开根号操作的"势能", 然后开根号的时候势能一定是递减的
+ 注意引入势能分析是忽略过程, 只考虑所有过程的总和
+ 即我们不管在一次暴力中到底一个树节点被访问了几次(单次操作的时间复杂度可能很大, 可能是 $O(N)$) 但是这些暴力的总量是势能上限
+ 对于带修改的问题, 如果势能不是单调减少的, 那么就必须确保每次对于势能提高的上限不能太大

对于势能线段树, 假设线段树的节点数为 $N$ , 操作数目为 $M$ , 则势能线段树的总时间复杂度为

$O(M \times |0$势能时线段树操作时间复杂度$| + N \times |$节点势能上限降低至$0$势能时间复杂度$|)$

若势能可被某种操作重置或增加, 则必须考虑最坏情况下能提供操作总数 $M * |$单次操作重置势能的节点总数$| * |$节点势能上限$|$ 的时间复杂度, 则势能线段树的总时间复杂度为

$O(M \times |0$势能时线段树操作时间复杂度$| + N \times |$节点势能上限降低至$0$势能时间复杂度$|$$ + \ M \times |$线段树单次操作影响到的节点数目$| \times |$操作额外提供的势能$|)$

> 给你一个长度大小为 $N$ 的正整数数组, 进行 $M$ 次操作, 操作有下列两种
>
> 1. 给定区间 $[l, r]$ 对区间中所有数字开根号向下取整, 即 $a_i = |\sqrt{a_i}|(l \le i \le r)$ 
> 2. 查询给定区间 $[l, r]$ 的元素和, 即求 $\sum_{i = l}^{r} a_i$ 
>
> 本题中有两种可以定义势能与 $0$ 势能的方法:
>
> 1. 定义区间开根次数 $cnt$ 为势能, 势能初始值为势能上限 $= 6$ , 定义 $0$ 势能点为 $cnt = 0$ 
> 2. 定义区间最大值 $max$ 为势能, 势能初始值为区间最大值, 定义 $0$ 势能点为 $max = 1$ 

> 给你一个长度大小为 $N$ 的正整数数组, 进行 $M$ 次操作, 操作有下列三种
>
> 1. 给定区间 $[l, r]$ 对区间中所有数字开根号向下取整, 即 $a_i = |\sqrt{a_i}|(l \le i \le r)$ 
> 2. 给定区间 $[l, r]$ , 对区间中每个数字加上一个正整数 $x$ 
> 3. 查询给定区间 $[l, r]$ 的元素和, 即求 $\sum_{i = l}^{r} a_i$ 
>
> 本题中有两种可以定义势能与 $0$ 势能的方法:
>
> 1. 定义区间开根次数 $cnt$ 为势能, 势能初始值为势能上限 $= 6$ , 定义 $0$ 势能点为 $cnt = 0$ , 但是此方法重置势能比较困难
> 2. 定义区间最大值 $max$ 与区间最小值 $min$ 的差值 $diff$ 为势能, 势能初始值为差值 $diff$ , 定义 $0$ 势能点为 $diff = 0$ 

```c++
struct tnode
{
    long long sum,max,min,lazy;
    int l,r;
};
struct Segment_Tree
{
    tnode t[4*MAXN];
    void lazy_union(int fa,int ch)
    {
        if(t[fa].lazy)
        {
            t[ch].lazy+=t[fa].lazy;
        }
    }
    long long ssqrt(long long x)
    {
        return sqrt(x+0.5);
    }
    long long cal_dalta(long long x)
    {
        return x-ssqrt(x);
    }
    void cal_lazy(int root)
    {
        if(t[root].lazy)
        {
            t[root].sum+=t[root].lazy*(t[root].r-t[root].l+1);
            t[root].max+=t[root].lazy;
            t[root].min+=t[root].lazy;
        }
    }
    void init_lazy(int root)
    {
        t[root].lazy=0;
    }
    void pushdown(int root)
    {
        if(t[root].lazy)
        {
            cal_lazy(root);
            if(t[root].l!=t[root].r)
            {
                int ch=root<<1;
                lazy_union(root,ch);
                lazy_union(root,ch+1);
            }
            init_lazy(root);
        }
    }
    void update (int root)
    {
        int ch=root<<1;
        pushdown(ch);
        pushdown(ch+1);
        t[root].sum=t[ch].sum+t[ch+1].sum;
        t[root].max=max(t[ch].max,t[ch+1].max);
        t[root].min=min(t[ch].min,t[ch+1].min);
    }
    void build(int root,int l,int r,int *A)
    {
        t[root].l=l;
        t[root].r=r;
        if(l!=r)
        {
            int mid=(l+r)>>1;
            int ch=root<<1;
            build(ch,l,mid,A);
            build(ch+1,mid+1,r,A);
            update(root);
        }
        else
        {
            t[root].sum=A[l];
            t[root].min=A[l];
            t[root].max=A[l];
        }
    }
    void add(int root,int l,int r,long long delta)
    {
        pushdown(root);
        int mid=(t[root].l+t[root].r)>>1;
        int ch=root<<1;
        if(l==t[root].l&&r==t[root].r)
        {
            t[root].lazy+=delta;
            return;
        }
        if(r<=mid)add(ch,l,r,delta);
        else if(l>mid)add(ch+1,l,r,delta);
        else {add(ch,l,mid,delta);add(ch+1,mid+1,r,delta);}
        update(root);
    }
    void do_sqrt(int root,int l,int r)
    {
        pushdown(root);
        int mid=(t[root].l+t[root].r)>>1;
        int ch=root<<1;
        if(l==t[root].l&&r==t[root].r)
        {
            if(cal_dalta(t[root].max)==cal_dalta(t[root].min))
            {
                t[root].lazy-=cal_dalta(t[root].max);
                return;
            }
            do_sqrt(ch,l,mid);
            do_sqrt(ch+1,mid+1,r);
            update(root);
            return;
        }
        if(r<=mid)do_sqrt(ch,l,r);
        else if(l>mid)do_sqrt(ch+1,l,r);
        else {do_sqrt(ch,l,mid);do_sqrt(ch+1,mid+1,r);}
        update(root);
    }
    long long sum(int root,int l,int r)
    {
        pushdown(root);
        if(t[root].l==l&&t[root].r==r)
        {
            return t[root].sum;
        }
        int mid=(t[root].l+t[root].r)>>1;
        int ch=root<<1;
        if(r<=mid)return sum(ch,l,r);
        else if(l>mid)return sum(ch+1,l,r);
        else return sum(ch,l,mid)+sum(ch+1,mid+1,r);
    }
};
```

#### 李超线段树

+ 李超线段树是一种维护空间一次函数的结构
+ 定义线段树中的一个节点 $l$ ~ $r$ 所表示的区间为一个空间"域"的话
+ 定义最优势直线为整个区间自上而下覆盖范围最广的直线
+ 线段树中存储的信息, 实际上是每个空间"域"内最优势的一次函数
+ 从本质上来讲, 李超线段树是一种标记永久化的线段树
+ 它每次推标记的时候都会二分向左或者向右, 不会同时向两边推标记, 这就使得它可以暴力推标记推到叶子节点
+ 李超线段树也是网络比赛中的"利器", 因为传统的单调栈查询最优一次函数是有限制条件的, 即要么斜率单调, 要么查询点单调, 如果两个都不单调, 就必须借助CDQ分治或者直接使用李超树
+ 在能贴板子的情况下, 有的时候不用太想清楚单调的问题
+ 不过注意常数问题, 现场比赛中, 在抄模板有时间消耗代价, 并且有可能复杂度多个 $log$ 过不去的情况下, 要选取合适的数据结构

> 平面空间中有若干条直线, 每条直线的方程可以写作 $y = k_i \times x + b_i$ , 现在有两种操作
>
> 1. 插入一条方程为 $y' = k_i \times x' + b_i$ 的直线
> 2. 给定一个正整数 $x$ , $x \in [1, N]$ , 查询现在所有直线中令 $x = x'$ 时, $y'$ 的最大值和最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1000005;
struct Lin
{
    long long k,b;
    long long val(long long x)
    {
        return k*x+b;
    }
    Lin(long long _k=0,long long _b=0)
    {
        k=_k;
        b=_b;
    }
};
double Lin_cross_x(const Lin&A,const Lin&B)
{
    return (B.b-A.b)*1.0/(A.k-B.k);
}
const long long INF=(long long)1e18;
struct LiChao_Segmenttree
{
    long long cross_x(const Lin&A,const Lin&B)
    {
        return (B.b-A.b)/(A.k-B.k);
    }
    struct tree_node
    {
        int l,r;
        bool vis;
        bool has_lin;
        Lin lin;
    }t[4*MAXN];
    void build(int l,int r,int root=1)
    {
        t[root].l=l;
        t[root].r=r;
        t[root].vis=false;
        t[root].has_lin=false;
        if(l!=r)
        {
            int mid=(l+r)>>1;
            int ch=root<<1;
            build(l,mid,ch);
            build(mid+1,r,ch+1);
        }
    }
    void insert(Lin x,int l,int r,int root=1)
    {
        t[root].vis=true;
        if(l==t[root].l&&r==t[root].r)
        {
            if(!t[root].has_lin)
            {
                t[root].has_lin=true;
                t[root].lin=x;
                return;
            }
            if(t[root].lin.val(t[root].l)>=x.val(t[root].l)
               &&t[root].lin.val(t[root].r)>=x.val(t[root].r))
            {
                return;
            }
            if(t[root].lin.val(t[root].l)<x.val(t[root].l)
               &&t[root].lin.val(t[root].r)<x.val(t[root].r))
            {
                t[root].lin=x;
                return;
            }
            int mid=(t[root].l+t[root].r)>>1;
            int ch=root<<1;
            if(cross_x(x,t[root].lin)<=mid)
            {
                if(x.k<t[root].lin.k)
                {
                    insert(x,l,mid,ch);
                }
                else
                {
                    insert(t[root].lin,l,mid,ch);
                    t[root].lin=x;
                }
            }
            else
            {
                if(x.k>t[root].lin.k)
                {
                    insert(x,mid+1,r,ch+1);
                }
                else
                {
                    insert(t[root].lin,mid+1,r,ch+1);
                    t[root].lin=x;
                }
            }
        }
        else
        {
            int mid=(t[root].l+t[root].r)>>1;
            int ch=root<<1;
            if(r<=mid)
            {
                insert(x,l,r,ch);
            }
            else if(l>mid)
            {
                insert(x,l,r,ch+1);
            }
            else
            {
                insert(x,l,mid,ch);
                insert(x,mid+1,r,ch+1);
            }
        }
        return;
    }
    void clear(int root=1)
    {
        t[root].vis=false;
        t[root].has_lin=false;
        if(t[root].l!=t[root].r)
        {
            int ch=root<<1;
            if(t[ch].vis)
            {
                clear(ch);
            }
            if(t[ch+1].vis)
            {
                clear(ch+1);
            }
        }
        return;
    }
    long long get_val(int x,int root=1)
    {
        if(!t[root].vis)return -INF;
        long long ret;
        if(!t[root].has_lin)
        {
            ret=-INF;
        }
        else
        {
            ret=t[root].lin.val(x);
        }
        if(t[root].l==t[root].r)return ret;
        int ch=root<<1;
        int mid=(t[root].l+t[root].r)>>1;
        if(x<=mid)
        {
            return max(ret,get_val(x,ch));
        }
        else
        {
            return max(ret,get_val(x,ch+1));
        }
    }
}seg_up,seg_down;
int n,m,op,k,b,x;
int main()
{
    scanf("%d %d",&n,&m);
    seg_up.build(1,n);
    seg_down.build(1,n);
    while(m--)
    {
        scanf("%d",&op);
        if(op==0)
        {
            scanf("%d %d",&k,&b);
            seg_up.insert(Lin(k,b),1,n);
            seg_down.insert(Lin(-k,-b),1,n);
        }
        else
        {
            scanf("%d",&x);
            printf("%lld %lld\n", seg_up.get_val(x),-seg_down.get_val(x));
        }
    }
    return 0;
}
```

> 要求在平面直角坐标系下维护两个操作:
>
> 1. 在平面上加入一条线段, 记第 $i$ 条被插入的线段的标号为 $i$ 
> 2. 给定一个数 $k$ , 查询与直线 $x = k$ 相交的线段中, 交点最靠上的线段的编号

```c++
#include<bits/stdc++.h>
using namespace std;
struct Lin
{
    double k, b;
    int id;
    double val(double x)
    {
        return k * x + b;
    }
    Lin(double _k = 0, double _b = 0, int _id = 0)
    {
        k = _k;
        b = _b;
        id = _id;
    }
};
const int MAXN = 100005;
const double EPS = 1e-7;
const double INF = 1e18;
struct LiChao_Segmenttree
{
    int dcmp(double x)
    {
        return x > EPS ? 1 : x < EPS ? -1 : 0;
    }
    double cross_x(const Lin&A, const Lin&B)
    {
        return (B.b - A.b) / (A.k - B.k);
    }
    struct tree_node
    {
        int l, r;
        bool vis;
        bool has_lin;
        Lin lin;
    } t[4 * MAXN];
    void build(int l, int r, int root = 1)
    {
        t[root].l = l;
        t[root].r = r;
        t[root].vis = false;
        t[root].has_lin = false;
        if (l != r)
        {
            int mid = (l + r) >> 1;
            int ch = root << 1;
            build(l, mid, ch);
            build(mid + 1, r, ch + 1);
        }
    }
    void insert(Lin x, int l, int r, int root = 1)
    {
        t[root].vis = true;
        if (l == t[root].l && r == t[root].r)
        {
            if (!t[root].has_lin)
            {
                t[root].has_lin = true;
                t[root].lin = x;
                return;
            }
            if (dcmp(t[root].lin.val(t[root].l) - x.val(t[root].l)) >= 0 
                && dcmp(t[root].lin.val(t[root].r) - x.val(t[root].r)) >= 0)
            {
                return;
            }
            if (dcmp(t[root].lin.val(t[root].l) - x.val(t[root].l)) < 0 
                && dcmp(t[root].lin.val(t[root].r) - x.val(t[root].r)) < 0)
            {
                t[root].lin = x;
                return;
            }
            int mid = (t[root].l + t[root].r) >> 1;
            int ch = root << 1;
            if (dcmp(cross_x(x, t[root].lin) - mid) <= 0)
            {
                if (x.k < t[root].lin.k)
                {
                    insert(x, l, mid, ch);
                }
                else
                {
                    insert(t[root].lin, l, mid, ch);
                    t[root].lin = x;
                }
            }
            else
            {
                if (x.k > t[root].lin.k)
                {
                    insert(x, mid + 1, r, ch + 1);
                }
                else
                {
                    insert(t[root].lin, mid + 1, r, ch + 1);
                    t[root].lin = x;
                }
            }
        }
        else
        {
            int mid = (t[root].l + t[root].r) >> 1;
            int ch = root << 1;
            if (r <= mid)
            {
                insert(x, l, r, ch);
            }
            else if (l > mid)
            {
                insert(x, l, r, ch + 1);
            }
            else
            {
                insert(x, l, mid, ch);
                insert(x, mid + 1, r, ch + 1);
            }
        }
    }
    void clear(int root = 1)
    {
        t[root].vis = false;
        t[root].has_lin = false;
        if (t[root].l != t[root].r)
        {
            int ch = root << 1;
            if (t[ch].vis)
            {
                clear(ch);
            }
            if (t[ch + 1].vis)
            {
                clear(ch + 1);
            }
        }
        return;
    }
    pair<double, int> get_val(int x, int root = 1)
    {
        if (!t[root].vis)return make_pair(-INF, 0);
        pair<double, int> ret;
        if (!t[root].has_lin)
        {
            ret = make_pair(-INF, 0);
        }
        else
        {
            ret = make_pair(t[root].lin.val(x), t[root].lin.id);
        }
        if (t[root].l == t[root].r)return ret;
        int ch = root << 1;
        int mid = (t[root].l + t[root].r) >> 1;
        if (x <= mid)
        {
            return max(ret, get_val(x, ch));
        }
        else
        {
            return max(ret, get_val(x, ch + 1));
        }
    }
} seg;
const int mod1 = 39989;
const int mod2 = 1e9;
int n, x_1, y_1, x_2, y_2, op, ans, x, id;
double k, b;
int main()
{
    seg.build(1, mod1);
    scanf("%d", &n);
    while (n--)
    {
        scanf("%d", &op);
        if (op)
        {
            scanf("%d %d %d %d", &x_1, &y_1, &x_2, &y_2);
            x_1 = (x_1 + ans - 1) % mod1 + 1;
            x_2 = (x_2 + ans - 1) % mod1 + 1;
            y_1 = (y_1 + ans - 1) % mod2 + 1;
            y_2 = (y_2 + ans - 1) % mod2 + 1;
            if (x_1 > x_2)
            {
                swap(x_1, x_2);
                swap(y_1, y_2);
            }
            if (x_2 == x_1)k = 0;
            else k = 1.0 * (y_2 - y_1) / (x_2 - x_1);
            b = -k * x_1 + y_1;
            seg.insert(Lin(k, b, ++id), x_1, x_2);
        }
        else
        {
            scanf("%d", &x);
            x = (x + ans - 1) % mod1 + 1;
            ans = seg.get_val(x).second;
            printf("%d\n", ans);
        }
    }
    return 0;
}
```

<br>

### 伸展树

#### splay

+ 将某个节点通过旋转直接一路提到根的操作就称"伸展"操作
+ 伸展树在所有操作后, 都会执行这个 $splay$ 操作将它提到根
+ 写起来都要写成这种 $root = ×××$ 的形式, 比如说 `root = insert(x)` 
+ 基于 `splay` , 可以写出一些关键操作, 比如说
  + `insert()` 
  + `find()` 
  + `delete()` 
  + `kth()` $\quad$ 索引的第 $k$ 个
  + `lower_bound()` 
  + `upper_bound()` 
  + `merge/link()` 
  + `split/cut()` 
+ 伸展树维护区间的特长
  + 区间拼接
  + 区间翻转
  + 区间大段插入

```c++
int stot, stop, sstk[MAXN], n, root1, root2, root3, root, number[MAXN], tail;
struct tree
{
    int ch[2];
    int fa;
    int size;
    int cnt;
    int num;
    bool rev;
}t[MAXN];
//更新节点root的size属性,表示以root为根节点的子树的节点总数
void update(int root)
{
    t[root].size = t[root].cnt + t[t[root].ch[0]].size + t[t[root].ch[1]].size;
}
//将节点root的标记向下传递,即将root的翻转标记应用到其子节点
void pushdown(int root)
{
    if(t[root].rev)
    {
        swap(t[root].ch[0], t[root].ch[1]);
        t[root].rev ^= 1;
        t[t[root].ch[0]].rev ^= 1;
        t[t[root].ch[1]].rev ^= 1;
    }
    return;
}
//将从root到根节点路径上的所有节点都进行pushdown操作,确保在对树进行操作之前,没有延迟的标记
void push_until(int root)
{
    while(root)
    {
        sstk[++stop] = root;
        root = t[root].fa;
    }
    while(stop)
    {
        pushdown(sstk[stop--]);
    }
    return;
}
//对节点root进行一次旋转操作,旋转操作会改变root和其父节点、祖父节点的关系,以及子节点的位置
void rot(int root)
{
    int fa = t[root].fa;
    int gfa = t[fa].fa;
    int t1 = (root != t[fa].ch[0]);
    int t2 = (fa != t[gfa].ch[0]);
    int ch = t[root].ch[1^t1];
    t[root].fa = gfa;
    t[root].ch[1^t1] = fa;
    t[fa].ch[0^t1] = ch;
    t[fa].fa = root;
    t[ch].fa = fa;
    t[gfa].ch[0^t2] = root;
    update(fa);
    return;
}
//将节点root通过一系列的旋转操作,旋转到树的根节点位置,并返回旋转后的根节点
int splay(int root)
{
    push_until(root);
    while(t[root].fa)
    {
        int fa = t[root].fa, gfa = t[fa].fa;
        if(gfa)
        {
            (t[fa].ch[0] == root) ^ (t[gfa].ch[0] == fa) ? rot(root) : rot(fa);
        }
        rot(root);
    }
    update(root);
    return root;
}
//在以root为根的子树中,找到第k小的元素,并将其旋转到根节点位置,返回旋转后的根节点
int kth(int root, int k)
{
    for(;;)
    {
        pushdown(root);
        if(k <= t[t[root].ch[0]].size)
        {
            root = t[root].ch[0];
        }
        else if(k > t[t[root].ch[0]].size + t[root].cnt)
        {
            k -= t[t[root].ch[0]].size + t[root].cnt;
            root = t[root].ch[1];
        }
        else
        {
            return splay(root);
        }
    }
}
//向以root为根节点的子树中插入一个值为num的节点,如果已经存在值为num的节点,则增加其计数器,返回插入/旋转后的根节点
int ins(int root, int num)
{
    while(root && t[root].num != num && t[root].ch[num > t[root].num])
        root = t[root].ch[num > t[root].num];
    if(root && t[root].num == num)
    {
        t[root].cnt ++;
        return splay(root);
    }
    t[++stot].num = num;
    t[stot].cnt = t[stot].size = 1;
    t[stot].rev = 0;
    t[stot].fa = root;
    t[stot].ch[0] = t[stot].ch[1] = 0;
    t[root].ch[num > t[root].num] = stot;
    root = stot;
    return splay(root);
}
//将以root1和root2为根的两棵子树连接起来,并返回连接后的根节点
int links(int root1, int root2)
{
    if(!root1 || !root2) return root1 | root2;
    root1 = kth(root1, t[root1].size);
    t[root1].ch[1] = root2;
    t[root2].fa = root1;
    update(root1);
    return root1;
}
//将以root为根的子树切割成两个子树,k是切割的位置,root1和root2用于返回切割后的两个子树的根节点
void cuts(int root, int k, int &root1, int &root2)
{
    if(k == 0)
    {
        root1 = 0;
        root2 = root;
        return;
    }
    root1 = kth(root, k);
    root2 = t[root1].ch[1];
    t[root1].ch[1] = t[root2].fa = 0;
    update(root1);
    return;
}
int build(int l, int r)
{
    if(r < l) return 0;
    int mid = (l + r) >> 1;
    int new_node = ++stot;
    t[new_node].num = mid;
    t[new_node].cnt = 1;
    t[new_node].rev = 0;
    t[new_node].fa = 0;
    t[new_node].ch[0] = build(l, mid - 1);
    t[new_node].ch[1] = build(mid + 1, r);
    t[t[new_node].ch[0]].fa = new_node;
    t[t[new_node].ch[1]].fa = new_node;
    update(new_node);
    return new_node;
}
void dfs(int root)
{
    pushdown(root);
    if(t[root].ch[0])
    {
        dfs(t[root].ch[0]);
    }
    number[++tail] = t[root].num;
    if(t[root].ch[1])
    {
        dfs(t[root].ch[1]);
    }
    return;
}
void init()
{
    stot = 0;
    root = 0;
}
int main()
{
    //初始化 + 建树
    init();
    tail = 0;
    root = build(1, n);

    //将[l, r]区间翻转
    scanf("%d %d", &l, &r);
    cuts(root, l - 1, root1, root2);
    cuts(root2, r - l + 1, root2, root3);
    t[root2].rev ^= 1;
    root = links(root1, root2);
    root = links(root, root3);

    //树的中序遍历存储在number[]数组中
    dfs(root);
}
```

#### 树旋转与换根DP

+ 树旋转的本质是父子关系的改变, 实际上可以用一些 `link` `cut` 操作来达到这个效果
+ 就可以利用 `link` 和 `cut` 做一个类似多叉树旋转的换根DP

```c++
vector<int> G[MAXN];
int sz[MAXN], dp[MAXN], val[MAXN], n, u, v, ans[MAXN];

void dp_link(int root1, int root2)
{
    dp[root1] += max(dp[root2], 0);
}
void dp_cut(int root1, int root2)
{
    dp[root1] -= max(dp[root2], 0);
}
void get_leaf(int root)
{
    dp[root] = val[root] ? 1 : -1;
}

void change_root(int root1, int root2)
{
    dp_cut(root1, root2);
    dp_link(root2, root1);
}
void dp_dfs(int x, int fa)
{
    get_leaf(x);
    for(auto &i: G[x])
    {
        if(i != fa)
        {
            dp_dfs(i, x);
            dp_link(x, i);
        }
    }
    return;
}
void dfs(int x, int fa)
{
    ans[x] = dp[x];
    for(auto &i: G[x])
    {
        if(i != fa)
        {
            change_root(x, i);
            dfs(i, x);
            change_root(i, x);
        }
    }
    return;
}
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &val[i]);
    }
    for(int i = 1; i < n; i++)
    {
        scanf("%d %d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dp_dfs(1, -1);
    dfs(1, -1);
    //dp[i]表示取任意节点为整棵树的根节点时,以节点i为根的子树的最优解
    //ans[i]表示以节点i为根的整棵树的最优解
    for(int i = 1; i <= n; i++)
    {
        printf("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}
```

<br>

### 跳表、分块、莫队

#### 跳表和倍增

+ 跳表又叫 $ST$ 算法, 它的本质是一种倍增算法

+ 倍增是一种基于二进制待定系数的二分思路, 它在一定程度上比 $l$ , $r$ , $mid$ 的形式需要考虑的边界问题更少, 但是它的常数更大

+ 它其实比 $l$ , $r$ , $mid$ 的形式更好写, 只用写一行就写好了

+ ```c++
  int x = -1;
  for(int i = 16; ~i; --i) if(check(x + (1 << i))) x += (1 << i);
  ```

+ 倍增在树上更常见一点. 或者说, 在链式结构上更常见

+ 数组上可以用 $l$ , $r$ , $mid$ 这种形式的二分查找, 从本质上讲是因为数组在空间上是连续的

+ 而链表结构在空间上不连续, 所以没办法用这种形式二分

#### 跳表

+ 跳表是为了处理静态查询问题, 绝大部分问题都是动态的, 而且即使是静态查询问题, 跳表也不比线段树更有优势
+ 跳表真正的优势在于, 预处理时间和查询时间的不对等 (预处理$O(N \log N)$ , 查询$O(1)$)
+ 比如数据量只有 $1e5$ , 而查询数达到了 $1e7$ 并且强制在线, 这时候跳表以绝对优势暴打了绝大部分算法
+ 跳表一共有两种
  1. 步长为根号的根号跳表
  2. 步长为二进制倍增的倍增跳表
+ 对于 $RMQ$ (区间查询极大/小值) 问题
+ 给定一个长度大小为 $N$ 的数组, 进行若干次查询
  + 如果这个"若干次" $= N$ , 那它可能打不过线段树或者和线段树打平
  + 如果这个"若干次" $= 10N$ , 那么倍增跳表将有很大优势
  + 如果这个"若干次" $= 100N$ , 那么根号跳表开始具有优势

#### 根号跳表

+ 根号跳表是这样实现的
+ 先开一个叫做 $ST\_small[N][sqrt(N)]$ 的二维数组
+ $ST\_small[i][j]$ 表示以 $i$ 为起点, 向后延伸长度为 $j$ 的区间信息
+ 接下来开一个叫做 $ST\_big[N][sqrt(N)]$ 的二维数组
+ $ST\_big[i][j]$ 表示以 $i$ 为起点, 向后延伸长度为 $j * sqrt(N)$ 的区间信息
+ 显然, $ST\_big[i][1] = ST\_small[i][sqrt(N)]$ 
+ 对于任意一段查询 $max \{l, r\}$ 
+ 转化为 $max(ST\_big[l][len / sqrt(N)], ST\_small[l + len / sqrt(N) * sqrt(N)][len - len / sqrt(N) * sqrt(N)])$​ 
+ 这是一种 $O(1)$ 的查询
+ $sqrt(N)$ 一般用 `int block = sqrt(N)` 声明

```c++
const int N, block = sqrt(N);
int ST_small[N][block], ST_big[N][block];

for(int i = 1; i <= n; i++)
    for(int j = 1; j <= block; j++)
        ST_small[i][j] = max(ST_small[i][j - 1], a[i + j - 1]);
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= block; j++)
        ST_big[i][j] = max(ST_big[i][j - 1], ST_small[i + (j - 1) * block][block]);

//查询区间[l, r]极值
int len = r - l + 1;
int ans = max(ST_big[l][len / block], ST_small[l + len / block * block][len - len / block * block]);
```

+ 根号跳表还有一个经典的例子就是 **光速幂**
  + 设底数为 $a$ , 指数为 $b$ , 模数为 $mod$ 
  + 主要思想就是分块, 预处理出 $a^1, a^2, a^3, \cdots, a^{\sqrt{n}}$ 和 $a^{\sqrt{n}}, a^{2\sqrt{n}}, a^{3\sqrt{n}}, \cdots, a^n$ 
  + $O(\sqrt{n})$ 预处理, $O(1)$ 查询

```c++
struct Lightspeed_Pow
{
    int ST_small[N], ST_big[N];
    int block;
    int maxn = 1e12; //最大的可能指数
    void init(int x) //传入底数a, O(sqrt(n))预处理
    {
        block = sqrt(maxn) + 1;
        ST_small[0] = 1;
        for(int i = 1; i <= block; i++)
            ST_small[i] = ST_small[i - 1] * x % mod;
        ST_big[0] = 1;
        for(int i = 1; i <= block; i++)
            ST_big[i] = ST_big[i - 1] * ST_small[block] % mod;
    }
    int calc(int x) //传入指数b, O(1)查询
    {
        return ST_big[x / block] * ST_small[x % block] % mod;
    }
}pw;
```

#### 倍增跳表

+ 如果是朴素的查询RMQ, 或者其他可重复合并信息, 如区间 `max` `min` `gcd` , 也就是多次重复合并不影响结果的情况下, 倍增跳表具有优势

+ 倍增跳表是这样被定义的, 首先开一个叫做 $ST[N][log(N)]$ 的数组

+ `ST[i][j]` 表示以 $i$ 为起点, 向后延伸 $2^j$ 的区间信息

+ 显然存在 $dp$ 转移方程

+ `ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1])`

+ 查询的时候, `k = log(r - l + 1)` , `ans = max(ST[l][k], ST[r - (1 << k) + 1][k])` 

+ 这里的 `log2` 不要调用系统函数, 在处理整数问题上, $pow$ , $log$ , $sqrt$ 等函数都有精度问题和时间常数问题

+ 可以暴力跑一个预处理 $log$ 

+ ```c++
  LG2[1] = 0;
  for(int i = 2; i < N; i++) LG[i] = LG[i / 2] + 1;
  ```

```c++
int a[MAXN], ST_max[MAXN][16], ST_min[MAXN][16], l, r;
void Sparse_Table()
{
    for(int i = 1; i <= n; i++)
    {
        ST_max[i][0] = ST_min[i][0] = a[i];
    }
    for(int j = 1; (1 << j) <= n; j++)
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
        {
            ST_max[i][j] = max(ST_max[i][j - 1], ST_max[i + (1 << (j - 1))][j - 1]);
            ST_min[i][j] = min(ST_min[i][j - 1], ST_min[i + (1 << (j - 1))][j - 1]);
        }
}
int RMQ(int l, int r)
{
    int k;
    for(k = 0; (1 << (k + 1)) <= r - l + 1; k++);
    int maxnum = max(ST_max[l][k], ST_max[r - (1 << k) + 1][k]);
    int minnum = min(ST_min[l][k], ST_min[r - (1 << k) + 1][k]);
    return maxnum - minnum;
}
```

#### 分块

+ 分块是一种比较优雅的暴力
+ 先把数组切成 $\sqrt{N} (+ 1)$ 段, 每段有不超过 $\sqrt{N}$ 个元素
+ 然后我们需要这样几个数组: $L[MAXBLOCK]$ , $R[MAXBLOCK]$ , $cnt[MAXBLOCK]$ , $belong[MAXN]$ 
+ $LR$ 表示块的左右边界, $cnt$ 表示一块内的元素数目, $belong[i]$ 表示数组的第 $i$ 个元素属于第几块
+ 查询: 碰到块的时候直接利用整段信息加速, 不然就暴力爬
  + 总的段的数量不超过 $\sqrt{N}$ , 暴力爬的两段内每段元素个数不超过 $\sqrt{N}$ , 这样做下来整个的时间复杂度是 $O(\sqrt{N})$ 的
+ 修改: 修改所覆盖到的区间, 对于整段而言, 可以像线段树使用 $lazytag$ 一样直接打标记, 对于两边一头一尾直接暴力

#### 莫队

```c++
//树上莫队
int a[MAXN], fa[MAXN], son[MAXN], n, x, y, m, deep[MAXN], top[MAXN], sz[MAXN], b[MAXN], dfn, L[MAXN], R[MAXN], ans[MAXN], cnt[MAXN], motot, nowans, block;
bool state[MAXN];
vector<int> G[MAXN];
void dfs1(int x, int dep, int father)
{
    sz[x] = 1;
    deep[x] = dep;
    fa[x] = father;
    for(int i = 0; i < G[x].size(); i++)
    {
        if(G[x][i] != father)
        {
            dfs1(G[x][i], dep + 1, x);
            sz[x] += sz[G[x][i]];
            if(!son[x] || sz[son[x]] < sz[G[x][i]]) 
                son[x] = G[x][i];
        }
    }
}
void dfs2(int x, int tp)
{
    b[++dfn] = x;
    L[x] = dfn;
    top[x] = tp;
    if(son[x]) dfs2(son[x], tp);
    for(int i = 0; i < G[x].size(); i++)
    {
        if(G[x][i] != fa[x] && G[x][i] != son[x])
        {
            dfs2(G[x][i], G[x][i]);
        }
    }
    b[++dfn] = x;
    R[x] = dfn;
    return;
}
int lca(int x, int y)
{
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return deep[x] < deep[y] ? x : y;
}
struct query
{
    int l, r, ex, id;
}mo[MAXN];
bool cmp(query x, query y)
{
    if(x.l / block != y.l / block)
        return x.l / block < y.l < block;
    return x.r < y.r;
}
void work(int t_node)
{
    if(state[t_node])
    {
        -- cnt[a[t_node]];
        if(!cnt[a[t_node]]) -- nowans;
    }
    else
    {
        if(!cnt[a[t_node]]) ++ nowans;
        ++ cnt[a[t_node]];
    }
    state[t_node] ^= 1;
    return;
}
void MO()
{
    nowans = 0;
    int l = 1;
    int r = 1;
    work(b[1]);
    for(int i = 1; i <= motot; i++)
    {
        while(l > mo[i].l) work(b[--l]);
        while(l < mo[i].l) work(b[l++]);
        while(r > mo[i].r) work(b[r--]);
        while(r < mo[i].r) work(b[++r]);
        if(mo[i].ex)
        {
            work(mo[i].ex);
            ans[mo[i].id] = nowans;
            work(mo[i].ex);
        }
        else
        {
            ans[mo[i].id] = nowans;
        }
    }
    return;
}
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        G[i].clear();
    }
    for(int i = 0; i < n; i++)
    {
        scanf("%d %d", &x, &y);
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dfs1(1, 0, 0);
    dfs2(1, 1);
    block = sqrt(2 * n + 0.5);
    scanf("%d", &m);
    for(int i = 1; i <= m; i++)
    {
        scanf("%d %d", &x, &y);
        if(x == y)
        {
            ans[i] = 1;
        }
        else
        {
            if(L[x] > L[y]) swap(x, y);
            if(R[x] > R[y])
            {
                mo[++motot].l = L[x];
                mo[motot].r = L[y];
                mo[motot].ex = 0;
                mo[motot].id = i;
            }
            else
            {
                mo[++motot].l = R[x];
                mo[motot].r = L[y];
                mo[motot].ex = lca(x, y);
                mo[motot].id = i;
            }
        }
    }
    sort(mo + 1, mo + 1 + motot, cmp);
    MO();
    for(int i = 1; i <= m; i++)
        printf("%d%c", ans[i], i == m ? '\n' : ' ');
}
```

<div style="page-break-after:always;"></div>

# 数据结构的可持久化

### 可持久化线段树

```c++
//N = 4 * maxn + 2 * log2(maxn)

struct Persistent_Segment_Tree
{
    int lch[N], rch[N], tot; // 左孩子和右孩子数组，tot表示节点的数量
    int sum[N], lazy[N]; // sum数组用于存储节点的和，lazy数组用于存储懒惰标记
    void init()
    {
        tot = 0; // 初始化节点数量为0
    }
    inline void cpy(int from, int to)
    {
        lch[to] = lch[from]; // 复制左孩子
        rch[to] = rch[from]; // 复制右孩子
        sum[to] = sum[from]; // 复制和
        lazy[to] = lazy[from]; // 复制懒惰标记
    }
    void build(int &root, int l, int r)
    {
        root = ++ tot; // 新建一个节点，节点数量加1
        lazy[root] = 0; // 初始化懒惰标记为0
        if(l == r)
        {
            sum[root] = 0; // 叶节点的和为0
            return;
        }
        int mid = (l + r) >> 1; // 计算中点
        build(lch[root], l, mid); // 递归构建左子树
        build(rch[root], mid + 1, r); // 递归构建右子树
        sum[root] = sum[lch[root]] + sum[rch[root]]; // 计算当前节点的和
    }
    void change(int &root, int old, int L, int R, int l, int r, long long v)
    {
        root = ++ tot; // 新建一个节点，节点数量加1
        cpy(old, root); // 复制旧节点的信息到新节点
        sum[root] += v * (r - l + 1); // 更新当前节点的和
        if(l == L && r == R)
        {
            lazy[root] += v; // 更新当前节点的懒惰标记
            return;
        }
        int mid = (L + R) >> 1; // 计算中点
        if(r <= mid) change(lch[root], lch[root], L, mid, l, r, v); // 更新左子树
        else if(l > mid) change(rch[root], rch[root], mid + 1, R, l, r, v); // 更新右子树
        else
        {
            change(lch[root], lch[root], L, mid, l, mid, v); // 更新左子树的一部分
            change(rch[root], rch[root], mid + 1, R, mid + 1, r, v); // 更新右子树的一部分
        }
        return;
    }
    int qsum(int root, int L, int R, int l, int r)
    {
        if(l == L && r == R)
        {
            return sum[root]; // 返回当前节点的和
        }
        int ans = lazy[root] * (r - l + 1); // 计算当前节点的懒惰标记对应的值
        int mid = (L + R) >> 1; // 计算中点
        if(r <= mid) return ans + qsum(lch[root], L, mid, l, r); // 查询左子树
        else if(l > mid) return ans + qsum(rch[root], mid + 1, R, l, r); // 查询右子树
        else return ans + qsum(lch[root], L, mid, l , mid) + qsum(rch[root], mid + 1, R, mid + 1, r); // 查询左右子树的一部分
    }
    int q(int s, int t, int L, int R, int k)
    {
        if(L == R)
        {
            return L; // 返回叶节点的值
        }
        int mid = (L + R) >> 1; // 计算中点
        if(k <= sum[lch[t]] - sum[lch[s]]) // 如果k小于等于左子树的和
        {
            return q(lch[s], lch[t], L, mid, k); // 在左子树中查询
        }
        else
        {
            return q(rch[s], rch[t], mid + 1, R, k - (sum[lch[t]] - sum[lch[s]])); // 在右子树中查询
        }
    }
};

struct discretization_node
{
    int num;
    int ki;
} disc[MAXN];

// 比较函数，用于排序
bool cmp(discretization_node x, discretization_node y)
{
    return x.num < y.num;
}

// 离散化函数
void discretization(int a[], int inv[], int n, discretization_node disc[])
{
    // 初始化离散化节点数组
    for (int i = 1; i <= n; i++)
    {
        disc[i].num = a[i];
        disc[i].ki = i;
    }

    // 对离散化节点数组进行排序
    sort(disc + 1, disc + 1 + n, cmp);

    int cnt = 0, per;

    // 进行离散化
    for (int i = 1; i <= n; i++)
    {
        // 如果当前数字与前一个数字不相同，则计数器加一
        if (i == 1 || a[disc[i].ki] != per)
            ++cnt;

        per = a[disc[i].ki];
        a[disc[i].ki] = cnt;
        inv[cnt] = disc[i].num;
    }

    return;
}

Persistent_Segment_Tree seg;
int root[MAXN], T, n, m, l, r, t, k;
int a[MAXN], b[MAXN], v;

int main()
{
    while (scanf("%d %d", &n, &m) != EOF)
    {
        T = 0;

        // 读取输入数组 a
        for (int i = 1; i <= n; i++)
        {
            scanf("%d", &a[i]);
        }

        // 进行离散化
        discretization(a, b, n, disc);

        // 初始化持久化线段树
        seg.init();

        // 构建初始线段树
        seg.build(root[T], 1, n);

        // 逐个插入元素并构建持久化线段树
        for (int i = 1; i <= n; i++)
        {
            T++;
            seg.change(root[T], root[T - 1], 1, n, a[i], a[i], 1);
        }

        // 处理查询操作
        for (int i = 1; i <= m; i++)
        {
            scanf("%d %d %d", &l, &r, &k);

            // 在持久化线段树上查询第 k 小的元素，并输出对应的离散化前的值
            printf("%d\n", b[seg.q(root[l - 1], root[r], 1, n, k)]);
        }
    }
}
```

<div style="page-break-after:always;"></div>

# 统计类算法

### CDQ分治

+ CDQ分治的前身是"分治求逆序对", 换句话说, 整个算法来自于"归并排序"的扩展

+ CDQ分治擅长处理"偏序约束关系", 所以想要使用CDQ分治的话, 最核心的部分就是找约束关系或者将问题的限制条件转化为这种偏序约束条件
+ CDQ分治的应用
  + 分治求逆序对
  + 分治求最长上升子序列
  + 分治求线段覆盖
  + 分治求区间元素种类数
  + 分治求动态凸包
  + 分治求区间和 (单点修改)
  + 分治求区间和 (区间修改)
  + 分治求区间和 (区间加等差)

#### 分治求逆序对

需要满足的约束条件是: $$ \left\{\begin{matrix} 
  pos_i < pos_j \\  
  a_i > a_j
\end{matrix}\right. $$ , 满足条件后要做的操作是 $ans ++$ 

根据我们的预备知识, 所有的分治算法无外乎都是考虑, $f(l, r) = f(l, mid) + f(mid + 1, r) + val(l, r)$ 中的 $val(l, r)$ 这一部分. 其中 $val(l, r)$ 仅表示 $i$ 落在 $[l, mid]$ , $j$ 落在 $[mid + 1, r]$ 这些数对提供的答案. 其他贡献递归算法自动帮我们算好了, 所以仅需考虑一层

由于 $val(l, r)$ 仅表示 $i$ 落在 $[l, mid]$ , $j$ 落在 $[mid + 1, r]$ 的数对, 所以每当从右侧弹出数字的时候, 我们只要知道左侧已经弹出几个数字, 把他们加到最终答案中, $val(l, r)$ 就处理完了

如果记归并排序过程中左侧有序数组的指针为 $p_1$ 的话, 每当从右侧弹出数字时都计算贡献 $ans += p_1 - l$ , 逆序对就算完了

```c++
int n,a[MAXN],temp[MAXN];
long long ans;
void cdqDivAlgorithm(int l,int r){
    if(l==r)return;
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid);
    cdqDivAlgorithm(mid+1,r);
    int p1=l,pl=l,p2=mid+1;
    while(p1<=mid&&p2<=r){
        if(a[p1]>a[p2]){
            temp[pl++]=a[p1++];
        }else{
            temp[pl++]=a[p2++];
            ans+=p1-l;
        }
    }
    while(p1<=mid){
        temp[pl++]=a[p1++];
    }
    while(p2<=r){
        temp[pl++]=a[p2++];
        ans+=p1-l;
    }
    for(int i=l;i<=r;++i){
        a[i]=temp[i];
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);
    
    cdqDivAlgorithm(1,n);
    printf("%lld\n",ans);
}
```

#### 分治求最长上升子序列

题意: 给 $n$ 个数求 1、最长非上升子序列 2、最长严格上升子序列

对于第一问, 需要满足的约束条件是: $$ \left\{\begin{matrix} 
  pos_i < pos_j \\  
  a_i \ge a_j
\end{matrix}\right. $$ , 在满足约束条件的前提下进行状态转移 $dp[pos_j] = max(dp[pos_i] + 1, dp[pos_j])$ 

对于第二问, 需要满足的约束条件是: $$ \left\{\begin{matrix} 
  pos_i < pos_j \\  
  a_i < a_j
\end{matrix}\right. $$ , 在满足约束条件的前提下进行状态转移 $dp[pos_j] = max(dp[pos_i] + 1, dp[pos_j])$ 

分治算法只考虑 $i$ 落在 $[l, mid]$ , $j$ 落在 $[mid + 1, r]$ 的情况, 所以我们记录来自左子树 $dp$ 的最大值 (只用一个变量存储即可), 然后碰到来自右子树的节点就进行转移

**算法实现的难点**

由于是做动态规划, 所以还必须注意状态转移的阶段性

最长上升子序列的其中一种划分阶段的方法是按照下标递增的顺序进行划分求解

在处理上, 借助"中序遍历"的思路就可以一遍分治, 一遍满足状态转移的阶段性

但是"中序遍历"又不能满足归并排序(归并排序必须是后序遍历), 所以在实际处理上先进行一遍朴素的归并排序并记录过程, 然后模拟归并(已经排好了, 不需要真的再排一遍), 采取"中序遍历"的递归模式, 在过程中进行状态转移

```c++
int n,x,dp[MAXN],a[MAXN],ans;
pair<int,int>temp[MAXN][20];//<val,pos>
bool cmp(const pair<int,int> &A,const pair<int,int> &B,const int &type){
    return type?A.first!=B.first?A.first>B.first:A.second<B.second:A.first!=B.first?A.first<B.first:A.second>B.second;
}
void mergeSort(int l,int r,int deep,const int &cmptype){
    if(l==r){
        temp[l][deep].first=a[l];
        temp[l][deep].second=l;
        return;
    }
    int mid=(l+r)>>1;
    mergeSort(l,mid,deep+1,cmptype);
    mergeSort(mid+1,r,deep+1,cmptype);
    int p1=l,p2=mid+1;
    while(p1<=mid&&p2<=r){
        if(cmp(temp[p1][deep+1],temp[p2][deep+1],cmptype)){
            temp[l++][deep]=temp[p1++][deep+1];
        }else{
            temp[l++][deep]=temp[p2++][deep+1];
        }
    }
    while(p1<=mid){
        temp[l++][deep]=temp[p1++][deep+1];
    }
    while(p2<=r){
        temp[l++][deep]=temp[p2++][deep+1];
    }
}
void cdqDivAlgorithm(int l,int r,int deep,const int &cmptype){
    if(l==r){
        dp[l]=max(dp[l],1);
        ans=max(ans,dp[l]);
        return;
    }
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid,deep+1,cmptype);
    int p1=l,p2=mid+1,premax=0;
    while(p1<=mid&&p2<=r){
        if(cmp(temp[p1][deep+1],temp[p2][deep+1],cmptype)){
            premax=max(premax,dp[temp[p1++][deep+1].second]);
        }else{
            dp[temp[p2][deep+1].second]=max(premax+1,dp[temp[p2][deep+1].second]);
            p2++;
        }
    }
    while(p2<=r){
        dp[temp[p2][deep+1].second]=max(premax+1,dp[temp[p2][deep+1].second]);
        p2++;
    }
    cdqDivAlgorithm(mid+1,r,deep+1,cmptype);
}
int main()
{
    while(scanf("%d",&x)!=EOF)a[++n]=x;
    
    mergeSort(1,n,0,1);
    cdqDivAlgorithm(1,n,0,1);
    printf("%d\n",ans);
    
    memset(dp,0,sizeof(dp));
    ans=0;
    mergeSort(1,n,0,0);
    cdqDivAlgorithm(1,n,0,0);
    printf("%d\n",ans);
}
```

#### 分治求线段覆盖

题意: 求最多的相互之间没有交集的线段数量

需要满足的约束条件是: $r_i \le l_j$ , 在满足约束条件的前提下进行状态转移 $dp[j] = max(dp[i] + 1, dp[j])$ 

这个约束条件看着别扭, 所以我们稍微扩展一下变成 $$ \left\{\begin{matrix} 
  l_i \le l_j \\  
  r_i \le r_j
\end{matrix}\right. $$ . 其实这个 $l_i \le l_j$ 约束不起作用, 因为只要输入的线段合法, 当 $r_i \le l_j$ 满足时 $l_i \le l_j$ 也必定被满足

多扩展这个无用的约束条件有两点意义

1. 构造偏序约束条件
2. $l$ 有序实际上是做状态转移的阶段, 为了保证动态规划的阶段性所以引入 $l_i \le l_j$ 这个约束

**算法难点**

首先是 $r_i \le l_j$ 这个约束和之前不一样, 也就是到当前层的时候我们既需要 $l$ 有序, 有需要 $r$ 有序. 为了让左子树的 $r$ 有序, 右子树的 $l$ 有序. 一开始按照 $l$ 排序, 然后在中序遍历的时候进行状态转移

然后我们知道归并排序算法必须是"后序遍历", 所以在代码实现上, 我们中序处理状态转移, 后序处理归并排序

用CDQ处理复杂结构体时尽量不要封装, 频繁拷贝可能会导致大常数

```c++
int n,L[MAXN],R[MAXN],id[MAXN],dp[MAXN],ans;
int temp[MAXN];
void cdqDivAlgorithm(int l,int r){
    if(l==r){
        dp[id[l]]=max(1,dp[id[l]]);
        ans=max(ans,dp[id[l]]);
        return;
    }
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid);
    int p1=l,pl,p2=mid+1,premax=0;
    while(p1<=mid&&p2<=r){
        if(R[id[p1]]<=L[id[p2]]){
            premax=max(premax,dp[id[p1++]]);
        }else{
            dp[id[p2]]=max(premax+1,dp[id[p2]]);
            ++p2;
        }
    }
    while(p2<=r){
        dp[id[p2]]=max(premax+1,dp[id[p2]]);
        ++p2;
    }
    cdqDivAlgorithm(mid+1,r);
    p1=l,pl=l,p2=mid+1;
    while(p1<=mid&&p2<=r){
        if(R[id[p1]]<R[id[p2]]){
            temp[pl++]=id[p1++];
        }else{
            temp[pl++]=id[p2++];
        }
    }
    while(p1<=mid){
        temp[pl++]=id[p1++];
    }
    while(p2<=r){
        temp[pl++]=id[p2++];
    }
    for(int i=l;i<=r;++i){
        id[i]=temp[i];
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d %d",&L[i],&R[i]);
        id[i]=i;
    }
    
    sort(id+1,id+1+n,[](const int &A,const int &B){
            return L[A]<L[B];
         });
    cdqDivAlgorithm(1,n);
    printf("%d\n",ans);
}
```

#### 分治求区间元素种类数

题意: 给定长度大小为 $n$ 的数组和 $m$ 个询问, 每次询问一段区间 $[l, r]$ 内不同元素的种类数

乍一看别说偏序约束关系, 连一个约束条件都找不出来. 难点在于如何转化问题

我们记数组中第 $i$ 个位置上一次在数组中出现相同数字的位置为 $prepos_i$ , 如果不存在上一次出现相同数字的位置, 则记为 $-1$ 

这样就可以写出约束条件了, 问题转化成满足约束条件: $$ \left\{\begin{matrix} 
  prepos_i < l_j \\  
  l_j \le i \le r_j
\end{matrix}\right. $$ 时, 进行操作 $ans_j ++$ 

注意 $l_j \le i \le r_j$ 这个条件当然要拆分, 但是不要拆完了约束条件变为 $$ \left\{\begin{matrix} 
  prepos_i < l_j \\  
  l_j \le i \\
  i \le r_j
\end{matrix}\right. $$ 三元的约束条件

这样不是不能做, 而是最终做出来的算法复杂度是 $n \log^2 n$ 的

这个拆分可以借助前缀和的思想去拆分. $l_j \le i \le r_j$ 可以看成是, 满足 $i \le r_j$ 的数目减去满足 $i \le l_j - 1$ 的数目

那么也就将约束条件 $$ \left\{\begin{matrix} 
  prepos_i < l_j \\  
  l_j \le i \le r_j
\end{matrix}\right. $$ , 转化为了满足 $$ \left\{\begin{matrix} 
  prepos_i < l_j \\  
  i \le r_j
\end{matrix}\right. $$ 的值减去满足 $$ \left\{\begin{matrix} 
  prepos_i < l_j \\  
  i \le l_j - 1
\end{matrix}\right. $$​ 的值

然后这个约束条件其实看着不太舒服, 所以令 $l_i = prepos_i$ , $r_i = i$ , 把原来的约束条件中的符号换一下, 让它好看一点

即满足 $$ \left\{\begin{matrix} 
  l_i < l_j \\  
  r_i \le r_j
\end{matrix}\right. $$ 时, 如果 $i$ 代表数组元素, $j$ 代表查询, 则进行操作 $ans_j ++$ 或者满足 $$ \left\{\begin{matrix} 
  l_i < l_j \\  
  r_i \le l_j - 1
\end{matrix}\right. $$ 时 $ans --$​ 

在代码的处理上, 我们多加 $m$ 个操作, 让这些操作的 $r_j = l_j - 1$ , 这样的话两种操作就都整理成 $$ \left\{\begin{matrix} 
  l_i < l_j \\  
  r_i \le r_j
\end{matrix}\right. $$ 这种逆序对的一般形式了, 然后最终计算贡献的时候再乘上 $-1$ 

```c++
int n,m,x,L[MAXN],R[MAXN],id[MAXN],type[MAXN],pre[MAXN/3],ans[MAXN],temp[MAXN],f[MAXN];
inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
inline int getq(int x)
{
    if(x>n)x-=n;
    if(x>m)x-=m;
    return x;
}
void cdqDivAlgorithm(int l,int r){
    if(l==r)return;
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid);
    cdqDivAlgorithm(mid+1,r);
    int p1=l,pl=l,p2=mid+1,sum=0;
    while(p1<=mid&&p2<=r){
        if(R[id[p1]]<=R[id[p2]]){
            if(type[id[p1]]==0)++sum;
            temp[pl++]=id[p1++];
        }else{
            if(type[id[p2]]==1)
                ans[getq(id[p2])]+=sum*f[id[p2]];
            temp[pl++]=id[p2++];
        }
    }
    while(p1<=mid){
        temp[pl++]=id[p1++];
    }
    while(p2<=r){
        if(type[id[p2]]==1)
            ans[getq(id[p2])]+=sum*f[id[p2]];
        temp[pl++]=id[p2++];
    }
    for(int i=l;i<=r;++i){
        id[i]=temp[i];
    }
}
int main()
{
    n=read();
    memset(pre,-1,sizeof(pre));
    for(int i=1;i<=n;++i){
        id[i]=i,L[i]=pre[x=read()],R[i]=i;
        pre[x]=i;
        type[i]=0;
    }
    m=read();
    for(int i=1;i<=m;++i){
        id[n+i]=n+i;
        L[n+i]=read();
        R[n+i]=read();
        type[n+i]=1;
        f[n+i]=1;
        id[n+m+i]=n+m+i;
        L[n+m+i]=L[n+i];
        R[n+m+i]=L[n+i]-1;
        type[n+m+i]=1;
        f[n+m+i]=-1;
    }
    
    sort(id+1,id+1+n+m*2,[](const int &A,const int &B){
         return L[A]!=L[B]?L[A]<L[B]:type[A]>type[B];
         });
    cdqDivAlgorithm(1,n+m*2);
    for(int i=1;i<=m;++i){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

#### 分治求动态凸包

> ###### [JSOI2008] Blue Mary 开公司
>
> ###### 题目背景
>
> Blue Mary 最近在筹备开一家自己的网络公司。由于他缺乏经济头脑，所以先后聘请了若干个金融顾问为他设计经营方案。
>
> ###### 题目描述
>
> 万事开头难，经营公司更是如此。开始的收益往往是很低的，不过随着时间的增长会慢慢变好。也就是说，**对于一个金融顾问 $i$，他设计的经营方案中，每天的收益都比前一天高，并且均增长一个相同的量 $P_i$。**
>
> 由于金融顾问的工作效率不高，**所以在特定的时间，Blue Mary 只能根据他已经得到的经营方案来估算某一时间的最大收益**。由于 Blue Mary 是很没有经济头脑的，所以他在估算每天的最佳获益时完全不会考虑之前的情况，而是直接从所有金融顾问的方案中选择一个在当天获益最大的方案的当天的获益值，例如：
>
> 有如下两个金融顾问分别对前四天的收益方案做了设计：
>
> |        | 第一天 | 第二天 | 第三天 | 第四天 | $P_i$ |
> | :----: | :----: | :----: | :----: | :----: | :---: |
> | 顾问 1 |  $1$   |  $5 $  |  $9$   |  $13$  |  $4$  |
> | 顾问 2 |  $2$   |  $5$   |  $8$   |  $11$  |  $3$  |
>
> 在第一天，Blue Mary 认为最大收益是 $2$（使用顾问 2 的方案），而在第三天和第四天，他认为最大收益分别是 $9$ 和 $13$（使用顾问 1 的方案）。而他认为前四天的最大收益是：$2 + 5 + 9 + 13 = 29$。
>
> 现在你作为 Blue Mary 公司的副总经理，会不时收到金融顾问的设计方案，也需要随时回答 Blue Mary 对某天的“最大收益”的询问（这里的“最大收益”是按照 Blue Mary 的计算方法）。**一开始没有收到任何方案时，你可以认为每天的最大收益值是 0**。下面是一组收到方案和回答询问的例子：
>
>
> - 询问 $2$，回答 $0$。
> - 收到方案：$0\ 1\ 2\ 3\ 4\ 5\ \cdots$
> - 询问 $2$，回答 $1$。
> - 收到方案：$2\ 2.1\ 2.2\ 2.3\ 2.4\ \cdots$
> - 询问 $2$，回答 $2.1$。
>
> ###### 输入格式
>
> 第一行 ：一个整数 $N$，表示方案和询问的总数。 
>
> 接下来 $N$ 行，每行开头一个单词 `Query` 或 `Project`。 
>
> 若单词为 `Query`，则后接一个整数 $T$，表示 Blue Mary 询问第 $T$ 天的最大收益。 
>
> 若单词为 `Project`，则后接两个实数 $S, P$，表示该种设计方案第一天的收益 $S$，以及以后每天比上一天多出的收益 $P$。
>
> ###### 输出格式
>
> 对于每一个 `Query`，输出一个整数，表示询问的答案，并精确到整百元（以百元为单位，例如：该天最大收益为 $210$ 或 $290$ 时，均应该输出 $2$）。没有方案时回答询问要输出 $0$。
>
> ###### 样例 #1
>
> ###### 样例输入 #1
>
> ```
> 10
> Project 5.10200 0.65000
> Project 2.76200 1.43000
> Query 4
> Query 2
> Project 3.80200 1.17000
> Query 2
> Query 3
> Query 1
> Project 4.58200 0.91000
> Project 5.36200 0.39000
> ```
>
> ###### 样例输出 #1
>
> ```
> 0
> 0
> 0
> 0
> 0
> ```
>
> ###### 提示
>
> **数据范围**
>
> $1 \leq N \leq 10 ^ 5$，$1 \leq T \leq 5\times 10 ^ 4$，$0 < P < 100$，$|S| \leq 10 ^ 5$。
>
> **提示**
>
> 本题读写数据量可能相当巨大，请选手注意选择高效的文件读写方式。

这个应该是CDQ最多的使用场景, 那为什么求个凸包和偏序扯上关系了呢

问题就在于, 单调队列/单调栈这玩意太菜了. 它要求你给出的直线的斜率必须是单调增或者减的, 总之得有单调性. 然后查询最好也有单调性, 如果查询不具有单调性也能查, 不过得在单调栈里面二分. 如果两个都不单调就凉了. 有个叫李超树的东西用单 $log$ 就能在线插入直线, 查询凸包点值, 甚至还能 $log^2$ 插入线段, 而且常数还比较小

拯救单调栈/队列, 首先看一下它的使用条件

1. 按照时间顺序插入的直线斜率单调
2. 按照时间顺序进行查询点值的 $x$ 坐标单调

那么要想使用单调栈解决动态凸壳问题, 对于任意一对插入的直线 $i$ , $j$ 需要满足约束条件: $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  k_i \le k_j
\end{matrix}\right. $$ , 其中 $t$ 代表时间戳, $k$ 代表斜率

同理, 对于任意一对进行的查询 $i$ , $j$ 也要满足约束条件: $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  x_i \le x_j
\end{matrix}\right. $$ , 其中 $t$ 代表时间戳, $x$ 代表查询点值的横坐标

从 $t$ 有序归并到 $k$ , $x$ 有序即可. 然后因为插入直线总是在左子树才执行, 查询总是在右子树才执行, 所以插入的直线按 $k$ 排, 查询按 $x$ 排同时进行即可

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100005;
const double eps=1e-6;
int m,n,id[MAXN],qid[MAXN],type[MAXN],x[MAXN],temp[MAXN],top;
double k[MAXN],b[MAXN],ans[MAXN];
char op[55];
inline bool cmp(const int &A,const int &B){
    return type[A]!=type[B]?type[A]<type[B]:type[A]?x[A]<x[B]:k[A]<k[B];
}
inline int dcmp(double x){
    return x>eps?1:x<-eps?-1:0;
}
inline double getCross(const double &k1,const double &b1,const double &k2,const double &b2){
    return (b2-b1)/(k1-k2);
}
inline double getVal(const double &k,const double &b,const int &x)
{
    return k*x+b;
}
pair<double,double>stk[MAXN];
void stkClear(){
    top=0;
    stk[++top]=make_pair(0,0);
}
void stkInsert(double k,double b){
    if(dcmp(stk[top].first-k)==0 && dcmp(stk[top].second-b)<0)top--;
    if(dcmp(stk[top].first-k)==0 && dcmp(stk[top].second-b)>=0)return;
    while(top>=2&&dcmp(getCross(stk[top].first,stk[top].second,stk[top-1].first,stk[top-1].second)-getCross(stk[top].first,stk[top].second,k,b))>0)top--;
    stk[++top]=make_pair(k,b);
}
double stkQuery(int x){
    while(top>=2&&dcmp(getVal(stk[top].first,stk[top].second,x)-getVal(stk[top-1].first,stk[top-1].second,x))<0)--top;
    return getVal(stk[top].first,stk[top].second,x);
}
void cdqDivAlgorithm(int l,int r){
    if(l==r)return;
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid);
    cdqDivAlgorithm(mid+1,r);
    stkClear();
    for(int i=l;i<=mid && !type[id[i]];++i){
        stkInsert(k[id[i]],b[id[i]]);
    }
    for(int i=r;i>mid && type[id[i]];--i){
        ans[qid[id[i]]]=max(ans[qid[id[i]]],stkQuery(x[id[i]]));
    }
    int p1=l,pl=l,p2=mid+1;
    while(p1<=mid&&p2<=r){
        if(cmp(id[p1],id[p2])){
            temp[pl++]=id[p1++];
        }else{
            temp[pl++]=id[p2++];
        }
    }
    while(p1<=mid){
        temp[pl++]=id[p1++];
    }
    while(p2<=r){
        temp[pl++]=id[p2++];
    }
    for(int i=l;i<=r;++i){
        id[i]=temp[i];
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        id[i]=i;
        scanf("%s",op);
        if(*op=='P'){
            type[i]=0;
            scanf("%lf %lf",&b[i],&k[i]);
            b[i]-=k[i];
        }
        else{
            type[i]=1;
            qid[i]=++m;
            scanf("%d",&x[i]);
        }
    }
    cdqDivAlgorithm(1,n);
    for(int i=1;i<=m;++i){
        printf("%d\n",(int)ans[i]/100);
    }
    return 0;
}
```

#### 分治求区间和 (单点修改)

当 $i$ 是修改, $j$ 是查询, 则有满足约束条件: $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  l_j \le i \le r_j
\end{matrix}\right. $$ 时进行操作 $ans_j += val_i$ , 其中 $t$ 代表时间戳

利用前缀和进行拆分, 变成满足约束 $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  i \le r_j
\end{matrix}\right. $$ 时 $ans_j += val_i$ , 满足约束 $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  i \le l_j - 1
\end{matrix}\right. $$ 时 $ans_j -= val_i$​ 

```c++
int T,id[MAXN],sum[MAXN],type[MAXN],n,m,k,qid[MAXN],ans[MAXN],val[MAXN],l,r,pos[MAXN],f[MAXN],temp[MAXN];
char op[55];
void cdqDivAlgorithm(int l,int r){
    if(l==r)return;
    int mid=(l+r)>>1;
    cdqDivAlgorithm(l,mid);
    cdqDivAlgorithm(mid+1,r);
    int p1=l,pl=l,p2=mid+1,sum=0;
    while(p1<=mid&&p2<=r){
        if(pos[id[p1]]<=pos[id[p2]]){
            if(type[id[p1]]==0)
                sum+=val[id[p1]];
            temp[pl++]=id[p1++];
        }else{
            if(type[id[p2]]==1)
                ans[qid[id[p2]]]+=f[id[p2]]*sum;
            temp[pl++]=id[p2++];
        }
    }
    while(p1<=mid){
        temp[pl++]=id[p1++];
    }
    while(p2<=r){
        if(type[id[p2]]==1)
            ans[qid[id[p2]]]+=f[id[p2]]*sum;
        temp[pl++]=id[p2++];
    }
    for(int i=l;i<=r;++i){
        id[i]=temp[i];
    }
}
int main(){
    scanf("%d",&T);
    for(int cas=1;cas<=T;++cas){
        scanf("%d",&n);
        m=0;
        k=0;
        for(int i=1;i<=n;++i){
            scanf("%d",&sum[i]);
            sum[i]+=sum[i-1];
        }
        while(scanf("%s",op)){
            if(*op=='Q'){
                scanf("%d %d",&l,&r);
                type[++m]=1;
                id[m]=m;
                ans[qid[m]=++k]=sum[r]-sum[l-1];
                pos[m]=r;
                f[m]=1;
                type[++m]=1;
                id[m]=m;
                qid[m]=k;
                pos[m]=l-1;
                f[m]=-1;
            }else if(*op=='A'){
                type[++m]=0;
                id[m]=m;
                scanf("%d",&pos[m]);
                scanf("%d",&val[m]);
            }else if(*op=='S'){
                type[++m]=0;
                id[m]=m;
                scanf("%d",&pos[m]);
                scanf("%d",&val[m]);
                val[m]=-val[m];
            }else{
                break;
            }
        }
        
        cdqDivAlgorithm(1,m);
        printf("Case %d:\n",cas);
        for(int i=1;i<=k;++i){
            printf("%d\n",ans[i]);
        }
    }
}
```

#### 分治求区间和 (区间修改)、分治求区间和 (区间加等差)

对于区间加数, 做一次差分后变为单点修改区间查询, 就变成了 $$ \left\{\begin{matrix} 
  t_i < t_j \\  
  l_j \le i \le r_j
\end{matrix}\right. $$ 这种形式

区间加等差数列或者区间加任意多项式也是同理, 维护相应阶数的差分数组即可, 只不过计算贡献时, 不是简单的数值而是多项式

<br>

### 整体二分

很多题都可以用二分解决. 但是如果我们对每个询问都直接二分, 可能会收获一个 `TLE` . 这时候我们就会用到整体二分. 整体二分的主题思路就是把多个查询一起解决. (所以这是一个离线算法)

> 所谓整体二分, 需要数据结构题满足以下性质:
>
> 1. 询问的答案具有可二分性
> 2. **修改对判定答案的贡献互相独立**, 修改之间互不影响效果
> 3. 修改如果对判定答案有贡献, 则贡献为一确定的与判定标准无关的值
> 4. 贡献满足交换律, 结合律, 具有可加性
> 5. 题目允许离线算法
>
> ——许昊然《浅谈数据结构题几个非经典解法》

整体二分的老本行: 区间第 $k$ 大值查询

给一个数组, 查询若干次, 每次查询一个区间 $[L, R]$ , 支持修改操作

**思路**

定义 $[l, r]$ 为答案的值域, $[L, R]$ 为答案的定义域. (也就是说这个答案是针对区间 $[L, R]$ 的)

+ 我们首先把所有操作 **按顺序** 存入一个结构体中, 然后开始分治
+ 在每一层分治中, 利用数据结构 (一般是树状数组) 统计当前查询的答案和 $mid$ 之间的关系
+ 根据查询出来的关系将所有查询分为 $q1$ 和 $q2$ (小于等于 $mid$ 和大于 $mid$ )
+ 将 $q1$ 和 $q2$ 重新组成新的查询序列 $q$ , 分治
+ 当 $l = r$ 时, 找到答案, 记录答案返回即可

```c++
struct node{
    int val,x,y,k,pos,ty;
}q[maxn],q1[maxn],q2[maxn];
int n,m,a[maxn],t,cnt,c[maxn],ans[maxn];
void add(int pos,int x){
    for(;pos<=n;pos+=pos&-pos){
        c[pos]+=x;
    }
    return;
}
int query(int pos){
    int anstot=0;
    for(;pos>=1;pos-=pos&-pos){
        anstot+=c[pos];
    }
    return anstot;
}
void solve(int l,int r,int L,int R){
    if(l>r||L>R)return;
    int cnt1=0,cnt2=0,mid=(l+r)>>1;
    if(l==r){
        for(int i=L;i<=R;i++){
            if(q[i].ty){ans[q[i].pos]=l;}
        }
        return;
    }
    for(int i=L;i<=R;i++){ //遍历所有询问
        if(q[i].ty){ //为查询操作
            int tmp=query(q[i].y)-query(q[i].x-1); //小于等于mid，在[x,y]区间内的元素个数
            if(tmp>=q[i].k){ //mid过大
                q1[++cnt1]=q[i];
            }
            else{
                q[i].k-=tmp;q2[++cnt2]=q[i];
            }
        }
        else{ //为修改操作
            if(q[i].val<=mid){add(q[i].pos,q[i].k);q1[++cnt1]=q[i];}
            else q2[++cnt2]=q[i];
        }

    }

    for(int i=1;i<=cnt1;i++){if(!q1[i].ty)add(q1[i].pos,-q1[i].k);}
    for(int i=1;i<=cnt1;i++){q[L+i-1]=q1[i];}
    for(int i=1;i<=cnt2;i++){q[L+i-1+cnt1]=q2[i];}
    solve(l,mid,L,L+cnt1-1);solve(mid+1,r,L+cnt1,R);
}
int main(){
    int cnt=0,cntans=0,pos,x;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);q[++cnt]=(node){a[i],0,0,1,i,0};
    }
    for(int i=1;i<=m;i++){
        int l,r,k;char s[5];scanf("%s",s);
        if(s[0]=='Q'){
            scanf("%d%d%d",&l,&r,&k);q[++cnt]=(node){0,l,r,k,++cntans,1};
        }
        else{
            scanf("%d%d",&pos,&x);q[++cnt]=(node){a[pos],0,0,-1,pos,0};q[++cnt]=(node){a[pos]=x,0,0,1,pos,0};
        }
    }
    solve(-inf,inf,1,cnt);
    for(int i=1;i<=cntans;i++){
        printf("%d\n",ans[i]);
    }
}
```

<div style="page-break-after:always;"></div>

# 树上信息维护

### 树的DFS序、树上差分、树上倍增

#### 树的dfs序

+ 对于一棵二叉树, 它有三种遍历方式:
  + 前序
  + 中序
  + 后序
+ 这三种顺序其实都有使用的场景 (主要是在分治算法中考虑是递归前, 递归进行中, 递归后) 的区别
+ 在多叉树里面, 常用的 $dfs$ 序有三种:
  + $dfs$ 序
  + 扩展 $dfs$ 序
  + 欧拉序
+ $dfs$ 序类似二叉树的先序遍历
+ 扩展 $dfs$ 序类似二叉树的先序 + 中序
+ 欧拉序类似二叉树的先序 + 后序
+ 在树上问题中 $dfs$ 序往往是为了构建"树"与"序列"的桥梁
+ 绝大部分的"子树"操作类问题, "树链"操作问题, 其实本质来讲都是利用了 $dfs$ 序列将树结构整理成数组

#### dfs序

+ 定义多叉树的 $dfs$ 序是一种类二叉树先序遍历
+ 定义 $dfn$ 是 $dfs$ 遍历的标号计数变量
+ 定义 $id[x]$ $(L)$ 数组是 $x$ 节点在遍历的过程中被标记的 $dfn$ 的值
+ 定义 $idx (mp) [x]$ 数组是 $dfn$ 为 $x$ 的节点是哪个节点
+ 对于一棵多叉树, 发现将其利用 $dfs$ 序重标号后, 每一棵子树的 $dfs$ 序全都是连续的
+ 之前定义过 $id$ 数组, 其实它还有一个含义, 它还表示 $L$ 数组
+ 定义 $L[x]$ 数组表示在 $dfs$ 遍历的过程中 $x$ 所覆盖子树的 $dfn$ 最小值
+ 定义 $R[x]$ 数组表示在 $dfs$ 遍历的过程中 $x$ 所覆盖子树的 $dfn$ 最大值
+ 有了 $LR$ 数组, 子树的维护问题就转化成了数组区间的维护问题

```c++ 
void dfs(int u)
{
    dfn[++ timestamp] = u;
    L[u] = timestamp;
    vis[u] = true;
    for(auto v: G[u])
        if(!vis[v])
            dfs(v);
    R[u] = timestamp;
}
```

#### 扩展dfs序

+ 扩展 $dfs$ 序是一种"类中序"的处理
+ 一般来讲对于多叉树是用不到这种类中序的, 因为多叉树的多个子树不像二叉树有左右的顺序关系, 但是扩展 $dfs$ 序被巧妙的使用在了一个黑科技 $LCA$ 的模板中
+ 该模板支持:
  + $O(N \log N)$ 时间预处理
  + $O(1)$ 在线查询任意两点的 $LCA$ 
+ 该模板的使用场景为:
  + 树的尺寸 $N$ 和 $LCA$ 的查询数目 $M$ 不对等, 并且在数量级上至少有 $N < M \times 10$ 的关系, 并且题目需要强制在线
+ 在遍历的过程中, 维护一个 `pair` 类型的 $ST$ 表, `pair<deep,id> ST` 
+ 总有一个 $lca(u, v)$ 的儿子, 它的 $dfn$ 是落在 $[dfn_u, dfn_v]$ 之间的, 而 $dfn$ 在 $[dfn_u, dfn_v]$ 之间的所有点的深度都不会小于或等于 $lca(u, v)$ 
+ 于是我们只需要找到 $dfn$ 在 $[dfn_u, dfn_v]$ 之间的深度最小的点即可, $lca(u, v)$ 即为该点的父亲

```c++
int root, timestamp;
int dfn[N], dep[N], fa[N], LG2[N];
int ST_LCA[LOG][N];
vector<int> G[N];

void ex_dfs(int u, int f)
{
    dfn[u] = ++ timestamp;
    dep[u] = dep[f] + 1;
    fa[u] = f;
    ST_LCA[0][dfn[u]] = u;

    for(auto v: G[u])
    {
        if(v == f) continue;
        ex_dfs(v, u);
    }
}
int get(int u, int v)
{
    return dep[u] < dep[v] ? u : v;
}
int LCA(int u, int v)
{
    if(u == v) return u;
    if(dfn[u] > dfn[v]) swap(u, v);
    u = dfn[u] + 1, v = dfn[v];
    int k = LG2[v - u + 1];
    return fa[get(ST_LCA[k][u], ST_LCA[k][v - (1 << k) + 1])];
}
void init()
{
    ex_dfs(root, 0);
    for(int i = 2; i <= n; i++)
        LG2[i] = LG2[i >> 1] + 1;
    for(int j = 1; j <= LG2[n]; j++)
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
            ST_LCA[j][i] = get(ST_LCA[j - 1][i], ST_LCA[j - 1][i + (1 << j - 1)]);
}
```

+ 利用扩展 $dfs$ 序, $LCA$ 问题转化成了 $RMQ$ 问题
+ 利用笛卡尔树, 可以将任意的 $RMQ$ 问题转化成 $LCA$ 问题
+ 笛卡尔树模型可以将和区间 $RMQ$ 有关的问题 (例如和 $RMQ$ 问题有关的动态规划方程, 区间 $DP$ 等) 转化成树上问题, 然后可以利用树形 $DP$ 求解
+ 扩展 $dfs$ 序: $LCA$ 问题 $\longrightarrow$ $RMQ$ 问题
+ 笛卡尔树: $RMQ$ 问题 $\longrightarrow$ $LCA$ 问题
+ 静态查询中, $LCA$ 问题和 $RMQ$ 问题是本质等价的

#### 欧拉序

+ 欧拉序是一种"类前后序", 原本我们处理 $LR$ 数组的时候, 一般来讲只对 $L$ 进行 $dfn++$ 的操作, 欧拉序和 $dfs$ 序的区别只在于要不要对 $R$ (回溯访问) 分配 $dfn$ 
+ 一般来讲, 回溯时分配 $dfn$ 的作用有两点:
  + 一是为了"抵消"前后的影响, 例如树链上莫队吗, 树链求异或和
  + 二是利用欧拉序列维护信息, 例如 $ETT$ (欧拉环游树)

```c++
void euler_dfs(int u)
{
    dfn[++ timestamp] = u;
    L[u] = timestamp;
    vis[u] = true;
    for(auto v: G[u])
        if(!vis[v])
            euler_dfs(v);
    dfn[++ timestamp] = u;
    R[u] = timestamp;
}
```

#### 树上差分

+ 一般来讲, 树上差分或者树上前缀和是为了解决静态的子树加数求和问题, 在步骤上可以直接做
+ 树链问题还是没法直接搞, 需要树链剖分 (这是由于树链中的 $dfn$ 不连续导致的)

#### 树上倍增

+ 树上倍增的写法类似 $ST$ 表, 但是无论维护哪些信息, 都要首先维护一个 $fa$ 数组, $fa[i][j]$ 表示树上第 $i$ 个节点向上跳跃 $2^j$ 后的父节点是谁
+ 预处理 `fa[i][j] = fa[fa[i][j - 1]][j - 1]` 

<br>

### 轻重树链剖分

#### 树链剖分

+ 树链剖分是为了解决树上链信息维护的问题
+ 利用线段树等结构, 可以维护数组中的增删改查问题
+ 树链剖分的作用其实就是将整棵结构树分解成若干段数组, 然后使用一个数据结构来维护每一条链的信息
+ (一般来讲不会使用平衡树去维护树链, 不然不如直接上 $LCT$ )

#### 链分解

+ 把一棵"树"拆分成若干个连续的"数组", 且每一部分互不包含就称之为是一个树的链分解
+ 如何随便的给出一个树的链分解呢, 很简单, 利用 $dfn$ , 也就是多叉树的 $dfs$ 序
+ 在 $dfs$ 的过程中从当前节点一路向下到叶子的过程天然的就是一种链分解
+ 我们定义 `top[]` 数组为链分解的链首, $dfs$ 的过程中对于第一个孩子继承当前节点的 $top$ 值, 否则另起新链即可

```c++
void dfs(int x, int tp)
{
    top[x] = tp;
    chain[tp].push_back(x);
    for(int i = 0; i < G[x].size(); i++)
        dfs(G[x][i], i ? G[x][i] : tp);
}
```

#### 伸展度

+ 一种叫"毛毛虫树"的结构

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\数据结构专题\毛毛虫.png" alt="毛毛虫" style="zoom:50%;" />

+ 所谓"毛毛虫"树就是指伸展度较低的树
+ 所谓"伸展度t"是指在造树的时候往往需要经过一下几个步骤
  + 1. 连边 $i \longleftrightarrow random(min(max(1 + t, 1), i - 1), min(max(i + t, 1), i - 1))$ 
  + 2. 节点随机重标号
  + 3. 边随机排列

```c++
//下面是生成一棵树的主要代码,它接受两个参数——顶点数和伸展度。例如,当n=10,t=1000时,可能会生成链;当n=10,t=-1000时,可能会生成菊花
#define forn(i, n) for (int i = 0; i < int(n); i++)

registerGen(argc, argv, 1);

int n = atoi(argv[1]);
int t = atoi(argv[2]);

vector<int> p(n);

/* 为节点 1..n-1 设置父亲 */
forn(i, n) if (i > 0) p[i] = rnd.wnext(i, t);

printf("%d\n", n);

/* 打乱节点 1..n-1 */
vector<int> perm(n);
forn(i, n) perm[i] = i;
shuffle(perm.begin() + 1, perm.end());

/* 根据打乱的节点顺序加边 */
vector<pair<int, int> > edges;
for (int i = 1; i < n; i++)
  if (rnd.next(2))
    edges.push_back(make_pair(perm[i], perm[p[i]]));
  else
    edges.push_back(make_pair(perm[p[i]], perm[i]));

/* 打乱边 */
shuffle(edges.begin(), edges.end());

for (int i = 0; i + 1 < n; i++)
  printf("%d %d\n", edges[i].first + 1, edges[i].second + 1);
```

+ 伸展度越大, 全局树深度越小, 当伸展度 $= INF$ 时, 树退化为菊花
+ 伸展度越小, 全局树深度越大, 当伸展度 $= -INF$ 时, 树退化为单链
+ 毛毛虫树是伸展度较小, 并且不为 $-INF$ 的情况
+ 这种情况下会使得随机 $dfs$ 的链分解出的链非常短

#### 轻重树链剖分

+ 所以在做链分解之前, 首先要做的一个预处理过程是对于子树轻重的划分
+ 首先利用树 $DP$ 求出所有子树的大小 $size$ 
+ 定义重儿子为当前节点中所有子树 $size$ 最大的子树
+ 定义轻儿子为当前节点中所有子树 $size$ 最小的子树
+ 定理: 轻儿子的 $size$ 必定小于等于当前子树 $size$ 的一半
+ 定理的扩展: 树上没经过一条轻边之后, 子树尺寸缩减一半

#### LCA

+ 这是一种暴力的 $LCA$ 写法
+ 该写法的好处在于, 如果树深度可控, 那么复杂度就是树深度

```c++
int lca(int x, int y)
{
    while(x != y)
    {
        if(deep[x] < deep[y]) swap(x, y);
        x = fa[x];
    }
    return x;
}
```

#### 链分解后的结构树

+ 在对树进行链分解以后, 借助面向对象的思想, 我们把一整个重链看成一个整体, 作为一个大的"节点"看待, 树上的轻链看成是结构树的部分
+ 这样的话, 整个树就被"压缩"了
+ 可以证明, 压缩后的结构树, 深度不超过 $\log N$ 

#### 树链剖分实现LCA

+ 树链剖分后的结构树深度可控
+ 直接暴力复杂度就是 $O(log)$ 级别的

```c++
int lca(int x, int y)
{
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return deep[x] < deep[y] ? x : y;
}
```

#### 树链剖分

+ 所以说树链剖分的本质是, 对于结构树的压缩重构, 使得在新的结构树上面暴力移动的复杂度不多于 $log$ (即进行树链剖分后重链形成的结构树, 树的直径变为 $\log N$ )
+ 树链剖分本身不具备任何维护信息的功能, 换句话说树链剖分本身不是数据结构, 只是利用 $dfs$ 对树的整理过程

```c++
int b[MAXN], arr[MAXN], deep[MAXN], g[MAXN], sz[MAXN], fa[MAXN], top[MAXN], id[MAXN], son[MAXN], sum[MAXN], tot, dfn, n, m, q;
struct edges
{
    int to, next;
}e[2 * MAXN];
void init()
{
    tot = dfn = 0;
    memset(g, 0, sizeof g);
    memset(sz, 0, sizeof sz);
    memset(fa, 0, sizeof fa);
    memset(top, 0, sizeof top);
    memset(id, 0, sizeof id);
    memset(son, 0, sizeof son);
    memset(sum, 0, sizeof sum);
}
void add_edge(int from, int to)
{
    e[++tot].to = to;
    e[tot].next = g[from];
    g[from] = tot;
    return;
}
void dfs1(int x, int dep, int father)
{
    sz[x] = 1;
    deep[x] = dep;
    fa[x] = father;
    for(int i = g[x]; i; i = e[i].next)
    {
        if(e[i].to != father)
        {
            dfs1(e[i].to, dep + 1, x);
            sz[x] += sz[e[i].to];
            if(!son[x] || sz[son[x]] < sz[e[i].to]) son[x] = e[i].to;
        }
    }
}
void dfs2(int x, int tp)
{
    id[x] = ++ dfn;
    b[dfn] = arr[x];
    top[x] = tp;
    if(son[x]) dfs2(son[x], tp);
    for(int i = g[x]; i; i = e[i].next)
    {
        if(e[i].to != fa[x] && e[i].to != son[x])
        {
            dfs2(e[i].to, e[i].to);
        }
    }
    return;
}
int lowbit(int x)
{
    return x & -x;
}
int qsum(int x)
{
    int ans = 0;
    while(x)
    {
        ans += sum[x];
        x -= lowbit(x);
    }
    return ans;
}
void change(int x, int num)
{
    while(x <= n)
    {
        sum[x] += num;
        x += lowbit(x);
    }
    return;
}
void build()
{
    for(int i = 1; i <= n; i++)
    {
        sum[i] += b[i] - b[i - 1];
        if(i + lowbit(i) <= n)
        {
            sum[i + lowbit(i)] += sum[i];
        }
    }
    return;
}
void chain_add(int root1, int root2, int v)
{
    while(top[root1] != top[root2])
    {
        if(deep[top[root1]] < deep[top[root2]]) swap(root1, root2);
        change(id[top[root1]], v);
        change(id[root1] + 1, -v);
        root1 = fa[top[root1]];
    }
    if(deep[root1] > deep[root2]) swap(root1, root2);
    change(id[root1], v);
    change(id[root2] + 1, -v);
    return;
}
int main()
{
    while(scanf("%d %d %d", &n, &m, &q) != EOF)
    {
        init();
        for(int i = 1; i <= n; i++)
        {
            scanf("%d", &arr[i]);
        }
        for(int i = 1; i <= m; i++)
        {
            int u, v;
            scanf("%d %d", &u, &v);
            add_edge(u, v);
            add_edge(v, u);
        }
        dfs1(1, 1, 0);
        dfs2(1, 1);
        build();
        for(int i = 1; i <= q; i++)
        {
            scanf("%s", que);
            if(que[0] == 'I')
            {
                int u, v, c;
                scanf("%d %d %d", &u, &v, &c);
                chain_add(u, v, c);
            }
            else if(que[0] == 'D')
            {
                int u, v, c;
                scanf("%d %d %d", &u, &v, &c);
                chain_add(u, v, -c);
            }
            else
            {
                int u;
                scanf("%d", &u);
                printf("%d\n", qsum(id[u]));
            }
        }
    }
}
```

<br>

### dsu on tree 长链剖分

+ $dsu \ on \ tree$ 和长链剖分都是解决子树类静态查询问题的统计类算法
+ 这类问题首先要是"子树"查询, 并且是"静态"不带修改的
+ 某些问题其实不太有必要上 $dsu \ on \ tree$ , 比如子树元素和, 子树元素最大值 (可合并区间信息)
+ $dsu \ on \ tree$ 处理的问题有, 例如子树众数, 子树元素种类数

#### dsu on tree (树上启发式合并)

+ $dsu \ on \ tree$ 这个算法的本质是"优雅的暴力", 也就是在思想上这个算法和莫队更接近一些, 但是在复杂度证明和原理上, 它更偏向于轻重树链剖分, 因此它还有一些别名, 比如"树上启发式合并"、"轻重树链分治"等
+ 选莫队算法作为切入点, 这两个算法在应用的场景上有共通点, 只不过一个应用于子树, 一个应用于数组区间

**莫队**

从最简单的区间问题"子区间的静态求和问题"开始讨论

假定现在有一个数组 $a$ , 数组里面有若干个元素, 然后已知 $[l_1, r_1]$ 这段区间的区间和, 假定区间 $[l_1, r_1]$ 与区间 $[l_2, r_2]$ 有大面积重合, 重合率达到 $90\%$ . 问如何在已知 $[l_1, r_1]$ 区间和情况下计算 $[l_2, r_2]$ 的区间和 ?

只要把 $l_1$ 向后面移动, 然后令 $ans$ 每次减少遍历到的数组元素 $a[l_1]$ , 再把 $r_1$ 向后移动, 每次加入新的元素 $a[r_1]$ , 这样利用区间 $[l_1, r_1]$ 计算区间 $[l_2, r_2]$ 的结果复杂度为 $|l_2 - l_1| + |r_2 - r_1|$ , 在区间重合率较高的情况下可以优化很多重复计算

假设共有 $m$ 个查询问题, 每一次的查询都基于上一次查询的结果的基础上, 那么总复杂度就可以表示为 $\sum_{i = 1}^{m} |l_i - l_{i - 1}| + |r_i - r_{i - 1}|$ 

如果想要让这个复杂度最小化, 也就是"**如何安排一个合理的查询顺序, 使得复杂度最小化**"

与动态规划的思路不同, 动态规划的思想是既然有重复子问题, 那就不停地划分子问题, 然后分阶段求解不同子问题, 最终求总的答案, 这样最高效率地利用了重复子问题. 而莫队是如何利用重复子问题的呢, 显然它没有保存, 它只是因为当前的查询与下一个查询之间有重复部分, 所以不用重复统计仅此而已

从莫队上得到了启示: **对于静态的查询类问题, 如果查询之间有大面积的重合, 那么只要安排一个合理的顺序暴力求解就能降低复杂度** 

**为什么不用区间DP/倍增跳表或者线段树维护**

就是因为它们做不到, 所以才需要莫队, 要么是时空不允许, 要么就干脆不满足区间合并的性质, 比如"区间元素种类数", "区间出现次数 $> k$ 的元素"等

这个问题的答案也揭示了后面"为什么需要 $dsu \ on \ tree$ , 而非直接树形 $DP$​ "这个问题

**dsu on tree**

1. 优先处理子树查询, 再处理根节点
2. 当出现多个子树的时候, 优先处理轻儿子, 处理完每个轻儿子之后使用 $init$ 清空, 最后处理重儿子并保留信息的情况下处理根节点

**"最优求解序列"就是轻重树链剖分的dfs序列的倒置, 并且在每条重链的链首处进行了一次init()**

定理: 树上任意节点到根节点的简单路径中, 经过轻边的数目不多于 $\log n$ 

那对于任意节点 $x$ , 它对总时间复杂度的贡献不多于 $\log n$ , 那么这个算法的最终复杂度就不多于 $O(n \log n)$ 

> 输入一个正整数 $n$ 表示有 $n$ 个节点的树, 根节点为 $1$ 号节点, 然后输入 $n$ 个正整数表示点权, 请输出 $n$ 个数, 以每个点为根的子树权值和

```c++
int n;
int g[MAXN],tot,dfn,u,v;
int sz[MAXN],deep[MAXN],fa[MAXN],son[MAXN],L[MAXN],R[MAXN],Index[MAXN],skp;
long long sum,ans[MAXN],val[MAXN];
struct edges
{
    int to,next;
}e[2*MAXN];
void add_edge(int from,int to)
{
    e[++tot].to=to;
    e[tot].next=g[from];
    g[from]=tot;
    return;
}
void dfs(int x,int dep,int father)
{
    sz[x]=1;
    deep[x]=dep;
    fa[x]=father;
    son[x]=0;
    L[x]=++dfn;
    Index[dfn]=x;
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=father)
        {
            dfs(e[i].to,dep+1,x);
            sz[x]+=sz[e[i].to];
            if(!son[x]||sz[son[x]]<sz[e[i].to])son[x]=e[i].to;
        }
    }
    R[x]=dfn;
    return;
}
void get_data(int x)
{
    for(int i=L[x];i<=R[x];++i)
    {
        if(Index[i]==skp)
        {
            i=R[Index[i]];
            continue;
        }
        sum+=val[Index[i]];
    }
}
/*
void get_data(int x)
{
    if(x==skp)return;
    sum+=val[x];
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to==fa[x])continue;
        get_data(e[i].to);
    }
}
*/
void dsu(int x,bool del)
{
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to==fa[x]||e[i].to==son[x])continue;
        dsu(e[i].to,true);
    }
    ///skip the heavy son
    if(son[x])
    {
        dsu(son[x],false);
        skp=son[x];
    }
    ///get data from light son and itself
    get_data(x);
    ///solve problem with subtree x
    ans[x]=sum;
    ///if delete clear all
    if(del)
    {
        skp=0;
        sum=0;
    }
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%lld",&val[i]);
    }
    for(int i=1;i<n;++i)
    {
        scanf("%d %d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs(1,1,-1);
    dsu(1,0);
    for(int i=1;i<=n;++i)
    {
        printf("%lld%c",ans[i],i==n?'\n':' ');
    }
}
```

**为什么需要dsu on tree**

这个问题其实就类似使用莫队的困境一样, 有的树形 $dp$ , 它压根就不支持子树之间的合并问题. 就是说虽然根节点可以快速在单链时快速转移, 但是碰到两个以上的子树时, 两子树之间的信息不能快速合并

例如"子树元素种类数", "子树元素众数"

> 输入一个正整数 $n$ 表示有 $n$ 个节点的树, 根节点为 $1$ 号节点, 然后输入 $n$ 个正整数表示点权, 请输出 $n$ 个数, 以每个点为根的子树元素种类数

```c++
int n;
int g[MAXN],tot,dfn,u,v;
int sz[MAXN],deep[MAXN],fa[MAXN],son[MAXN],L[MAXN],R[MAXN],Index[MAXN],skp,col[MAXN],nowans,ans[MAXN],cnt[MAXN];
struct edges
{
    int to,next;
}e[2*MAXN];
void add_edge(int from,int to)
{
    e[++tot].to=to;
    e[tot].next=g[from];
    g[from]=tot;
    return;
}
void dfs(int x,int dep,int father)
{
    sz[x]=1;
    deep[x]=dep;
    fa[x]=father;
    son[x]=0;
    L[x]=++dfn;
    Index[dfn]=x;
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=father)
        {
            dfs(e[i].to,dep+1,x);
            sz[x]+=sz[e[i].to];
            if(!son[x]||sz[son[x]]<sz[e[i].to])son[x]=e[i].to;
        }
    }
    R[x]=dfn;
    return;
}
void get_data(int x,int op)
{
    for(int i=L[x];i<=R[x];++i)
    {
        if(Index[i]==skp)
        {
            i=R[Index[i]];
            continue;
        }
        cnt[col[Index[i]]]+=op;
        if(cnt[col[Index[i]]]==1)++nowans;
        if(cnt[col[Index[i]]]==0)--nowans;
    }
}

void dsu(int x,bool del)
{
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to==fa[x]||e[i].to==son[x])continue;
        dsu(e[i].to,true);
    }
    ///skip the heavy son
    if(son[x])
    {
        dsu(son[x],false);
        skp=son[x];
    }
    ///get data from light son and itself
    get_data(x,1);
    ///solve problem with subtree x
    ans[x]=nowans;
    ///if delete clear all
    if(del)
    {
        //注意del这个东西,虽然我们要的效果是将cnt数组和nowans清零,但是实际上我们不能使用memset,否则复杂度会退化为O(n^2)
        skp=0;
        get_data(x,-1);
    }
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&col[i]);
    }
    for(int i=1;i<n;++i)
    {
        scanf("%d %d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs(1,1,-1);
    dsu(1,0);
    for(int i=1;i<=n;++i)
    {
        printf("%d%c",ans[i],i==n?'\n':' ');
    }
}
```

### 长链剖分

长链剖分可以视作 $dsu \ on \ tree$ 算法的一个特例

$dsu \ on \ tree$ 用于解决子树类的静态查询问题, 基础复杂度为 $O(n \log n)$ 

长链剖用于解决子树类 **与深度相关可合并** 的静态查询类问题, 基础复杂度为 $O(n)$​ 

长链剖分中, $L[x]$ , $R[x]$ 和之前 $dsu \ on \ tree$ 的含义不同, 这次表示 **$x$ 节点的下属长链中 $dfn$ 的最小值与最大值**

> 给一棵以 $1$ 为根大小为 $n$ 的有根树, 每个点有点权, 查询若干次, 每次查询以 $x$ 的子树, 深度为 $y$ 的这一层中, 所有点权的和 (节点 $x$ 的深度为 $0$ )

```c++
int tot,g[MAXN],len[MAXN],L[MAXN],R[MAXN],fa[MAXN],son[MAXN],dfn,n,m,x,y,u,v;
long long val[MAXN],ans[MAXN],sum[MAXN];

vector<pair<int,int> >lis[MAXN];

struct edges
{
    int to,next;
}e[2*MAXN];

void add_edge(int from,int to)
{
    e[++tot].to=to;
    e[tot].next=g[from];
    g[from]=tot;
    return;
}

void dfs1(int x,int father)
{
    fa[x]=father;
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=father)
        {
            dfs1(e[i].to,x);
            if(!son[x]||len[son[x]]<len[e[i].to])son[x]=e[i].to;
        }
    }
    len[x]=len[son[x]]+1;
    return;
}
void dfs2(int x)
{
    L[x]=++dfn;
    R[x]=L[x]+len[x]-1;
    if(son[x])dfs2(son[x]);
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=fa[x]&&e[i].to!=son[x])
        {
            dfs2(e[i].to);
        }
    }
    return;
}
void dsu(int x)
{
    if(son[x])
    {
        dsu(son[x]);
    }
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=fa[x]&&e[i].to!=son[x])
        {
            dsu(e[i].to);
            for(int j=L[e[i].to],k=1;j<=R[e[i].to];++j,++k)
            {
                sum[L[x]+k]+=sum[j];
            }
        }
    }
    sum[L[x]]+=val[x];
    for(auto &i:lis[x])
    {
        ans[i.first]=sum[L[x]+i.second];
    }
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%lld",&val[i]);
    }
    for(int i=1;i<n;++i)
    {
        scanf("%d %d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs1(1,0);
    dfs2(1);
    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%d %d",&x,&y);
        lis[x].push_back(make_pair(i,y));
    }
    dsu(1);
    for(int i=1;i<=m;++i)
    {
        printf("%lld\n",ans[i]);
    }
}
```

<div style="page-break-after:always;"></div>

# 动态树

+ 树上查询问题是指, 给定一个图论中的树结构, 需要对树上的子树或者链进行一系列增删改查的问题
+ 和序列问题中一般常说的"动态"和"静态"不同
+ 动态树问题一般指树结构发生改变
+ 动态树常见的有三种
  + LCT: Link-cut-trees
  + ETT: Euler Tour Tree
  + TopTree

### LCT

+ $LCT$ 的顶层原理叫做, 用 $splay$ 维护动态的链分解
+ $LCT$ 相对于其他数据结构属于大型数据结构
+ 把一条树链当成一个点, 把轻边当成树上的边, 我们可以得到一棵结构树. 这个地方和树链剖分相同, 事实上 $link-cut \ tree$ 总是能在 $log$ 级的时间内把需要查询的树上的简单路径构造到同一条链中
+ $LCT$ 的基本函数
  + `access(x)` 不换根, 将根节点到 $x$ 节点构造到同一条链中
  + `change/make/set root(x)` 将节点 $x$ 设置成整棵树的根
  + `query path(x, y)` 将 $x$ , $y$ 构造到同一条链中, 且链的首尾为 $x$ , $y$ 
  + `link(x, y)` 将 $x$ , $y$ 连接到 $LCT$ 中
  + `cut` 将 $x$ , $y$ 从 $LCT$ 中断开
  + `lca(x, y, z)` 查询以 $x$ 为根, $y$ 和 $z$ 的 $lca$ 
  + `findroot(x)` 查询 $x$ 节点所在树结构的数根是谁, 类比并查集

#### access

+ $access$ 是 $LCT$ 中所有操作的基础, 是重中之重
+ $access$ 操作是 $Link-Cut \ Trees$ 的所有操作的基础. 假设调用了过程 $access(v)$ , 那么从点 $v$ 到根节点的路径就成为一条新的 $Preferred \ Path$ 
+ 如果执行了一个点的 $access$ 操作, 那么从根节点到这个点路径上的所有的点就会变成重儿子, 所有的边就会变成重边, 这条路经也就变为一条重路径, 同时, 从根节点到该节点的这条路径就被储存到了 $link-cut \ trees$ 根节点的 $splay$ 中

```c++
int access(int root)
{
    int temp = 0;
    while(root)
    {
        splay(root);
        t[root].ch[1] = temp;
        temp = root;
        root = t[root].fa;
    }
    return temp;
}
```

#### lca

+ 当我们从根节点画两条通路分别通向两个点时, 这两条通路中总是会有重合一部分, 这些重合的部分在我们两次 $access$ 操作中是不用变的, 那么最后一次变化的点就是两点的最近公共祖先

```c++
int lca(int root1, int root2)
{
    access(root1);
    return access(root2);
}
```

#### findroot

+ 查找数根指查找原树的树根, 并非 $link-cnt \ tree$ 的数根, 准确的说是寻找 $link-cnt \ tree$ 中主链 $deep$ 最小的点
+ 在 $access(v)$ 之后, 根节点一定是 $v$ 所属的伸展树深度最小节点. 我们先把 $v$ 旋转到它所属的伸展树的根, 再从 $v$ 开始, 沿着伸展树向左走, 直到不能再向左, 这个点就是我们要找的根节点. 由于使用的是 $splay$ 作为底层数据结构, 我们还需要对根节点进行 $splay$ 操作, 不然会导致势能均摊失效

```c++
int findroot(int root)
{
    access(root);
    splay(root);
    int temp = root;
    while(t[temp].ch[0]) temp = t[temp].ch[0];
    splay(temp); //不写答案也是对的,但是复杂度可能被卡
    return temp;
}
```

#### change/make root

```c++
void makeroot(int root)
{
    access(root);
    splay(root);
    t[root].rev ^= 1;
}
```

#### join/link (合并两棵link-cnt tree)

```c++
void link(int root1, int root2)
{
    makeroot(root1);
    t[root1].fa = root2;
}
```

#### cut (拆分)

```c++
void cut(int root1, int root2)
{
    makeroot(root1);
    access(root2);
    splay(root2);
    t[root2].ch[0] = t[root1].fa = 0;
}
```

#### query path

```c++
void query_path(int x, int y)
{
    makeroot(x);
    access(y);
    splay(y);
}
```

#### LCA (动态并查集)

```c++
int n, m, a1, b1;
char q[10];
struct tree
{
    int fa, ch[2], lazy;
}t[MAXN];
int stk[MAXN], top;
void pushdown(int root)
{
    if(t[root].lazy)
    {
        t[root].lazy = 0;
        swap(t[root].ch[0], t[root].ch[1]);
        t[t[root].ch[0]].lazy ^= 1;
        t[t[root].ch[1]].lazy ^= 1;
    }
    return;
}
bool isroot(int root)
{
    return t[t[root].fa].ch[0] != root && t[t[root].fa].ch[1] != root;
}
void rot(int root)
{
    int fa = t[root].fa;
    int gfa = t[fa].fa;
    int t1 = (root != t[fa].ch[0]);
    int t2 = (fa != t[gfa].ch[0]);
    int ch = t[root].ch[1^t1];
    if(!isroot(fa)) t[gfa].ch[0^t2] = root;
    t[ch].fa = fa;
    t[root].fa = gfa;
    t[root].ch[1^t1] = fa;
    t[fa].fa = root;
    t[fa].ch[0^t1] = ch;
    return;
}
void splay(int root)
{
    stk[++top] = root;
    for(int i = root; !isroot(i); i = t[i].fa)
    {
        stk[++top] = t[i].fa;
    }
    while(top)
    {
        pushdown(stk[top--]);
    }
    while(!isroot(root))
    {
        int fa = t[root].fa;
        int gfa = t[fa].fa;
        if(!isroot(fa))
            root == t[fa].ch[0]^fa == t[gfa].ch[0] ? rot(root) : rot(fa);
        rot(root);
    }
    return;
}
void access(int root)
{
    int temp = 0;
    while(root)
    {
        splay(root);
        t[root].ch[1] = temp;
        temp = root;
        root = t[root].fa;
    }
    return;
}
void makeroot(int root)
{
    access(root); splay(root); t[root].lazy ^= 1;
}
void link(int root1, int root2)
{
    makeroot(root1); t[root1].fa = root2;
}
void cut(int root1, int root2)
{
    makeroot(root1); access(root2); splay(root2);
    t[root2].ch[0] = t[root1].fa = 0;
}
int findroot(int root)
{
    access(root); splay(root); int temp = root;
    while(t[temp].ch[0]) temp = t[temp].ch[0];
    return temp;
}
int main()
{
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; i++)
    {
        scanf("%s %d %d", &q, &a1, &b1);
        if(q[0] == 'Q')
        {
            if(findroot(a1) == findroot(a2))
            	printf("Yes\n");
            else printf("No\n");
        }
        if(q[0] == 'C')
        {
            link(a1, b1);
        }
        if(q[0] == 'D')
        {
            cut(a1, b1);
        }
    }
}
```

<div style="page-break-after:always;"></div>

# 无根树子树信息统计

### 分治

+ 分治作为一种思想在算法中被广泛使用, 比如归并排序、线段树之类的算法都是使用了分治的思想
+ 除了这些算法的底层原理, 分治单独拿出来运用的其中一种场景是作为一种统计类算法使用
+ 统计类算法一般指不带修改, 静态查询类的问题, 但是不同于静态查询问题, 统计类问题一般要求"全查", 例如枚举所有的子区间, 枚举一棵树上所有的链, 枚举一棵树上所有的子树 (例: 给一个数组, 求所有子数组的 $gcd$ 之和)
+ 由于统计类问题往往要求"全查", 这个时候各种数据结构就有点力不从心了, 因为只要枚举例如数组的子区间, 复杂度就要退化到了 $N^2$ 级别

<br>

### 数组上的统计类问题

+ 数组上进行分治的原理:
  + ① 左右端点全部落在 $mid$ 左侧的
  + ② 左右端点全部落在 $mid$ 右侧的
  + ③ 左端点落在 $mid$ 左侧, 右端点落在 $mid$ 右侧
  + 每次处理③, 对于①②, 以递归函数的方式实现
+ 我们需要维护的东西, 是两个集合, 一个表示前缀, 一个表示后缀
+ 用 $meet \ in \ middle$ (折半搜索)的方式合并"集合"
+ 要学分治必须会这些东西, 分治一般不单独用
  + $map$ , $set$ , $lower\_bound$ , 二分答案, 双指针尺取法, 单调栈, 容斥

> 给定一个长度大小为 $n$ 的数组, 要求求出该数组的某一个子区间, 记该子区间的异或和为 $xorsum$ , 记该子区间的最大值为 $max$ , 记该子区间的最小值为 $min$ , 要求使得 $xorsum \oplus max \oplus min$ 最大

```c++
struct Persistent_Trie
{
    int ch[N][2],tot,sum[N];
    void clear()
    {
        tot=0;
        return;
    }
    void cpy(int from,int to)
    {
        ch[to][0]=ch[from][0];
        ch[to][1]=ch[from][1];
        sum[to]=sum[from];
        return;
    }
    void insert(int &root,int old,int num,int nowbit)
    {
        root=++tot;
        cpy(old,root);
        sum[root]++;
        if(nowbit==-1)return;
        if(num&(1<<nowbit))
        {
            insert(ch[root][1],ch[root][1],num,nowbit-1);
        }
        else
        {
            insert(ch[root][0],ch[root][0],num,nowbit-1);
        }
    }
    int que(int s,int t,int x)
    {
        int ans=0;
        for(int i=30;i>=0;--i)
        {
            if(sum[ch[t][!(x&(1<<i))]]-sum[ch[s][!(x&(1<<i))]])
            {
                t=ch[t][!(x&(1<<i))];
                s=ch[s][!(x&(1<<i))];
                ans|=(1<<i);
            }
            else
            {
                t=ch[t][!!(x&(1<<i))];
                s=ch[s][!!(x&(1<<i))];
            }
        }
        return ans;
    }
};
Persistent_Trie trie;
int n,a[MAXN],ans,maxarray[MAXN],minarray[MAXN],sumarray[MAXN],root[MAXN];
void div_algorithm(int l,int r)
{
    if(l>r)return;
    if(l==r)
    {
        ans=max(a[l],ans);
        return;
    }
    int mid=(l+r)>>1;
    int suml=0,maxl=-INF,minl=INF,maxr=-INF,minr=INF,sumr=0;
    int pin1,pin2;
    for(int i=mid;i>=l;--i)
    {
        suml^=a[i];
        maxl=max(maxl,a[i]);
        minl=min(minl,a[i]);
        sumarray[i]=suml;
        minarray[i]=minl;
        maxarray[i]=maxl;
    }
    for(int i=mid+1;i<=r;++i)
    {
        sumr^=a[i];
        maxr=max(maxr,a[i]);
        minr=min(minr,a[i]);
        sumarray[i]=sumr;
        minarray[i]=minr;
        maxarray[i]=maxr;
    }
    //1.max left min left
    trie.clear();
    root[mid]=0;
    for(int i=mid+1;i<=r;++i)
    {
        trie.insert(root[i],root[i-1],sumarray[i],30);
    }
    pin1=mid+1;
    for(int i=mid;i>=l;--i)
    {
        while(pin1<=r&&minarray[pin1]>=minarray[i]&&maxarray[pin1]<=maxarray[i])++pin1;
        int temp=minarray[i]^maxarray[i]^sumarray[i];
        ans=max(ans,temp);
        if(pin1>mid+1)
        {
            ans=max(ans,trie.que(root[mid],root[pin1-1],temp));
        }
    }
    //2.max right min right
    trie.clear();
    root[mid+1]=0;
    for(int i=mid;i>=l;--i)
    {
        trie.insert(root[i],root[i+1],sumarray[i],30);
    }
    pin1=mid;
    for(int i=mid+1;i<=r;++i)
    {
        while(pin1>=l&&minarray[pin1]>=minarray[i]&&maxarray[pin1]<=maxarray[i])--pin1;
        int temp=minarray[i]^maxarray[i]^sumarray[i];
        ans=max(ans,temp);
        if(pin1<mid)
        {
            ans=max(ans,trie.que(root[mid+1],root[pin1+1],temp));
        }
    }
    //3.max left min right
    trie.clear();
    root[mid]=0;
    for(int i=mid+1;i<=r;++i)
    {
        trie.insert(root[i],root[i-1],sumarray[i]^minarray[i],30);
    }
    ///pin1 min pin[
    ///pin2 max pin)
    ///anser range is [pin1,pin2)
    pin1=pin2=mid+1;
    for(int i=mid;i>=l;--i)
    {
        while(pin1<=r&&minarray[i]<minarray[pin1])++pin1;
        while(pin2<=r&&maxarray[i]>=maxarray[pin2])++pin2;
        if(pin1<pin2)
        {
            int temp=sumarray[i]^maxarray[i];
            ans=max(ans,trie.que(root[pin1-1],root[pin2-1],temp));
        }
    }
    //4.max right min left
    trie.clear();
    root[mid+1]=0;
    for(int i=mid;i>=l;--i)
    {
        trie.insert(root[i],root[i+1],sumarray[i]^minarray[i],30);
    }
    ///pin1 min pin[
    ///pin2 max pin)
    ///anser range is [pin1,pin2)
    pin1=pin2=mid;
    for(int i=mid+1;i<=r;++i)
    {
        while(pin1>=l&&minarray[i]<minarray[pin1])--pin1;
        while(pin2>=l&&maxarray[i]>=maxarray[pin2])--pin2;
        if(pin1>pin2)
        {
            int temp=sumarray[i]^maxarray[i];
            ans=max(ans,trie.que(root[pin1+1],root[pin2+1],temp));
        }
    }
    div_algorithm(l,mid);
    div_algorithm(mid+1,r);
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&a[i]);
    }
    
    div_algorithm(1,n);
    printf("%d\n",ans);
}
```

<br>

### 树上分治

+ 类比数组分治, 直接扩展到树上, 成为树分治的原理
  + ① 左右端点不过分治中心 $mid$
  + ② 左右端点横跨分治中心 $mid$ 
+ 树分治有两种, 一般常见的是点分治, 还有一种不太常用的边分治

#### 树的重心

+ 定义无根树的重心为: 选择重心作为整棵树的根节点, 使得整棵树变为有根树后, 可以最小化根节点的所有直接子树中尺寸的最大值
+ 树的重心有一个重要性质: 选择树的重心作为根节点时, 根节点的直接子树尺寸不大于 $N / 2$ , $N$ 表示整棵树的尺寸

#### 树分治

+ 选择重心以后按照数组分治中的思路做就可以了
  + ① 处理跨重心的树链
  + ② 递归处理子树

+ 一般树分治的模板需要这么几个函数
  + `get_gravity()` 
  + `get_size()` 
  + `get_data()` 
  + `get_ans()` 
  + `tree_div()` 
+ 一般用动的是 $get\_date$ 和 $get\_ans$ , 以及 $tree\_div$ 关于答案统计的部分可以要微调以外, 其他部分都是模板性的不需要动

> 给定一棵树, 每条边有边权, 统计树上所有长度小于 $k$ 的路径的数量

```c++
int n, k, g[MAXN], tot, gravity_size[MAXN], gravity_max[MAXN], gravity, siz, a, b, c, ans, dis[MAXN], distot, temp[MAXN];
bool div_vis[MAXN];
struct edges
{
    int to;
    int v;
    int next;
}e[MAXM<<1];
void add_edge(int from, int to, int v)
{
    e[++tot].to = to;
    e[tot].v = v;
    e[tot].next = g[from];
    g[from] = tot;
    return;
}
void init()
{
    tot = 0;
    for(int i = 1; i <= n; i++)
    {
        g[i] = 0;
        div_vis[i] = false;
    }
    ans = 0;
    return;
}
void get_gravity(int x, int fa)
{
    gravity_size[x] = 1;
    gravity_max[x] = -1;
    for(int i = g[x]; i; i = e[i].next)
    {
        if(e[i].to != fa && !div_vis[e[i].to])
        {
            get_gravity(e[i].to, x);
            if(gravity_max[x] == -1 || gravity_max[x] < gravity_size[e[i].to])
            {
                gravity_max[x] = gravity_size[e[i].to];
            }
            gravity_size[x] += gravity_size[e[i].to];
        }
    }
    gravity_max[x] = max(gravity_max[x], siz - gravity_size[x]);
    if(gravity == -1 || gravity_max[gravity] > gravity_max[x]) gravity = x;
}
void get_size(int x, int fa)
{
    ++ siz;
    for(int i = g[x]; i; i = e[i].next)
    {
        if(e[i].to != fa && !div_vis[e[i].to])
        {
            get_size(e[i].to, x);
        }
    }
}
void get_dis(int x, int fa, int nowdis)
{
    dis[++distot] = nowdis;
    for(int i = g[x]; i; i = e[i].next)
    {
        if(e[i].to != fa && !div_vis[e[i].to])
        {
            get_dis(e[i].to, x, nowdis + e[i].v);
        }
    }
    return;
}
int get_ans(int x, int v)
{
    distot = 0;
    get_dis(x, -1, v);
    sort(dis + 1, dis + 1 + distot);
    int l = 1;
    int ret = 0;
    for(int r = distot; r; r--)
    {
        while(dis[l] + dis[r] <= k && l <= distot) l++;
        ret += l - 1 - (l > r);
    }
    return ret;
}
void tree_div(int x)
{
    siz = 0;
    get_size(x, -1);
    gravity = -1;
    get_gravity(x, -1);
    div_vis[gravity] = true;
    int temp = get_ans(gravity, 0);
    ans += temp;
    for(int i = g[gravity]; i; i = e[i].next)
    {
        if(!div_vis[e[i].to])
        {
            temp = get_ans(e[i].to, e[i].v);
            ans -= temp;
        }
    }
    for(int i = g[gravity]; i; i = e[i].next)
    {
        if(!div_vis[e[i].to])
        {
            tree_div(e[i].to);
        }
    }
    return;
}
int main()
{
    while(scanf("%d %d", &n, &k) != EOF)
    {
        if(!n && !k) break;
        init();
        for(int i = 1; i < n; i++)
        {
            scanf("%d %d %d", &a, &b, &c);
            add_edge(a, b, c);
            add_edge(b, a, c);
        }
        tree_div(1);
        printf("%d\n", ans / 2);
    }
}
```

<div style="page-break-after:always;"></div>

# 无根树子树信息维护

### 点分树

+ 点分树是典型的三层结构模型
  + 第一层是分治重心树, 它是一个"区间树", 它表示作用域的嵌套关系
  + 第二层是图论结构树, 它表示第一层次中每一个节点的实际图论结构
  + 第三层是数据结构层, 这里可以嵌套各种数据结构, 包括数组、线段树、$STL$ , 平衡树
+ 实际上在做题的过程中, 我们需要做算法设计的是第三层, 前两层都是模板性的, 只需要做一次, 后面直接贴模板就行了

#### 分治重心树

+ 直接把树分治的模板贴过来, 加一个 $fa$ 参数, 直接记录一个 $fa$ , 这个树就建好了
+ (也可以完整的把这个分治重心树建出来用于调试, 因为后面只会用到 $fa$ 信息, 所以没必要用存图的方式来建树)

#### 图论结构树

+ 开一个 $belong$ 数组, 分层图 $belong[i][j]$ 表示分层图上带有状态的节点 $<i, j>$ 属于哪一张图
+ 那么它里面的值从逻辑上来讲应该是一个指针, 它指向一张图
+ 在实现上, 这些图它都是"树", 那么只要它指向"树"的根节点, 也就表示了整棵树

#### 数据结构层

+ 前面两层都是固定化的模板化的部分, 这一层次才是按照一些功能去设计整个算法的部分

> 给定一个棵树, 树上有黑点和白点, 求树上所有黑点的距离和, 且带修改

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200005,MAXM=200005,MAXDEEP=20;
const long long mod=1e9+7;
int n,k,g[MAXN],tot,gravity_size[MAXN],gravity_max[MAXN],gravity,siz,a,b,c,ans,temp[MAXN],div_fa[MAXN],sz[MAXN],top[MAXN],id[MAXN],deep[MAXN],son[MAXN],fa[MAXN],belone[MAXN][MAXDEEP],dfn,g_deep[MAXN];
long long spoint_cnt[MAXN],spoint_sum_dis[MAXN],sub_tree_spoint_cnt[MAXN][MAXDEEP],sub_tree_spoint_sum[MAXN][MAXDEEP],dis_to_gravity_fa[MAXN][MAXDEEP],nowans;
bool div_vis[MAXN];
struct edges
{
    int to;
    int next;
}e[MAXM<<1];
void add_edge(int from,int to)
{
    e[++tot].to=to;
    e[tot].next=g[from];
    g[from]=tot;
    return;
}
void get_gravity(int x,int fa)
{
    gravity_size[x]=1;
    gravity_max[x]=-1;
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=fa&&!div_vis[e[i].to])
        {
            get_gravity(e[i].to,x);
            if(gravity_max[x]==-1||gravity_max[x]<gravity_size[e[i].to])
            {
                gravity_max[x]=gravity_size[e[i].to];
            }
            gravity_size[x]+=gravity_size[e[i].to];
        }
    }
    gravity_max[x]=max(gravity_max[x],siz-gravity_size[x]);
    if(gravity==-1||gravity_max[gravity]>gravity_max[x])gravity=x;
}
void get_size(int x,int fa)
{
    ++siz;
    for(int i=g[x];i;i=e[i].next)
    {
        if(e[i].to!=fa&&!div_vis[e[i].to])
        {
            get_size(e[i].to,x);
        }
    }
}
void get_belone_data(int now,int fa,const int &Bl,const int &state,int dist)
{
    belone[now][state]=Bl;
    dis_to_gravity_fa[now][state]=dist;
    for(int i=g[now];i;i=e[i].next)
    {
        if(e[i].to!=fa&&!div_vis[e[i].to])
        {
            get_belone_data(e[i].to,now,Bl,state,dist+1);
        }
    }
    return;
}
void tree_div(int x,int deep,int pre_gravity)
{
    siz=0;
    get_size(x,-1);
    gravity=-1;
    get_gravity(x,-1);
    g_deep[gravity]=deep;
    div_fa[gravity]=pre_gravity;
    div_vis[gravity]=true;

    belone[gravity][deep]=gravity;

    dis_to_gravity_fa[gravity][deep]=0;
    spoint_cnt[gravity]=0;
    spoint_sum_dis[gravity]=0;
    for(int i=g[gravity];i;i=e[i].next)
    {
        get_belone_data(e[i].to,gravity,e[i].to,deep,1);
    }
    int nowg=gravity;
    for(int i=g[gravity];i;i=e[i].next)
    {
        if(!div_vis[e[i].to])
        {
            tree_div(e[i].to,deep+1,nowg);
        }
    }
    return;
}
void add_spoint(int x)
{
    int nowg=x;
    int nowdp=g_deep[x];
    nowans+=spoint_sum_dis[x];
    if(nowans>=mod)nowans-=mod;
    spoint_cnt[x]++;
    nowg=div_fa[nowg];
    --nowdp;
    while(nowg)
    {

        int belonfa=belone[x][nowdp];
        long long k=spoint_cnt[nowg]-sub_tree_spoint_cnt[belonfa][nowdp];
        nowans=(nowans+dis_to_gravity_fa[x][nowdp]*k%mod)%mod;
        long long delta=spoint_sum_dis[nowg]-sub_tree_spoint_sum[belonfa][nowdp];
        nowans=((nowans+delta)%mod+mod)%mod;
 
        //update
 
        spoint_cnt[nowg]++;
        sub_tree_spoint_cnt[belonfa][nowdp]++;
        spoint_sum_dis[nowg]+=dis_to_gravity_fa[x][nowdp];
        if(spoint_sum_dis[nowg]>=mod)spoint_sum_dis[nowg]-=mod;
        sub_tree_spoint_sum[belonfa][nowdp]+=dis_to_gravity_fa[x][nowdp];
        if(sub_tree_spoint_sum[belonfa][nowdp]>=mod)sub_tree_spoint_sum[belonfa][nowdp]-=mod;
 
        nowg=div_fa[nowg];
        --nowdp;
    }
    return;
}
 
void del_spoint(int x)
{
    int nowg=x;
    int nowdp=g_deep[x];
    nowans-=spoint_sum_dis[x];
    if(nowans<0)nowans+=mod;
    spoint_cnt[x]--;
    nowg=div_fa[nowg];
    --nowdp;
 
    while(nowg)
    {
        int belonfa=belone[x][nowdp];
        long long k=spoint_cnt[nowg]-sub_tree_spoint_cnt[belonfa][nowdp];
        nowans=((nowans-dis_to_gravity_fa[x][nowdp]*k%mod)%mod+mod)%mod;
        long long delta=spoint_sum_dis[nowg]-sub_tree_spoint_sum[belonfa][nowdp];
        nowans=((nowans-delta)%mod+mod)%mod;
 
        //update
 
        spoint_cnt[nowg]--;
        sub_tree_spoint_cnt[belonfa][nowdp]--;
        spoint_sum_dis[nowg]-=dis_to_gravity_fa[x][nowdp];
        if(spoint_sum_dis[nowg]<0)spoint_sum_dis[nowg]+=mod;
        sub_tree_spoint_sum[belonfa][nowdp]-=dis_to_gravity_fa[x][nowdp];
        if(sub_tree_spoint_sum[belonfa][nowdp]<0)sub_tree_spoint_sum[belonfa][nowdp]+=mod;
 
 
        nowg=div_fa[nowg];
        --nowdp;
    }
    return;
}
vector<pair<int,int> >op[MAXN];
char s[MAXN];
int x,pos,m;
int main()
{
    scanf("%d",&n);
    //树上版本应用于数组版本建图,实际中按真实的树连边建图
    for(int i=1;i<n;++i)
    {
        add_edge(i,i+1);
        add_edge(i+1,i);
    }
    tree_div(1,0,0);
    nowans=0;
    scanf("%s",s+1);
    for(int i=1;s[i];++i)
    {
        if(s[i]=='1')
        {
            add_spoint(i);
        }
    }
    printf("%lld\n",nowans);
    scanf("%d",&m);
    while(m--)
    {
        scanf("%d %d",&x,&pos);
        if(x==1)
        {
            add_spoint(pos);
        }
        else
        {
            del_spoint(pos);
        }
        printf("%lld\n",nowans);
    }
    return 0;
}
```

<div style="page-break-after:always;"></div>

# 整数分解与筛法

### 欧几里得算法

**问题:** 求正整数 $a$ , $b$ 的 $gcd$ . $1 \le a, b \le 10^9$ 

根据定义, 不妨考虑暴力算法, 复杂度为 $O(\min \{a, b\})$ , 太慢

**欧几里得算法 (辗转相除法)** 求最大公因数

**命题:** 设 $a$ , $b$ , $c$ 是任意三个不全为 $0$ 的整数, 满足存在整数 $q$ , $a = bq + c$ , 那么 $(a, b) = (b, c)$ 

```c++
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

复杂度: $O(\log (\min \{a, b\}))$ 

<br>

### 扩展欧几里得算法

不妨展开上述的递归过程:
$$
a = bq_1 + r_1 \\  
  b = r_1q_2 + r_2 \\
  r_1 = r_2q_3 + r_3 \\
  r_i = r_{i + 1}q_{i + 2} + r_{i + 2} \ (q \le i < k) \\
  \cdots \\
  r_{k - 1} = r_kq_{k + 1} + r_{k + 1} \\
  r_k = r_{k + 1}q_{k + 2} + r{k + 2}
$$
若 $r_{k + 2} = 0$ , 则 $r_{k + 1} = (a, b)$ 

**推论:** 若 $a$ , $b$ 是任意两个不全为 $0$ 的整数, 则存在整数 $x$ , $y$ , 使得 $ax + by = (a, b)$ 

```c++
int exgcd(int a, int b, int & x, int & y) {
    if(b == 0) return x = 1, y = 0, a;
    int r = exgcd(b, a % b, x, y);
    tie(x, y) = make_tuple(y, x - (a / b) * y);
    return r;
}
```

注意满足 $ax + by = (a, b)$ 的 $(x, y)$ 有无限多组, 假设 $(x_0, y_0)$ 是其中一组, 则所有解为 $(x_0 + k\dfrac{b}{(a, b)}, y_0 - k\dfrac{a}{(a, b)}), (k \in {\Bbb{Z}})$ 

<br>

### 整数分解

**定义:** 设 $p$ 为正整数, $p > 1$ , 如果 $p$ 的正因数只有 $1$ 及它本身, 则称 $p$ 为质数 (素数), 否则称 $p$ 为合数

**定理(算术基本定理):** 任一 $> 1$ 的整数 $a$ 能够唯一地写成 $a = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$  , 其中 $p_i$ 是质数, $\alpha_i > 0, i = 1 \dots k$ , 且 $p_i < p_j, (i < j)$ 

**问题:** 求 $1$ 到 $N$ 的所有质数 $(1 \le N \le 10^7)$ 

<br>

### 埃氏筛 (Sieve of Eratosthenes)

用质数把质数的倍数筛掉

```c++
const int maxn = 10000000;
bool not_prime[maxn + 5];
int prime[maxn + 5], tot = 0;
for(int i = 2; i <= n; i++) {
    if(!not_prime[i]) {
        prime[++tot] = i;
        for(int j = 2 * i; j <= n; j += i) {
            not_prime[j] = 1;
        }
    }
}
```

复杂度: $O(n \log (\log (n)))$​ 

<br>

### 欧拉筛 (Euler Sieve)

每个合数只需要被其最小的质因子筛掉

```c++
const int maxn = 10000000;
bool not_prime[maxn + 5];
int prime[maxn + 5], tot = 0;
for(int i = 2; i <= n; i++) {
    if(!not_prime[i]) prime[++tot] = i;
    for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
        not_prime[i * prime[j]] = 1;
        if(i % prime[j] == 0) break;
    }
}
```

复杂度: $O(n)$​ 

<br>

### 区间筛

**问题:** 对一段区间 $[a, b]$ $(a, b \le 10^{12}, b - a \le 10^6)$ 执行筛法

在埃氏筛的基础上, 只需要枚举 $[1, \sqrt{n}]$ 的所有质数, 就能把 $[1, n]$ 内的所有合数筛掉. 枚举 $[1, \sqrt{b}]$ 内的所有质数, 每次筛掉区间 $[a, b]$ 内的合数

```c++
const int N = 1000010;

//对区间[a, b]执行筛法
//isprime_seg[i - a] = true 表示 i 是素数
bool isprime_seg[N];
bool isprime_sqrtb[N];

//当a = 1时, 区间筛跑出来isprime_seg[1 - 1] = true(即把1视为素数,因此a=1时加上一个特判)
void get_prime(LL a, LL b)
{
    for(int i = 0; (LL)i * i <= b; i++)
        isprime_sqrtb[i] = true;
    for(int i = 0; i <= b - a; i++)
        isprime_seg[i] = true;
    for(int i = 2; (LL)i * i <= b; i++)
        if(isprime_sqrtb[i])
        {
            for(int j = 2 * i; (LL)j * j <= b; j += i)
                isprime_sqrtb[j] = false; //筛[2, sqrt(b)]
            for(LL j = max(2LL, (a + i - 1) / i) * i; j <= b; j += i)
                isprime_seg[j - a] = false; //筛[a, b]
        }
    if(a == 1)
        isprime_seg[0] = false;
}
```

<br>

### 质因数分解

**问题:** 求一个数 $n$ 的所有因数 $(1 \le n \le 10^{12})$ 

暴力: $O(\sqrt{n})$ 

```c++
vector <ll> fac;
for(int i = 1; i <= n / i; i++) {
    if(n % i == 0) {
        fac.push_back(i);
        if(n / i != i) fac.push_back(n / i);
    }
}
```

**问题:** 求一个数的所有**质因数** $(1 \le n \le 10^{12})$ 

暴力: 最坏 $O(\sqrt{n})$ 

```c++
vector <ll> p_fac;
for(int i = 1; i <= n / i; i++) {
    if(n % i == 0) {
        p_fac.push_back(i);
        while(n % i == 0) n /= i;
    }
}
if(n > 1) p_fac.push_back(n);
```

也可以预处理 $\sqrt{n}$ 内所有质数 $O(\sqrt{n})$ 

每次询问 $O(\sqrt{n} / \log (n))$ 

<br>

### 大整数的GCD

Stein 算法

+ 如果 $a = 0$ 或 $b = 0$ , 则 $(0, b) = b$ , $(a, 0) = a$ 
+ 如果 $a$ , $b$ 都是偶数, 则 $(a, b) = (a / 2, b / 2) \times 2$ 
+ 如果 $a$ 是偶数, $b$ 是奇数, 则 $(a, b) = (a / 2, b)$ 
+ 如果 $b$ 是奇数, $b$ 是偶数, 则 $(a, b) = (a, b / 2)$ 
+ 如果 $a$ , $b$ 都是奇数, 不妨设 $a > b$ , 则 $(a, b) = (b, a - b)$ 

复杂度: $O((\log (\max \{a, b\}))^2)$ 

```c++
//递归形式
int stein(int a, int b) {
    if(a < b) a ^= b, b ^= a, a ^= b;
    if(b == 0) return a;
    if((!(a & 1)) && (!(b & 1))) return stein(a >> 1, b >> 1) << 1;
    else if((a & 1) && (!(b & 1))) return stein(a, b >> 1);
    else if((!(a & 1)) && (b & 1)) return stein(a >> 1, b);
    else return stein(a - b, b);
}
```

```c++
//迭代形式
int stein(int a, int b) {
    int k = 1;
    while((!(a & 1)) && (!(b & 1))) {
        k <<= 1;
        a >>= 1;
        b >>= 1;
    }
    while(!(a & 1)) a >>= 1;
    while(!(b & 1)) b >>= 1;
    if(a < b) a ^= b, b ^= a, a ^= b;
    while(a != b) {
        a -= b;
        if(a < b) a ^= b, b ^= a, a ^= b;
    }
    return k * a;
}
```

<div style="page-break-after:always;"></div>

# 同余与模

### 模 m 等价类

**同余:** 设 $a$ , $b$ , $m$ 为三个整数. 其中 $m > 0$ , 如果满足 $a \% m = b \% m$ , 则称 $a$ 与 $b$ 对模 $m$ 同余, 记作 $a \equiv b \ (mod \ m)$ 

**等价类:** 令集合 ${\bf{i}} = \{x \ | \ x \equiv i \ (mod \ m) \}$ , $(i \in {\Bbb{Z}})$ 

假设 $j = i + m$ , 则 ${\bf{j}} = {\bf{i}}$ 

**等价类上的运算**

在 ${\Bbb{Z}}_m = \{0, 1, \dots, m - 1 \}$ 上定义两种运算 $+$ , $\times$ , 其中

+ ${\bf{a}} + {\bf{b}} = {\bf{c}}$ 当且仅当 $\forall a \in {\bf{a}}, b \in {\bf{b}}. a + b = c$​ 
+ ${\bf{a}} \times {\bf{b}} = {\bf{c}}$ 当且仅当 $\forall a \in {\bf{a}}, b \in {\bf{b}}. a \times b = c$ 

<br>

### 逆元

**逆元:** 如果 ${\bf{a}}, {\bf{b}} \in {\Bbb{Z}}_m$ , 满足 ${\bf{ab}} = 1$ , 则称 ${\bf{b}}$ 是 ${\bf{a}}$ 的逆元, 记作 ${\bf{a}}^{-1}$ 

**问题**

+ 判定在 ${\Bbb{Z}}_m$ 里, ${\bf{a}}$ 是否有逆元
+ 如果有, 如何求 ${\bf{a}}^{-1}$ 

$a \% m = b \% m$ $\Longrightarrow$ $ab = km + 1$ , 扩展欧几里得算法

+ ${\bf{a}}$ 在 ${\Bbb{Z}}_m$ 内有逆元, 当且仅当 $(a, m) = 1$ 
+ 如果 $m$ 为质数, 则任意 $0 < {\bf{a}} < m$ , ${\bf{a}} \in {\Bbb{Z}}_m$ 有逆

<br>

### 欧拉函数

**欧拉函数:** 定义欧拉函数 $\varphi(n)$ 为正整数 $n$ 与序列 $1, 2, \dots, n - 1, n$ 中互质的数的个数

设 $n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$ , 则 $\varphi(n) = (p_1 - 1)p_1^{\alpha_1 - 1} \times (p_2 - 1)p_2^{\alpha_2 - 1} \times \dots \times (p_k - 1)p_k^{\alpha_k - 1}$ 

求一项欧拉函数 (暴力求质因子的基础上略加修改)

```c++
ll get_phi(ll n) {
    ll phi = 1;
    for(int i = 2; i <= n / i; i++) {
        if(n % i == 0) {
            phi *= (i - 1);
            n /= i;
            while(n % i == 0) phi *= i, n /= i;
        }
    }
    if(n > 1) phi *= (n - 1);
    return phi;
}
```

求 $\varphi(1), \dots, \varphi(n)$ (欧拉筛的基础上略加修改)

```c++
const int maxn = 10000000;
bool not_prime[maxn + 5];
int prime[maxn + 5], tot = 0, phi[maxn + 5];
for(int i = 2; i <= n; i++) {
    if(!not_prime[i]) prime[++tot] = i, phi[i] = i - 1;
    for(int j = 1; j <= tot && i & prime[j] <= n; j++) {
        not_prime[i * prime[j]] = 1;
        if(i % prime[j] == 0) {
            phi[i * prime[j]] = phi[i] * prime[j];
            break;
        }
        phi[i * prime[j]] = phi[i] * (prime[j] - 1);
    }
}
```

<br>

### 逆元

**定理 (欧拉定理):** 如果 $(a, m) = 1$, 那么 $a^{\varphi(m)} = 1 \ (mod \ m)$ 

**定理 (费马小定理):** 设 $p$ 为质数, 如果 $p \nmid a$ , 那么 $a_{p - 1} \equiv 1 \ (mod \ p)$ 

设 $m$ 为正整数, ${\bf{a}} \in {\Bbb{Z}}_m$ , $(a, m) = 1$ , 逆元 ${\bf{a}}^{-1} = {\bf{a}}^{\varphi(m) - 1}$ 

设 $p$ 为质数, ${\bf{a}} \in {\Bbb{Z}}_p$ , $0 < a < p$ , 逆元 ${\bf{a}}^{-1} = {\bf{a}}^{p - 2}$ 

$O(n)$ 求 $1$ 到 $n$ 对于质数 $p(> n)$ 的逆元:

$\lfloor \dfrac{p}{i} \rfloor i + p \% i = p$ 

$\Rightarrow \lfloor \dfrac{p}{i} \rfloor i + p \% i \equiv 0 \ (mod \ p)$ 

$\Rightarrow i^{-1} \equiv -\lfloor \dfrac{p}{i} \rfloor (p \% i)^{-1} \ (mod \ p)$ 

注意 $-\lfloor \dfrac{p}{i} \rfloor$ 为负数, 但在模 $p$ 意义下, 其等价于 $p - \lfloor \dfrac{p}{i} \rfloor$ , 故在实际应用中真正的递推式为 $i^{-1} \equiv (p - \lfloor \dfrac{p}{i} \rfloor) \times (p \ mod \ i)^{-1} \ (mod \ p)$ 

```c++
const int N = 1000010;
int inv[N];

void get_inv(int n)
{
    inv[0] = 0, inv[1] = 1;
    for(int i = 2; i <= n; i++)
        inv[i] = (p - p / i) * inv[p % i] % p;
}
```

<br>

### 同余方程组

**问题:** 求方程组 $\left\{\begin{matrix} 
  x \equiv a_1 \ (mod \ m_1) \\  
  x \equiv a_2 \ (mod \ m_2) \\
  \cdots \\
  x \equiv a_k \ (mod \ m_k)
\end{matrix}\right. $ 的解

先考虑 $k = 2$ 的情况, $x = y_1m_1 + a_1 = y_2m_2 + a_2$ 

有解当且仅当 $(m_1, m_2) \mid a_1 - a_2$ 

解的形式为 $x \equiv x_0 \mod [m_1, m_2]$ 

<br>

### 同余方程组的构造解

**定理 (孙子定理)**

设 $m_1, m_2, \dots, m_k$ 是两两互质的 $k$ 个正整数, 

则方程组 $\left\{\begin{matrix} 
  x \equiv a_1 \ (mod \ m_1) \\  
  x \equiv a_2 \ (mod \ m_2) \\
  \cdots \\
  x \equiv a_k \ (mod \ m_k)
\end{matrix}\right. $ 的解为 $x \equiv \sum\limits_{i = 1}^{k} M_i'M_ia_i \ (mod \ M)$ 

其中 $M = m_1m_2\dots m_k$ , $M_i = M / m_i$ , $M_i'M_i \equiv 1 \ (mod \ m_i)$​ 

```c++
//中国剩余定理(CRT)模板
ll mod[15], yu[15], M = 1, ans; //mod[i]即为mi,yu[i]存放模后余数

void exGcd(ll a, ll b, ll &x, ll &y) {  
    if(b == 0) { x = 1, y = 0; return;}
    exGcd(b, a % b, y, x);         
    y -= a / b * x;
}

int main() {
    int n;
    cin >> n; //方程组数
    for (int i = 1; i <= n; ++i) {
        cin >> mod[i] >> yu[i]; //模数和余数，模数互质
        M * =mod[i];
    }
    for (int i = 1; i <= n; ++i) {
        ll Mi = M / mod[i], inv, y; //Mi为所有模数乘积除以第i个模数，inv为Mi在模mi意义下的逆元
        exGcd(Mi, mod[i], inv, y);
        inv = inv % mod[i];
        ans = (ans + yu[i] * Mi * inv) % M;
    }
    ans =  (ans + M) % M; //保证结果不出现负数
}
```

扩展中国剩余定理: 不需要满足 $m$ 两两互质

```c++
//扩展中国剩余定理(EXCPT)模板
ll n, mod[100009], yu[100009];

//要用快速乘(龟速乘), 防止爆long long
ll qMul(ll a, ll b, ll mo) {
    ll an = 0;
    while(b) {
        if(b & 1) an = (an + a) % mo;
        a = (a + a) % mo;
        b >>= 1;
    }
    return an % mo;
}

ll exGcd(ll a, ll b, ll &x, ll &y) {
    if(b == 0) { x = 1; y = 0; return a;}
    ll gcd = exGcd(b, a % b, y, x);
    y -=  a / b * x;
    return gcd;
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> mod[i] >> yu[i];
    ll ans = yu[1], M = mod[1], t, y; //ans表示前i-1个方程式的特解(余数), M为前i-1个方程式的模数的最小公倍数(i从2开始)
    for(int i = 2; i <= n; i++) {
        ll mi = mod[i], res = ((yu[i] - ans) % mi + mi) % mi; //res是等式的右边部分, 不能出现负数
        ll gcd = exGcd(M, mi, t, y); //求出gcd(mi,M)
        if(res % gcd != 0) { cout << -1 << endl; exit(0);} //如果等式右边不能整除gcd, 方程组无解
        t = qMul(t, res / gcd, mi); //求出t还要乘上倍数
        ans += t * M; //得到前i个方程的特解（余数）
        M = mi /gcd * M; //M等于lcm(M,mi), 注意乘法要在除法后面做，否则会爆long long
        ans = (ans % M + M) % M; 
    }
}
```

<br>

### 扩展欧拉定理

**定理 (扩展欧拉定理)**

$a^c \equiv a^{c \% \varphi(m) + \varphi(m)} \ (mod \ m)$ , $if \ c \ge \varphi(m)$ 

<div style="page-break-after:always;"></div>

# 简单排列和组合

### 加法和乘法原理

+ 加法原理: 做某件事情有几种选择, 每种选择的方案数之和就是做这件事情的方案数
+ 乘法原理: 做某件事情分为几步, 每步的方案数是独立的, 则它们的积就是这件事情的方案数

<br>

### 排列

**排列:** 设集合 $S$ 是一个 $n$ 元集, 序列 $a_1, a_2, \dots, a_r$ 满足 $a_i \in S$ , $(1 \le i \le r)$ , 且序列中的元素两两不同, 求有多少个这样的序列

几个符合: 

+ 下降幂: $n^{\underline{r}} = n \cdot (n - 1) \cdot (n - 1) \cdot \ldots \cdot (n - r + 1)$ 
+ 上升幂: $n^{\overline{r}} = n \cdot (n + 1) \cdot (n + 2) \cdot \ldots \cdot (n + r - 1)$ 
+ 阶乘: $n! = n \cdot (n - 1) \cdot \ldots \cdot 1$ , $0! = 1$ 

注: $n^{\underline{r}} = (n - r + 1)^{\overline{r}}$ 

<br>

### 组合

**组合:** 设集合 $S$ 是一个 $n$ 元集, 集合 $\{a_1, a_2, \cdots, a_r \}$ 满足 $a_i \in S$ , $(1 \le i \le r)$ , 求有多少个这样的集合

符号: 

+ 组合数: $\begin{pmatrix}  
  n \\  
  r  
  \end{pmatrix} = \dfrac{n^{\underline{r}}}{r!} = \dfrac{n!}{(n - r)!r!}$ 

常用式子: 

+ $\begin{pmatrix}  
  n \\  
  m  
  \end{pmatrix} = \begin{pmatrix}  
  n - 1 \\  
  m - 1  
  \end{pmatrix} + \begin{pmatrix}  
  n - 1 \\  
  m  
  \end{pmatrix}$ 
+ $\begin{pmatrix}  
  n \\  
  m  
  \end{pmatrix} = \dfrac{n}{m} \begin{pmatrix}  
  n - 1 \\  
  m - 1  
  \end{pmatrix}$ 
+ $\begin{pmatrix}  
  n \\  
  m  
  \end{pmatrix} = \dfrac{n - m + 1}{m}  \begin{pmatrix}  
  n \\  
  m - 1  
  \end{pmatrix}$ 

<br>

### 不定方程的解的数量

**问题:** 求不定方程 $x_1 + x_2 + \cdots x_k = n$ 的解的数量, 其中 $x_i$ 为整数, 且 $x_i \ge 1$ , $(1 \le i \le k)$ 

+ 隔板法

$k - 1$ 块板将 $n$ 个小球分成 $k$ 份 $\Longrightarrow$ $\begin{pmatrix}  
n - 1 \\  
k - 1  
\end{pmatrix}$ 

**变形1:** $x_i \ge 1$ 变成 $x_i \ge a_i$ 

换元: $x_i \ge a_i$ , 令 $y_i = x_i - (a_i - 1) \ge 1$ 

$y_1 + y_2 + \cdots y_k = n - \sum\limits_{i = 1}^{k} a_i + k$ $\Longrightarrow$ $\begin{pmatrix}  
n - \sum\limits_{i = 1}^{k} a_i + k - 1 \\  
k - 1  
\end{pmatrix}$

**变形2:** 求 $x_1 + x_2 + \cdots + x_k = n$ 的非负整数解的数量, 即 $x_i \ge 0$ 

即变形1中 $a_i = 0$ 的情形 $\Longrightarrow$ $\begin{pmatrix}  
n + k - 1 \\  
k - 1  
\end{pmatrix}$

**变形3:** 求 $x_1 + x_2 + \cdots + x_k \le n$ 的解的数量

即求解 $x_1 + x_2 + \cdots + x_k + z = n$ , $(z \ge 0)$ 的解的数量

<br>

### 网络路径计数

**问题:** 在 $n \times m$ 的网格图上, 从 $(0, 0)$ 走到 $(n, m)$ , 每次只能向右走或向上走, 求方案数

+ 动态规划: $f(i, j) = f(i - 1, j) + f(i, j - 1)$ 
+ 组合计数: $\begin{pmatrix}  
  n + m \\  
  m  
  \end{pmatrix}$

<div style="page-break-after:always;"></div>

# 容斥原理

### 容斥原理

**定理 (容斥原理(两个子集)):** 设 $S$ 是一个有限集, $A$ 和 $B$ 是 $S$ 的两个子集, 则 $|S - A \cup B| = |S| - |A| - |B| + |A \cap B|$ 

**定理 (容斥原理(三个子集)):** 设 $S$ 是一个有限集, $A$ , $B$ , $C$ 是 $S$ 的三个子集, 则 $|S - A \cup B \cup C| = |S| - |A| - |B| - |C| + |A \cap B| + |A \cap C| + |B \cap C| - |A \cap B \cap C|$ 

**定理 (容斥原理):** 设 $S$ 是一个有限集, $A_1, A_2, \cdots, A_n$ 是 $S$ 的 $n$ 个子集, 则 $|S - \bigcup\limits_{i = 1}^{n} A_i | = \sum\limits_{i = 0}^{n} (-1)^i \sum\limits_{1 \le j_1 < j_2 < \cdots < j_i \le n} | \bigcap\limits_{k = 1}^{i} A_{j_k}|$ 

<br>

### 不定方程的解的数量

**问题:** 求不定方程 $x_1 + x_2 + \cdots + x_k = n$ 的解的数量, 其中 $x_i$ 为整数, 且 $l_i \le x_i \le r_i$ , $(1 \le i \le k)$ 

令 $S = \{x_1 + x_2 + \cdots + x_k = n 的所有满足 x_i \ge l_i 的解 \}$ , $A_i = \{x_1 + x_2 + \cdots + x_k = n 的所有满足 x_i \ge r_i + 1 的解 \}$

则 $ans = |S - \bigcup\limits_{i = 1}^{k} A_i|$ 

对于 $|A_{j_1} \cap A_{j_2} \cap \cdots \cap A_{j_i}|$ , 即求满足对于任意 $p$ 从 $1$ ~ $n$ , 若 $p \in \{j_1, j_2, \cdots, j_i \}$ , 则 $x_p \ge r_p + 1$ , 若 $p \notin \{j_1, j_2, \cdots, j_i \}$ , 则 $x_p \ge l_p$ 的不定方程 $x_1 + x_2 + \cdots + x_k = n$ 的解的数量

<br>

### 错排问题

**问题:** $p$ 是 $1, 2, \cdots, n$ 的一个排列, 满足 $\forall 1 \le i \le n$ , $p_i \ne i$ , 给定 $n$ , 求满足要求的排列又多少个

令 $S = \{1, 2, \cdots, n 的全排列 \}$ , $A_i = \{满足 p_i = i 的排列 \}$ 

则 $ans = |S - \bigcup\limits_{i = 1}^{n}A_i| = \sum\limits_{i = 0}^{n}(-1)^i \begin{pmatrix}  
  n \\  
  i  
\end{pmatrix} (n - i)!$ 

$d(n) = \sum\limits_{i = 0}^{n}(-1)^i \begin{pmatrix}  
  n \\  
  i  
\end{pmatrix} (n - i)! = \sum\limits_{i = 0}^{n}(-1)^i \dfrac{n!}{i!(n - i)!}(n - i)! = \sum\limits_{i = 0}^{n}(-1)^i\dfrac{n!}{i!} = n! \sum\limits_{i = 0}^{n}\dfrac{(-1)^i}{i!}$ 

$O(n)$ 递推公式: $d(1) = 0, d(2) = 1$ , $d(i) = (i - 1)(d(i - 1) + d(i - 2))$ 

<br>

### 容斥原理的符号形式

设 $S$ 是一个有限集, $a_1, a_2, \cdots, a_n$ 是 $n$ 种性质

+ 记 $N(a_i)$ 为 $S$ 中有 $a_i$ 性质的元素的数量. 特殊的, 记 $N(1) = |S|$ 
+ 记 $N(1 - a_i)$ 为 $S$ 中没有 $a_i$ 性质的元素的数量
+ $N(a_{i_1}, a_{i_2}, \cdots, a_{i_k})$ 为 $S$ 中同时有 $a_{i_1}, a_{i_2}, \cdots, a_{i_k}$ 性质的元素的数量
+ 记 $N(a \pm b) = N(a) \pm + N(b)$ 

则容斥原理可以写成

$N((1 - a_1)(1 - a_2)\cdots(1- a_n)) = \sum\limits_{i = 0}^{n}(-1)^i \sum\limits_{1 \le j_1 < j_2 < \cdots < j_i \le n} N(a_{j_1}, a_{j_2}, \cdots, a_{j_i})$ 

$N(a_1\cdots a_x(1 - a_{x + 1})\cdots(1 - a_{x + n})) = \sum\limits_{i = 0}^{n}(-1)^i\sum\limits_{x \le j_1 < j_2 < \cdots < j_i \le x + n} N(a_1 \cdots a_xa_{j_1}\cdots a_{j_i})$ 

<br>

### 第二类斯特林数

**问题:** 有 $n$ 个互不相同的球, 放到 $k$ 个互不区分的盒子里, 每个盒子里至少要有一个球, 求方案数

+ 记号 $S_2(n, k)$ , $\begin{Bmatrix} n \\ k\end{Bmatrix}$​ 
+ 递推式 $\begin{Bmatrix} n \\ k\end{Bmatrix} = \begin{Bmatrix} n - 1 \\ k - 1\end{Bmatrix} + \begin{Bmatrix} n - 1 \\ k\end{Bmatrix}$
+ 容斥 $\begin{Bmatrix} n \\ k\end{Bmatrix} = \dfrac{1}{k!}\sum\limits_{i = 0}^{k}(-1)^i\begin{pmatrix}  
  k \\  
  i  
  \end{pmatrix}(k - i)^n$ 
+ 重要的公式 $n^m = \sum\limits_{k = 0}^{m} \begin{Bmatrix} m \\ k\end{Bmatrix} n^{\underline{k}}$ 

<div style="page-break-after:always;"></div>

# 积性函数

### 积性函数

**积性函数:** 如果函数 $f: {\Bbb{N}} \to {\Bbb{R}}$ , 满足对于任意一对互质的正整数 $p$ , $q$ , 都有 $f(pq) = f(p)f(q)$ , 则称 $f$ 为积性函数

积性函数的例子: 

+ $1(n) = 1$ 
+ $id(n) = n$ 
+ $\varepsilon(n) = [n = 1]$ 
+ $\varphi(n) = 1 \cdots n$ 中与 $n$ 互质的数的数量
+ $d(n) = n$ 的正因子的数量

**命题:** 如果 $f(n)$ , $g(n)$ 是积性函数, 则 $h(n) = f(n)g(n)$ 也是积性函数

设 $f$ 是积性函数, 假设 $n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$ , 则 $f(n) = f(p_1^{\alpha_1})f(p_2^{\alpha_2})\cdots f(p_k^{\alpha_k})$​ 

利用质因数分解求 $f(n)$ 

```c++
ll get_f(ll n) {
    ll ans = 1;
    for(int i = 2; i <= n / i; i++) {
        int cnt = 0;
        while(n % i == 0) cnt++, n /= i;
        ans *= f(i, cnt); //f(p, k) = f(p^k)
    }
    if(n > 1) ans *= f(n, 1);
    return ans;
}
```

利用欧拉筛求 $f(1), \cdots, f(n)$ 

```c++
f[1] = 1;
for(int i = 2; i <= n; i++) {
    if(!not_prime[i]) p[++tot] = i, cnt[i] = 1, f[i] = calc_f(i, 1);
    for(int j = 1; j <= tot && i * p[j] <= n; j++) {
        not_prime[i * p[j]] = 1;
        if(i % p[j] == 0) {
            cnt[i * p[j]] = cnt[i] + 1;
            f[i * p[j]] = f[i] / cala_f(p[j], cnt[i]) * calc_f(p[j], cnt[i] + 1);
            break;
        }
        cnt[i * p[j]] = 1;
        f[i * p[j]] = f[i] * calc_f(p[j], 1);
    }
}
```

<br>

### 莫比乌斯反演

+ 已知 $g(n)$ 的前缀和 $f(n) = \sum_{i = 1}^{n} g(i)$ , 则可以通过 $f$ 反求 $g$ , $g(n) = f(n) - f(n - 1)$ 
+ 已知 $g(n)$ 的因数和 $f(n) = \sum_{d | n} g(d)$ , 如何通过 $f$ 反求 $g$ 

**$\mu(n)$** 

$\mu(n) = \left\{\begin{matrix} 
  1, \quad \ if \ n = 1 \\
  (-1)^k, \ if \ n无平方因子且有 k 个质因子 \\  
  0, \quad \ if \ n 有平方因子
\end{matrix}\right.$ 

**定理 (莫比乌斯反演)**

设 $f: {\Bbb{N}} \to {\Bbb{R}}$ , $g: {\Bbb{N}} \to {\Bbb{R}}$ 是两个函数, 则 $f(n) = \sum\limits_{d|n} g(d) \Leftrightarrow g(n) = \sum\limits_{d|n} \mu(\dfrac{n}{d}) f(d)$ 

**定理 (莫比乌斯反演2)**

设 $f: {\Bbb{N}} \to {\Bbb{R}}$ , $g: {\Bbb{N}} \to {\Bbb{R}}$ 是两个函数, 且存在正整数 $N$ , 对于所有 $n > N$ , $f(n) = g(n) = 0$ , 则 $f(n) = \sum\limits_{\underset{m \le N}{n|m}} g(m) \Leftrightarrow g(n) = \sum\limits_{\underset{m \le N}{n|m}} \mu(\dfrac{m}{n})f(m)$ 

<br>

### 狄利克雷卷积

**狄利克雷卷积:** 设 $f: {\Bbb{N}} \to {\Bbb{R}}$ , $g: {\Bbb{N}} \to {\Bbb{R}}$ 是两个函数, 则它们的狄利克雷卷积为 $(f * g)(n) = \sum\limits_{d|n} f(d)g(\dfrac{n}{d})$ 

**命题:** 如果 $f(n)$ , $g(n)$ 是积性函数, 则 $h(n) = (f * g)(n)$ 也是积性函数

**定理:** $f = g * 1 \Longleftrightarrow g = f * \mu$ 

一些公式：

+ $\varepsilon = \mu * 1$ 
+ $id = \varphi * 1$ 
+ $\varphi = \mu * id$ 

**应用 （杜教筛）** 

求 $S_1(n) = \sum\limits_{i = 1}^{n} \mu(i)$ 和 $S_2(n) = \sum\limits_{i = 1}^{n}\varphi(i)$ 的值， $1 \le n \le 2^{31}$ 

莫比乌斯函数前缀和: 

由于 $\varepsilon = \mu * 1$ 

$1 = \sum\limits_{i = 1}^{n}\varepsilon(i) = \sum\limits_{i = 1}^{n}(\mu * 1)(i) = \sum\limits_{i = 1}^{n}\sum\limits_{d \mid i}\mu(d) = \sum\limits_{i = 1}^{n} S_1(\lfloor \dfrac{n}{i} \rfloor)$  

$S_1(n) = 1 - \sum\limits_{i = 2}^{n}S_1(\lfloor \dfrac{n}{i} \rfloor)$ 

欧拉函数前缀和: 

由于 $id = \varphi * 1$ 

$\dfrac{1}{2}n(n + 1) = \sum\limits_{i = 1}^{n}id(i) = \sum\limits_{i = 1}^{n}(\varphi * 1)(i) = \sum\limits_{i = 1}^{n}\sum\limits_{d \mid i}\varphi(d) = \sum\limits_{i = 1}^{n} S_2(\lfloor \dfrac{n}{i} \rfloor)$  

$S_2(n) = \dfrac{1}{2}n(n + 1) - \sum\limits_{i = 2}^{n}S_2(\lfloor \dfrac{n}{i} \rfloor)$ 

需要计算的 $S_1(i)$ 和 $S_2(i)$ 的数量是 $\log n$ 级别的, 通过整数分块进行处理

或由莫比乌斯反演: $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n}[gcd(i, j) = 1] = \sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n}\sum\limits_{d \mid i, d \mid j} \mu(d) = \sum\limits_{d = 1}^{n}\mu(d) \lfloor \dfrac{n}{d} \rfloor ^2$ 

$S_2(n) = [(\sum\limits_{d = 1}^{n}\mu(d) \lfloor \dfrac{n}{d} \rfloor ^2) + 1] \ / \ 2$ 

```c++
const int N = 2000010;
LL T, n, pri[N], cur, mu[N], sum_mu[N];
bool vis[N];
map<LL, LL> mp_mu;

LL S_mu(LL x)  // 求mu的前缀和
{
    if(x < N) return sum_mu[x];
    if(mp_mu[x]) return mp_mu[x];  // 如果map中已有该大小的mu值，则可直接返回
    LL ret = 1ll;
    for(LL i = 2, j; i <= x; i = j + 1) 
    {
        j = x / (x / i);
        ret -= S_mu(x / i) * (j - i + 1);
    }
    return mp_mu[x] = ret;  // 路径压缩，方便下次计算
}

LL S_phi(LL x)  // 求phi的前缀和
{
    LL ret = 0ll;
    for(LL i = 1, j; i <= x; i = j + 1)
    {
        j = x / (x / i);
        ret += (S_mu(j) - S_mu(i - 1)) * (x / i) * (x / i);
    }
    return (ret + 1) / 2;
}

int main() 
{
    cin >> T;
    mu[1] = 1;
    for(int i = 2; i < N; i++)  // 线性筛预处理mu数组
    {
        if(!vis[i]) 
        {
            pri[++cur] = i;
            mu[i] = -1;
        }
        for(int j = 1; j <= cur && i * pri[j] < N; j++) 
        {
            vis[i * pri[j]] = true;
            if(i % pri[j])
                mu[i * pri[j]] = -mu[i];
            else 
            {
                mu[i * pri[j]] = 0;
                break;
            }
        }
    }
    for(int i = 1; i < N; i++)
        sum_mu[i] = sum_mu[i - 1] + mu[i];  // 求mu数组前缀和
    while(T--) 
    {
      cin >> n;
      cout << S_phi(n) << ' ' << S_mu(n) << '\n';
    }
}
```

<br>

### 广义莫比乌斯反演

**定理** 

设 $(X, \le)$ 是下有限的偏序集, $f, g: X \to {\Bbb{R}}$ , 则

$f(x) = \sum\limits_{y \le x}g(y) \Leftrightarrow g(x) = \sum\limits_{y \le x}\mu(y, x)f(y)$ 

其中, $\mu(x, y)$ 满足

$\mu(x, y) = \left\{\begin{matrix} 
  1, \quad if \ x = y\\  
  -\sum\limits_{x \le z < y}\mu(x, z), \ if \ x < y 
\end{matrix}\right. $ 

<div style="page-break-after:always;"></div>

# 矩阵与高斯消元

### 矩阵

设 $K$ 为一个域 (如 ${\Bbb{R}}$ , ${\Bbb{C}}$ , ${\Bbb{F}}_p$ 等), 满足 $\forall 1 \le i, j \le n$ , $a_{ij} \in K$ 的数表
$$
A = \begin{pmatrix}  
  a_{11} & a_{12} & \cdots & a_{1n} \\  
  a_{21} & a_{22} & \cdots & a_{2n} \\
  \vdots & \vdots & & \vdots \\  
  a_{n1} & a_{n2} & \cdots & a_{nn}  
\end{pmatrix} 
$$
称为 $K$ 上的一个 $n$ 元矩阵

**矩阵乘法** 

假设 $A = (a_{ij})$ , $B = (b_{ij})$ 是两个 $n$ 元矩阵, 它们的乘积 $C = AB$ 也是一个 $n$ 元矩阵, $C = (c_{ij})$ , 满足 $c_{ij} = \sum\limits_{k = 1}^{n}a_{ik}b_{kj}$ 

**矩阵快速幂** 

```c++
int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while(k)
    {
        if(k & 1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}

class Array{
public:
    int n, m, a[N][N];
    Array(int _n, int _m) {
        n = _n, m = _m;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                a[i][j] = 0;
    }
    Array operator + (Array &B) {
        Array res(n, m);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                res.a[i][j] = (a[i][j] + B.a[i][j]) % mod;
        return res;
    }
    Array operator - (Array &B) {
        Array res(n, m);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                res.a[i][j] = ((a[i][j] - B.a[i][j]) % mod + mod) % mod;
        return res;
    }
    Array operator * (Array &B) {
        Array res(n, B.m);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= B.m; j++)
                for(int k = 1; k <= m; k++)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * B.a[k][j] % mod) % mod;
        return res;
    }
    void init() {   // 单位矩阵
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                a[i][j] = (i == j ? 1 : 0);
    }
    void debug() {
        cout << "Array(" << n << " x " << m << "):\n";
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                cout << a[i][j] << " \n"[j == m];
    }
    int sum() {     // 直接求元素和
        int res = 0;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                res = (res + a[i][j]) % mod;
        return res;
    }
    void read() {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                cin >> a[i][j];
    }
    Array inv() {   // 求逆矩阵
        Array B(n, n * 2);
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
                B.a[i][j] = a[i][j];
            B.a[i][i + n] = 1;
        }
        for(int i = 1, r; i <= n; i++)
        {
            r = i;
            for(int j = i + 1; j <= n; j++)
                if(B.a[j][i] > B.a[r][i]) r = j;
            if(r != i) swap(B.a[i], B.a[r]);
            
            int kk = qmi(B.a[i][i], mod - 2, mod); //求逆元 
            for(int k = 1; k <= n; k++)
            {
                if(k == i) continue;
                int p = B.a[k][i] * kk % mod;
                for(int j = i; j <= (n << 1ll); j++) 
                    B.a[k][j] = ((B.a[k][j] - p * B.a[i][j]) % mod + mod) % mod;
            } 
            for(int j = 1; j <= (n << 1ll); j++) 
                B.a[i][j] = (B.a[i][j] * kk % mod);
        }   
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                B.a[i][j] = B.a[i][j + n];
        B.m = n;
        return B;
    }
    int calc() {    // 求行列式
        Array B(n, n);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                B.a[i][j] = a[i][j];

        int sum = 1;
        for(int i = 1, r; i <= n; i++)
        {
            r = i;
            for(int j = i + 1; j <= n; j++)
                if(B.a[j][i] > B.a[r][i]) r = j;
            if(r != i)
            {
                swap(B.a[i], B.a[r]);
                sum *= -1;
            }
            
            int kk = qmi(B.a[i][i], mod - 2, mod); //求逆元 
            for(int k = n; k > i; k--)
            {
                int p = B.a[k][i] * kk % mod;
                for(int j = i; j <= n; j++) 
                    B.a[k][j] = ((B.a[k][j] - p * B.a[i][j]) % mod + mod) % mod;
            } 
        }   
        for(int i = 1; i <= n; i++)
            sum = ((sum * B.a[i][i]) % mod + mod) % mod;
        return sum;
    }
};
 
Array qmi(Array A, int b) {
    Array res(A.n, A.n);
    res.init();
    while (b) {
        if (b & 1) res = res * A;
        A = A * A;
        b = b >> 1;
    }
    return res;
}
```

**矩阵快速幂优化线性递推常见递推形式** 

+ $f(n) = a_1f(n - 1) + a_2f(n - 2) + \cdots + a_kf(n - k)$

$$
\begin{pmatrix}  
  f(n) \\  
  f(n - 1) \\
  f(n - 2) \\
  \vdots \\  
  f(n - k + 1) 
\end{pmatrix}  = \begin{pmatrix}  
  a_1 & a_2 & \cdots & a_{k - 1} & a_k \\  
  1 & 0 & \cdots & 0 & 0 \\
  0 & 1 & \cdots & 0 & 0 \\
  \vdots & \vdots & & \vdots & \vdots \\  
  0 & 0 & \cdots & 1 & 0  
\end{pmatrix} 
\begin{pmatrix}  
  f(n - 1) \\  
  f(n - 2) \\
  f(n - 3) \\
  \vdots \\  
  f(n - k) 
\end{pmatrix}
$$

+ $f(n) = a_1f(n - 1) + a_2f(n - 2) + C$ 

$$
\begin{pmatrix}  
  f(n) \\  
  f(n - 1) \\
  C
\end{pmatrix}  = \begin{pmatrix}  
  a_1 & a_2 & 1 \\  
  1 & 0 & 0 \\
  0 & 0 & 1  
\end{pmatrix} 
\begin{pmatrix}  
  f(n - 1) \\  
  f(n - 2) \\
  C
\end{pmatrix}
$$

$$
\begin{pmatrix}  
  f(n) \\  
  f(n - 1) \\
  1
\end{pmatrix}  = \begin{pmatrix}  
  a_1 & a_2 & C \\  
  1 & 0 & 0 \\
  0 & 0 & 1  
\end{pmatrix} 
\begin{pmatrix}  
  f(n - 1) \\  
  f(n - 2) \\
  1
\end{pmatrix}
$$



+ $f(n) = a_1f(n - 1) + a_2f(n - 2) + c_2n^2 + c_1n + c_0$ 

$$
\begin{pmatrix}  
  f(n) \\  
  f(n - 1) \\
  (n + 1)^2 \\
  n + 1 \\
  1
\end{pmatrix}  = \begin{pmatrix}  
  a_1 & a_2 & C_2 & c_1 & c_0 \\  
  1 & 0 & 0 & 0 & 0 \\
  0 & 0 & 1 & 2 & 1 \\
  0 & 0 & 0 & 1 & 1 \\
  0 & 0 & 0 & 0 & 1  
\end{pmatrix} 
\begin{pmatrix}  
  f(n - 1) \\  
  f(n - 2) \\
  n^2 \\
  n \\
  1
\end{pmatrix}
$$

+ $f(n) = a_{11}f(n - 1) + a_{12}g(n - 1)$ , $g(n) = a_{21}f(n - 1) + a_{22}g(n - 1)$ 

$$
\begin{pmatrix}  
  f(n) \\  
  g(n)
\end{pmatrix}  = \begin{pmatrix}  
  a_{11} & a_{12} \\
  a_{22} & a_{22}  
\end{pmatrix} 
\begin{pmatrix}  
  f(n - 1) \\  
  g(n - 1)
\end{pmatrix}
$$

<br>

### 线性基

**向量空间的基** 

向量空间中最大的线性无关组称为该向量空间的一组基

**线性基** 

一般指 ${\Bbb{Z}}_2^k$ 的一个子空间的基

```c++
using ull = unsigned long long;

ull p[64]; // 构造线性基

void insert(ull x)
{
    for(int i = 63; i; i--)
        if((x >> i) & 1)
        {
            if(!p[i])
            {
                p[i] = x;
                break;
            }
            x ^= p[i];
        }
}
```

**线性基的应用** 

+ 求一个集合 $S$ 中取一个子集异或得到所有数的数量

```c++
int cnt_xor() // 即求向量空间的大小
{
    int cnt = 0;
    for(int i = 0; i < 64; i++)
        if(p[i]) cnt ++;
    return cnt;
}
```

+ 求一个集合 $S$ 中取一个子集异或可以得到的最大/小值

```c++
int max_xor()
{
    int ans = 0;
    for(int i = 63; i >= 0; i--)
        ans = max(ans ^ p[i]);
    return ans;
}

int min_xor()
{
    if(cnt_xor() < n) return 0;
    for(int i = 0; i < 64; i++)
        if(p[i]) return p[i];
}
```

+ 求一个集合 $S$ 中取一个子集异或可以得到的第 $k$ 小值

```c++
vector<ull> p1;

void exchange()
{
    for(int i = 0; i < 64; i++)
    {
        for(int j = i - 1; j >= 0; j--)
            if((p[i] >> j) & 1)
                p[i] ^= p[j];
        if(p[i]) p1.push_back(p[i]);
    }
}

int min_k_xor(int k) // 求第 k 小
{
    int cnt = p1.size();
    if(cnt < n && k == 1) return 0;
    if(cnt < n) k --;
    if((1 << cnt) < k) return -1;

    int ans = 0;
    for(int i = 0; i < cnt; i++)
        if((k >> i) & 1)
            ans ^= p1[i];
    return ans;
}
```

+ 求一个集合 $S$ 中取一个子集异或是否可以得到 $x$ 

$(a_{b_1} \oplus a_{b_2} \oplus \cdots \oplus a_{b_k}) = x$ 等价于 $a_{b_1} \oplus a_{b_2} \oplus \cdots \oplus a_{b_k} \oplus x = 0$ 

即判断新的线性基的最小值是否为 $0$ 

<div style="page-break-after:always;"></div>

# 生成函数Ⅰ

### 形式幂级数

**多项式与形式幂级数** 

+ 多项式: $A(x) = \sum\limits_{i = 0}^{n}a_ix^i$ 
+ 形式幂级数: $A(x) = \sum\limits_{i \ge 0}a_ix^i$ 

其中 $a_i \in K$ , $K$ 是一个域, 通常, 我们考虑 $K = {\Bbb{R}}$ 或 $K = {\Bbb{Z}}_p$ 

注意这里的 $x$ 可以理解为一个独立于域 $K$ 的一个符号

**形式幂级数的运算** 

设 $A(x) = \sum\limits_{i \ge 0}a_ix^i$ , $B(x) = \sum\limits_{i \ge 0}b_ix^i$ 

+ 加法: $A(x) + B(x) = \sum\limits_{i \ge 0}(a_i + b_i)x^i$ 
+ 减法: $A(x) - B(x) = \sum\limits_{i \ge 0}(a_i - b_i)x^i$ 
+ 乘法: $A(x)B(x) = \sum\limits_{k \ge 0}(\sum\limits_{i + j = k}a_ib_j)x^k$ 

可以验证, 形式幂级数在以上定义的 $+$ , $-$ , $\times$ 下形成一个环

+ 记号: 记形式幂级数 (或多项式) $A(x)$ 的 $x^n$ 项的系数为 $[x^n]A(x)$ 

<br>

### 常生成函数

**定义** 

一个数列 $\{a_n\}$ 对应的常生成函数为 $A(x) = \sum\limits_{n \ge 0}a_nx^n$ 

**问题: 不定方程的解的数量** 

+ 求不定方程 $x_1 + x_2 + \cdots x_k = n$ 的解的数量, 其中 $x_i$ 为整数, 且 $l_i \le x_i \le r_i$ , $(1 \le i \le k)$ 

当 $k = 2$ 时, 求 $x_1 + x_2 = n$ 的解的数量

$F_1(x) = x^{l_1} + x_{l_1 + 1} + \cdots + x^{r_1} = \sum\limits_{j = l_1}^{r_1}x^j$ , $F_2(x) = \sum\limits_{j = l_2}^{r_2}x^j$ 

$F_{12}(x) = F_1(x) \cdot F_2(x)$ , $[x^n]F_{12}(x) = \sum\limits_{i + j = n}[x^i]F_1(x) \cdot [x^j]F_2(x)$ 

对 $k$ , $F_i(x) = \sum\limits_{j = l_i}^{r_i}x^j$ , $F(x) = \prod\limits_{i = 1}^{k}F_i(x) = F_1(x)F_2(x) \cdots F_k(x)$ 

不定方程的解的数量 $res = [x^n]F(x)$ 

+ 求 $x_1 + 2x_2 + 3x_3 = n$ 的正整数解的个数

$F_1(x) = \sum\limits_{i \ge 1}x^i = x + x^2 + x^3 + \cdots$ 

$F_2(x) = \sum\limits_{i \ge 1, \ 2 \mid i}x^i = x^2 + x^4 + x^6 + \cdots$ 

$F_3(x) = \sum\limits_{i \ge 1, \ 3 \mid i}x^i = x^3 + x^6 + x^9 + \cdots$ 

$F(x) = F_1(x) \cdot F_2(x) \cdot F_3(x)$ , $res = [x^n]F(x)$ 

**定理** 

设 $S = \{a_1, a_2, \cdots, a_k\}$ , 且 $a_i$ 可以取的次数的集合为 $M_i$ , 记 $F_i(x) = \sum\limits_{u \in M_i}x^u$ , 则从 $S$ 中取 $n$ 个元素组成集合的方案数 $g(n)$ 的常生成函数 $G(x) = \sum\limits_{i \ge 0}g(i)x^i$ , 满足 $G(x) = F_1(x)F_2(x)\cdots F_k(x)$ 

<br>

### 形式幂级数的逆元

+ 形式幂级数 $A(x)$ 的逆元: $A(x)B(x) = 1$ 
+ 逆元存在的条件: $[x^0]A(x) \ne 0$ 
+ 暴力计算的方法: 递推

常见的逆:

+ $A(x) = 1 + x + x^2 + \cdots$ 和 $B(x) = 1 - x$ , 即 $\dfrac{1}{1 - x} = \sum\limits_{i \ge 0}x^i$ 
+ $A(x) = 1 + ax + a^2x^2 + \cdots$ 和 $B(x) = 1 - ax$ , 即 $\dfrac{1}{1 - ax} =  \sum\limits_{i \ge 0}a^ix^i$ 
+ $A(x) = \binom{k - 1}{0} + \binom{k}{1}x + \binom{k + 1}{2}x^2 + \binom{k + 2}{3}x^3 + \cdots$ 和 $B(x) = (1 - x)^k$ , 即 $\dfrac{1}{(1 - x)^k} = \sum\limits_{i \ge 0}\binom{i + k - 1}{i}x^i$ 
+ $A(x) = 1 + x^2 + x^4 + \cdots$ 和 $B(x) = 1 - x^2$ , 即 $1 + x^2 + x^4 + \cdots = \dfrac{1}{1 - x^2}$ 
+ $A(x) = x + x^3 + x^5 + \cdots$ 和 $B(x) = \dfrac{1 - x^2}{x}$ , 即 $x + x^3 + x^5 + \cdots = \dfrac{x}{1 - x^2}$ 
+ $A(x) = 1 + x + x^2 + \cdots + x^k$ 和 $B(x) = \dfrac{1 - x}{1 - x^{k + 1}}$ , 即 $1 + x + x^2 + \cdots + x^k = \dfrac{1 - x^{k + 1}}{1 - x}$ 

<br>

### 递推关系

+ Fibonacci 数列满足: $F_0 = 0$ , $F_1 = 1$ , $F_n = F_{n - 1} + F_{n - 2} \ (n > 1)$ 

设 Fibonacci 数列的生成函数为 $F(x)$ 

$F(x) = a_0 + a_1x + a_2x^2 + \cdots a_nx^n + \cdots$ 

$\quad\quad\ = 0 + x + (a_0 + a_1)x^2 + (a_1 + a_2)x^3 + \cdots (a_{n - 2} + a_{n - 1})x^n + \cdots$ 

$F(x) = x^2F(x) + xF(x) + x$ 

$F(x) = \dfrac{x}{1 - x - x^2}$ 

设 $\dfrac{A}{1 - ax} + \dfrac{B}{1 - bx} = \dfrac{x}{1 - x - x^2}$ , 由待定系数法得
$$
\left\{\begin{matrix} 
  A = \dfrac{1}{\sqrt{5}} \\  
  B = -\dfrac{1}{\sqrt{5}} \\
  a = \dfrac{1 + \sqrt{5}}{2} \\
  b = \dfrac{1 - \sqrt{5}}{2}
\end{matrix}\right.
$$
$F(x) = \sum\limits_{n \ge 0} \dfrac{1}{\sqrt{5}}((\dfrac{1 + \sqrt{5}}{2})^n - (\dfrac{1 - \sqrt{5}}{2})^n)x^n$ 

$F_n = \dfrac{1}{\sqrt{5}}((\dfrac{1 + \sqrt{5}}{2})^n - (\dfrac{1 - \sqrt{5}}{2})^n)$ 

+ Lucas 数列满足: $L_0 = 2$ , $L_1 = 1$ , $L_n = L_{n - 1} + L_{n - 2} \ (n > 1)$ 

设 Lucas 数列的生成函数为 $L(x)$ 

$L(x) = x^2L(x) + xL(x) + 2 - x$ 

$L(x) = \dfrac{2 - x}{1 - x - x^2}$ 

设 $\dfrac{A}{1 - ax} + \dfrac{B}{1 - bx} = \dfrac{2 - x}{1 - x - x^2}$ , 由待定系数法得
$$
\left\{\begin{matrix} 
  A = 1 \\  
  B = 1 \\
  a = \dfrac{1 + \sqrt{5}}{2} \\
  b = \dfrac{1 - \sqrt{5}}{2}
\end{matrix}\right.
$$
$L(x) = \sum\limits_{n \ge 0} ((\dfrac{1 + \sqrt{5}}{2})^n + (\dfrac{1 - \sqrt{5}}{2})^n)x^n$ 

$L_n = (\dfrac{1 + \sqrt{5}}{2})^n + (\dfrac{1 - \sqrt{5}}{2})^n$ 

<br>

### Catalan 数

**问题** 

$n + 1$ 个数相乘 $x_0x_1x_2\cdots x_n$ , 求它们结合顺序的方案数. 如 $n = 3$ 时, 有 $5$ 种方案: $x_0(x_1(x_2x_3))$ , $x_0((x_1x_2)x_3)$ , $(x_0x_1)(x_2x_3)$ , $(x_0(x_1x_2))x_3$ , $((x_0x_1)x_2)x_3$ 

+ 递推公式: $c_0 = 1$ , $c_1 = 1$ 

  $c_n = c_0c_{n - 1} + c_1c_{n - 2} + \cdots + c_{n - 1}c_0$ 

+ 生成函数: $C(x) = \dfrac{1 - \sqrt{1 - 4x}}{2x}$ 

+ 通项公式: $c_n = \dfrac{1}{n + 1}\binom{2n}{n}$ 

<br>

### 指数生成函数

**定义**

一个数列 $\{a_n\}$ 对应的指数生成函数为 $A(x) = \sum\limits_{n \ge 0}a_n \dfrac{x^n}{n!}$ 

**定理** 

设 $S = \{a_1, a_2, \cdots, a_k\}$ , 且 $a_i$ 可以取的次数的集合为 $M_i$ , 记 $F_i(x) = \sum\limits_{u \in M_i}\dfrac{x^u}{u!}$ , 则从 $S$ 中取 $n$ 个元素排成一排的方案数 $g(n)$ 的指数生成函数 $G(x) = \sum\limits_{i \ge 0}g(i)\dfrac{x^i}{i!}$ , 满足 $G(x) = F_1(x)F_2(x)\cdots F_k(x)$ 

**公式 (定义)** 

+ $exp(x) = 1 + x + \dfrac{x^2}{2!} + \cdots = \sum\limits_{n \ge 0} \dfrac{x^n}{n!}$ 
+ $exp(ax) = 1 + ax + a^2\dfrac{x^2}{2!} + \cdots = \sum\limits_{n \ge 0}a^n \dfrac{x^n}{n!}$ 

<div style="page-break-after:always;"></div>

# FFT与拉格朗日插值

### 背景

+ 计数问题利用生成函数的方法转化为形式幂级数的代数计算问题
+ 假设 $C(x) = A(x) + B(x)$ 或 $A(x)B(x)$ 或 $\sqrt{A(x)}$ 等形式, $C(x)$ 的前 $n + 1$ 项的系数 $c_0, c_1, \cdots, c_n$ 仅仅需要 $A(x)$ , $B(x)$ 的前 $n + 1$ 项系数就可以计算
+ 多项式 $A(x)$ , $B(x)$ $\ mod$ $x^{n + 1}$ 替代形式幂级数 $A(x)$ , $B(x)$ 
+ 朴素多项式乘法、求逆、开根号等的复杂度为 $O(n^2)$ 
+ FFT / NTT 可以 $O(n \log(n))$ 内实现两个 $n$ 次多项式的乘积

<br>

### 多项式的表示形式

**系数表示与点值表示** 

假设 $f(x)$ 是一个 $n$ 次多项式, 则 $f(x)$ 的系数表示为 $f(x) = a_nx^n + a_{n - 1}x^{n - 1} + \cdots + a_0$ . $f(x)$ 的点值表示为 $(x_0, f(x_0))$ , $(x_1, f(x_1))$ , $\cdots$ , $(x_n, f(x_n))$ 

+ $n + 1$ 个点值可以表示一个 $n$ 次多项式
+ 在点值表示下 $n$ 次多项式的乘法复杂度为 $O(n)$ 

### 复数与单位根

**复数的指数形式** 

$a + bi = re^{i\theta}$ , 其中 $r = \sqrt{a^2 + b^2}$ , $tan(\theta) = \dfrac{b}{a}$ 

**单位根** 

$x^n = 1$ 在复数域上的根称为 $n$ 次单位根. $n$ 次单位根有 $n$ 个, 形式为 $\omega_n^k = e^{i \frac{2k\pi}{n}}$ 

**单位根的形式** 

+ $\omega_n^k = \omega_{2n}^{2k}$ 
+ $\omega_{2n}^{k + n} = -\omega_{2n}^k$ 

<br>

### FFT (快速傅里叶变换)

**DFT (离散傅里叶变换)** : 将多项式 $A(x) = a_0 + a_1x + \cdots + a_{n - 1}x^{n - 1}$ 转化为其点值形式 $(\omega_n^k, A(\omega_n^k)), \ (k = 0, 1, \cdots, n - 1)$ 

不妨假设 $n = 2^l$ , 设

$B(x) = a_0 + a_2x + \cdots + a_{n - 2}x^{n / 2 - 1}$ 

$C(x) = a_1 + a_3x + \cdots + a_{n - 1}x^{n / 2 - 1}$ 

则 $A(x) = B(x^2) + xC(x^2)$ 

对于 $k = 0, 1, \cdots, n / 2 - 1$ , 

$A(\omega_n^k) = B(\omega_{n / 2}^k) + \omega_n^kC(\omega_{n / 2}^k)$ 

$A(\omega_n^{k + n / 2}) = B(\omega_{n / 2}^k) - \omega_n^kC(\omega_{n / 2}^k)$ 

+ 分治 (递归, 常数大)
+ 蝴蝶变换 (非递归, 常数小)

```c++
// oi-wiki 递归版FFT
#include <cmath>
#include <complex>

typedef std::complex<double> Comp;  // STL complex

const Comp I(0, 1);  // i
const int MAX_N = 1 << 20;

Comp tmp[MAX_N];

// rev=1,DFT; rev=-1,IDFT
void DFT(Comp* f, int n, int rev) {
  if (n == 1) return;
  for (int i = 0; i < n; ++i) tmp[i] = f[i];
  // 偶数放左边，奇数放右边
  for (int i = 0; i < n; ++i) {
    if (i & 1)
      f[n / 2 + i / 2] = tmp[i];
    else
      f[i / 2] = tmp[i];
  }
  Comp *g = f, *h = f + n / 2;
  // 递归 DFT
  DFT(g, n / 2, rev), DFT(h, n / 2, rev);
  // cur 是当前单位复根，对于 k = 0 而言，它对应的单位复根 omega^0_n = 1。
  // step 是两个单位复根的差，即满足 omega^k_n = step*omega^{k-1}*n，
  // 定义等价于 exp(I*(2*M_PI/n*rev))
  Comp cur(1, 0), step(cos(2 * M_PI / n), sin(2 * M_PI * rev / n));
  for (int k = 0; k < n / 2;
       ++k) {  // F(omega^k_n) = G(omega^k*{n/2}) + omega^k*n\*H(omega^k*{n/2})
    tmp[k] = g[k] + cur * h[k];
    // F(omega^{k+n/2}*n) = G(omega^k*{n/2}) - omega^k_n*H(omega^k\_{n/2})
    tmp[k + n / 2] = g[k] - cur * h[k];
    cur *= step;
  }
  for (int i = 0; i < n; ++i) f[i] = tmp[i];
}
```

```c++
// oi-wiki 位逆序置换实现 (O(n log n))
/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 * len 必须为 2 的幂
 */
void change(Complex y[], int len) {
  // 一开始 i 是 0...01，而 j 是 10...0，在二进制下相反对称。
  // 之后 i 逐渐加一，而 j 依然维持着和 i 相反对称，一直到 i = 1...11。
  for (int i = 1, j = len / 2, k; i < len - 1; i++) {
    // 交换互为小标反转的元素，i < j 保证交换一次
    if (i < j) swap(y[i], y[j]);
    // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的。
    // 这里 k 代表了 0 出现的最高位。j 先减去高位的全为 1 的数字，直到遇到了
    // 0，之后再加上即可。
    k = len / 2;
    while (j >= k) {
      j = j - k;
      k = k / 2;
    }
    if (j < k) j += k;
  }
}
```

```c++
// oi-wiki 位逆序置换实现 (O(n))
// 同样需要保证 len 是 2 的幂
// 记 rev[i] 为 i 翻转后的值
void change(Complex y[], int len) {
  for (int i = 0; i < len; ++i) {
    rev[i] = rev[i >> 1] >> 1;
    if (i & 1) {  // 如果最后一位是 1，则翻转成 len/2
      rev[i] |= len >> 1;
    }
  }
  for (int i = 0; i < len; ++i) {
    if (i < rev[i]) {  // 保证每对数只翻转一次
      swap(y[i], y[rev[i]]);
    }
  }
  return;
}
```

<br>

**IDFT (逆离散傅里叶变换)** : 将多项式的点值表示 $(\omega_n^k, b_k), \ (k = 0, 1, \cdots, n - 1)$ 转化为其系数表示 $A(x) = a_0 + a_1x + \cdots + a_{n - 1}x^{n - 1}$ 

设 $n \times n$ 的矩阵 $\Omega$ , 其中 $\Omega_{i, j} = \omega_n^{ij}$ , 设向量 **a** $= (a_0, a_1, \cdots, a_{n - 1})$ ,  **b** $= (b_0, b_1, \cdots, b_{n - 1})$ , 则 IDFT 相当于求解方程 $\Omega$**a** = **b**

令 $\bar{\Omega}$ 为满足 $\bar{\Omega}_{i, j} = \omega_n^{-ij}$ , 有 $\bar{\Omega}\Omega = nl$ , 因此 **a** $= \dfrac{1}{n}\bar{\Omega}$**b** 

相当于给定 $B(x) = b_0 + b_1x + \cdots + b_{n - 1}x^{n - 1}$ , 求点值 $B(\omega_n^{-k}), \ (0 \le k < n)$ 

```c++
// oi-wiki 非递归版FFT(对应方法一)
/*
 * 做 FFT
 * len 必须是 2^k 形式
 * on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
  // 位逆序置换
  change(y, len);
  // 模拟合并过程，一开始，从长度为一合并到长度为二，一直合并到长度为 len。
  for (int h = 2; h <= len; h <<= 1) {
    // wn：当前单位复根的间隔：w^1_h
    Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));
    // 合并，共 len / h 次。
    for (int j = 0; j < len; j += h) {
      // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
      // ...
      Complex w(1, 0);
      for (int k = j; k < j + h / 2; k++) {
        // 左侧部分和右侧是子问题的解
        Complex u = y[k];
        Complex t = w * y[k + h / 2];
        // 这就是把两部分分治的结果加起来
        y[k] = u + t;
        y[k + h / 2] = u - t;
        // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
        // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
        // 一个数相反数的平方与这个数自身的平方相等
        w = w * wn;
      }
    }
  }
  // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
  if (on == -1) {
    for (int i = 0; i < len; i++) {
      y[i].x /= len;
    }
  }
}
```

```c++
// oi-wiki 非递归版FFT(对应方法二)
/*
 * 做 FFT
 * len 必须是 2^k 形式
 * on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
  change(y, len);
  for (int h = 2; h <= len; h <<= 1) {             // 模拟合并过程
    Complex wn(cos(2 * PI / h), sin(2 * PI / h));  // 计算当前单位复根
    for (int j = 0; j < len; j += h) {
      Complex w(1, 0);  // 计算当前单位复根
      for (int k = j; k < j + h / 2; k++) {
        Complex u = y[k];
        Complex t = w * y[k + h / 2];
        y[k] = u + t;  // 这就是把两部分分治的结果加起来
        y[k + h / 2] = u - t;
        // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
        // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
        // 一个数相反数的平方与这个数自身的平方相等
        w = w * wn;
      }
    }
  }
  if (on == -1) {
    reverse(y + 1, y + len);
    for (int i = 0; i < len; i++) {
      y[i].x /= len;
    }
  }
}
```

```c++
// oi-wiki FFT模板 (HDU 1402 - A*B Problem Plus)
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>

const double PI = acos(-1.0);

struct Complex {
  double x, y;

  Complex(double _x = 0.0, double _y = 0.0) {
    x = _x;
    y = _y;
  }

  Complex operator-(const Complex &b) const {
    return Complex(x - b.x, y - b.y);
  }

  Complex operator+(const Complex &b) const {
    return Complex(x + b.x, y + b.y);
  }

  Complex operator*(const Complex &b) const {
    return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
  }
};

/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 *len 必须为 2 的幂
 */
void change(Complex y[], int len) {
  int i, j, k;

  for (int i = 1, j = len / 2; i < len - 1; i++) {
    if (i < j) std::swap(y[i], y[j]);

    // 交换互为小标反转的元素，i<j 保证交换一次
    // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
    k = len / 2;

    while (j >= k) {
      j = j - k;
      k = k / 2;
    }

    if (j < k) j += k;
  }
}

/*
 * 做 FFT
 *len 必须是 2^k 形式
 *on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
  change(y, len);

  for (int h = 2; h <= len; h <<= 1) {
    Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));

    for (int j = 0; j < len; j += h) {
      Complex w(1, 0);

      for (int k = j; k < j + h / 2; k++) {
        Complex u = y[k];
        Complex t = w * y[k + h / 2];
        y[k] = u + t;
        y[k + h / 2] = u - t;
        w = w * wn;
      }
    }
  }

  if (on == -1) {
    for (int i = 0; i < len; i++) {
      y[i].x /= len;
    }
  }
}

const int MAXN = 200020;
Complex x1[MAXN], x2[MAXN];
char str1[MAXN / 2], str2[MAXN / 2];
int sum[MAXN];

int main() {
  while (scanf("%s%s", str1, str2) == 2) {
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    int len = 1;

    while (len < len1 * 2 || len < len2 * 2) len <<= 1;

    for (int i = 0; i < len1; i++) x1[i] = Complex(str1[len1 - 1 - i] - '0', 0);

    for (int i = len1; i < len; i++) x1[i] = Complex(0, 0);

    for (int i = 0; i < len2; i++) x2[i] = Complex(str2[len2 - 1 - i] - '0', 0);

    for (int i = len2; i < len; i++) x2[i] = Complex(0, 0);

    fft(x1, len, 1);
    fft(x2, len, 1);

    for (int i = 0; i < len; i++) x1[i] = x1[i] * x2[i];

    fft(x1, len, -1);

    for (int i = 0; i < len; i++) sum[i] = int(x1[i].x + 0.5);

    for (int i = 0; i < len; i++) {
      sum[i + 1] += sum[i] / 10;
      sum[i] %= 10;
    }

    len = len1 + len2 - 1;

    while (sum[len] == 0 && len > 0) len--;

    for (int i = len; i >= 0; i--) printf("%c", sum[i] + '0');

    printf("\n");
  }

  return 0;
}
```

<br>

### FFT 模板题

**A \* B  Problem Plus (HDU 1402)** : 求 $A \times B$ , 其中 $A$ , $B$ 的长度不超过 $5000$ 

$A = a_n \cdot 10^n + \cdots + a_i \cdot 10^i \cdots + a_1 \cdot 10 + a_0$ 

$B = b_m \cdot 10^m + \cdots + b_j \cdot 10^j + \cdots + b_1 \cdot 10 + b_0$ 

令 $A(x) = a_nx^n + a_{n - 1}x^{n - 1} + \cdots + a_0$ , $B(x) = b_mx^m + b_{m - 1}x^{m - 1} + \cdots + b_0$ 

$C(x) = A(x)B(x)$ 

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 200010;
const double PI = acos(-1.0);

struct Complex { // 复数
    double x, y;

    Complex(double _x = 0.0, double _y = 0.0) {
        x = _x;
        y = _y;
    }

    Complex operator-(const Complex &b) const {
        return Complex(x - b.x, y - b.y);
    }

    Complex operator+(const Complex &b) const {
        return Complex(x + b.x, y + b.y);
    }

    Complex operator*(const Complex &b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};

/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 *len 必须为 2 的幂
 */
void change(Complex y[], int len) {
    int i, j, k;

    for (int i = 1, j = len / 2; i < len - 1; i++) {
        if (i < j) swap(y[i], y[j]);

        // 交换互为小标反转的元素，i<j 保证交换一次
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
        k = len / 2;

        while (j >= k) {
            j = j - k;
            k = k / 2;
        }

        if (j < k) j += k;
    }
}

/*
 * 做 FFT
 *len 必须是 2^k 形式
 *on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
    change(y, len); // 蝴蝶变换

    for (int h = 2; h <= len; h <<= 1) {
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));

        for (int j = 0; j < len; j += h) {
            Complex w(1, 0);

            for (int k = j; k < j + h / 2; k++) {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }

    if (on == -1) {
        for (int i = 0; i < len; i++) {
            y[i].x /= len;
        }
    }
}

int n, m;
string A, B;
Complex a[N], b[N], c[N];
int sum[N]; 

void solve()
{
    n = A.size(), m = B.size();
    int len = 1;
    // FFT 要求 len 是 2 的幂次
    while(len < n * 2 || len < m * 2)
        len <<= 1;

    for(int i = 0; i < n; i++)
        a[i] = Complex(A[n - i - 1] - '0', 0);
    for(int i = n; i < len; i++)
        a[i] = Complex(0, 0);
    for(int i = 0; i < m; i++)
        b[i] = Complex(B[m - i - 1] - '0', 0);
    for(int i = m; i < len; i++)
        b[i] = Complex(0, 0);

    // DFT 将 A, B 从系数表示转化为点值表示
    fft(a, len, 1);
    fft(b, len, 1);

    // 计算 C(x) = A(x)B(x) 的点值表示
    for(int i = 0; i < len; i++)
        c[i] = a[i] * b[i];

    // IDFT 将 C 从点值表示转化为系数表示
    fft(c, len, -1);

    // 计算 C(10) 的值
    for(int i = 0; i < len; i++)
        sum[i] = int(c[i].x + 0.5);
    int t = 0;
    for(int i = 0; i < len; i++)
    {
        sum[i] += t;
        t = sum[i] / 10;
        sum[i] %= 10;
    }

    len --;
    // 去除前导零
    while(len > 0 && sum[len] == 0)
        len --;
    for(int i = len; i >= 0; i--)
        cout << sum[i];
    cout << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    while(cin >> A)
    {
        cin >> B;
        solve();
    }

    return 0;
}
```

<br>

### 拉格朗日插值

**拉格朗日插值定理** 

$n$ 个点值 $(x_i, y_i)$ , $(1 \le i \le n)$ , 满足 $x_i \ne y_i$ , $(i \ne j)$ , 它们唯一确定一个 $n - 1$ 次多项式 $f(x)$ , $f(x) = \sum\limits_{i = 1}^ny_i\prod\limits_{j \ne i}\dfrac{x - x_j}{x_i - x_j}$ 

+ 暴力实现: 先计算 $g(x) = \prod\limits_{i = 1}^n(x - x_i)$ , 再求 $n$ 次 $g(x) / (x - x_i)$ , 按照权值和将它们相加. $O(n^2)$ 
+ 特殊情况1: 只需要求一个 $f(x_0)$ . $O(n^2)$ 
+ 特殊情况2: 只需要求一个 $f(x_0)$ , 且 $x_i = i$ . $O(n)$ , 前缀积优化

<div style="page-break-after:always;"></div>

# 原根与NTT

### 阶与原根

**欧拉定理** 

若正整数 $m$ , $a$ , 满足 $(a, m) = 1$ , 则 $a^{\varphi(m)} \equiv 1\ (mod \ m)$ 

**阶** 

若正整数 $m $, $a$ , 满足 $(a, m) = 1$ , 则使得 $a^n \equiv 1 \ (mod \ m)$ 的最小正整数 $n$ 称为 $a$ 模 $m$ 的阶, 记作 $\delta_m(a)$ 

**原根** 

若 $\delta_m(a) = \varphi(m)$ , 则称 $a$ 为 $m$ 的一个原根

<br>

### 阶的性质

假设 $(a, m) = 1$ , $\delta = \delta_m(a)$ , 则

+ $a^0, a^1, \cdots, a^{\delta - 1}$ 在模 $m$ 意义下两两不同
+ $a^{\gamma} \equiv a^{\gamma'} \ (mod \ m) \Leftrightarrow \gamma \equiv \gamma' \ (mod \ \delta)$ 
+ $\delta \mid \varphi(m)$ 

<br>

### 原根的存在与判定

**定理 (原根的存在定理)** 

一个数 $m$ 存在原根当且仅当 $m = 2, 4, p^{\alpha}, 2p^{\alpha}$ , 其中 $p$ 为奇素数, $\alpha \in N^*$ 

**定理 (原根的判定定理)** 

设 $m > 1$ , $g$ 为正整数且 $(g, m) = 1$ . 则 $g$ 是 $m$ 的原根当且仅当对于任意 $\varphi(m)$ 的质因子 $q_i$ , $g^{\frac{\varphi(m)}{q_i}} \not \equiv 1 \ (mod \ m)$ 

```c++
// 暴力求原根
bool check(int x)
{
    if(x == 2 || x == 4) return true;
    if(!(x & 1)) x >>= 1;
    if(!(x & 1)) return false;
    for(int i = 2; i <= x / i; i++)
        if(x % i == 0)
        {
            while(x % i == 0) x /= i;
            return (x == 1);
        }
    return true;
}

int get_phi(int x)
{
    int res = x;
    for(int i = 2; i <= x / i; i++)
        if(x % i == 0)
        {
            res = res / i * (i - 1);
            while(x % i == 0) x /= i;
        }
    if(x > 1) res = res / x * (x - 1);
    return res;
}

vector<int> get_primes(int x)
{
    vector<int> primes;
    for(int i = 2; i <= x / i; i++)
        if(x % i == 0)
        {
            primes.push_back(i);
            while(x % i == 0) x /= i;
        }
    if(x > 1) primes.push_back(x);
    return primes;
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int qmi(int m, int k, int p)
{
    int res = 1;
    while(k)
    {
        if(k & 1) res = (long long)res * m % p;
        m = (long long)m * m % p;
        k >>= 1;
    }
    return res;
}

vector<int> get_primitive_roots(int n)
{
    vector<int> primitive_roots;
    if(!check(n)) return primitive_roots;
    int phi_n = get_phi(n);
    vector<int> q = get_primes(phi_n);

    for(int g = 1; g < n; g++)
    {
        if(gcd(g, n) != 1) continue;
        bool flag = true;
        for(auto v: q)
            if(qmi(g, phi_n / v, n) == 1)
            {
                flag = false;
                break;
            }
        if(flag) primitive_roots.push_back(g);
    }
    return primitive_roots;
}
```

```c++
// 优化: 先求出 n 的最小原根 g, n 的所有原根都能由 g 累乘若干次得到
vector<int> get_primitive_roots(int n)
{
    vector<int> primitive_roots;
    if(!check(n)) return primitive_roots;
    int g = get_min_primitive_root(n); // 最小原根
    for(int i = 1, mul = g; (int)primitive_roots.size() < phi[phi[n]]; i++, mul = (long long)mul * g % n)
        if(gcd(i, phi[n]) == 1) primitive_roots.push_back(mul);
    sort(primitive_roots.begin(), primitive_roots.end());
    return primitive_roots;
}
```

<br>

### BSGS

```c++
// 求 a * x = b (mod m) 的解	
ll modequ(ll a, ll b, ll m) {	//等价于ax+my=b
	ll x, y;
	ll d = exgcd(a, m, x, y);	// ax+my=gcd(a,m);
	if (b % d != 0) return -1;
	m /= d; a /= d; b /= d;		//a'x+m'y=d'   x=x*d' y=y*d'
	x = x * b % m;
	if (x < 0) x += m;
	return x;
}


// 求解指数方程  a^x ≡ b (mod m) 最小x
// 复杂度为O(sqrt(m)) 用map多一个log
ll Coprime_BSGS(ll a, ll b, ll m){	// 要求: gcd(a, m)==1
	// a^(T*q) = b*a^r (mod m)
	assert(__gcd(a, m)==1);
	int T = sqrt(m)+2;
	ll v = ksm(a, T, m);
	unordered_map<ll,ll> mp;
	ll cur = 1;
	For(q,1,T){
		cur = cur*v%m;
		if(!mp.count(cur)) mp[cur] = q;
	}
	ll ans = m+1;
	cur = b;
	For(r,1,T){
		cur = cur*a%m;
		if(mp.count(cur)){
			ans = min(mp[cur]*T-r, ans);
		}
	}
	if(ans >= m)return -1;
	return ans;
}
ll BSGS(ll a, ll b, ll m){	// (a, m)可以不互质
	// a^x = b (mod m)
	// a^M * a^(x-M) = b (mod m)
	// 要让 m/gcd(a^M, m) 与 a 互质, 大概是log
	// gcd(a^M,m) = gcd(a^M%m, m)	模掉自己gcd不变
	if(b==1)return 0;
	ll cur = 1, M = 30;
	For(i,1,M){
		cur = cur*a%m;
		if(cur==b) return i;
	}
	int g = __gcd(cur, m);
	if(b % g != 0)return -1;// 无解
	cur /= g, m /= g, b /= g;
	a %= m;
	b = modequ(cur, b, m);
	ll x = Coprime_BSGS(a, b, m);
	if(x == -1)return -1;
	return x + M;
}
```

<div style="page-break-after:always;"></div>

# KMP

### 基础定义

**字符串** 

$S$ : 无特殊说明, 字符串仅由 $26$ 个小写字母 `a` - `z` 构成, 并用大写字母表示一个字符串

$|S|$ : 表示一个字符串的长度

$S[i]$ : 表示字符串 $S$ 第 $i$ 个位置的字母, 下标从 $1$ 开始

<br>

**子串** 

$S[l, r]$ : 表示字符串 $S$ 从 $l$ 到 $r$ 个字母顺次连接而成的新字符串

$Prefix_S[i]$ : 表示字符串 $S$ 的长度为 $i$ 的前缀, $Prefix_S[i] = S[1, i]$ 

$Suffix_S[i]$ : 表示字符串 $S$ 的长度为 $i$ 的后缀, $Suffix_S[i] = S[|S| - i + 1, |S|]$ 

<br>

### 重要定义

**Border** 

如果字符串 $S$ 的同长度的前缀和后缀完全相同, 即 $Prefix[i] = Suffix[i]$ , 则称此前缀 (后缀) 为一个 $Border$ 

特殊地, 字符串本身也可以是它的 $Border$ 

<br>

**周期和循环节** 

对于字符串 $S$ 和正整数 $p$ , 如果有 $S[i] = S[i - p]$ , 对于 $p < i \le |S|$ 成立, 则称 $p$ 为字符串 $S$ 的一个周期

特殊地, $p = |S|$ 一定是 $S$ 的周期

若字符串 $S$ 的周期 $p$ 满足 $p \ | \ | S|$ , 则称 $p$ 为 $S$ 的一个循环节

特殊地, $p = |S|$ 一定是 $S$ 的循环节

<br>

### 重要性质

**Border vs 周期** 

$p$ 是 $S$ 的周期 $\Longleftrightarrow$ $|S| - p$ 是 $S$ 的 $Border$ 

字符串的周期性质等价于 $Border$ 性质, 求周期也等价于求 $Border$ 

==警告: **Border** 不具有二分性== 

<br>

### Border 的 Naive 求法

**暴力** 

枚举 $1 \le i \le |S|$ , 暴力验证是否有 $Preffix[i] == Suffix[i]$ 

复杂度 $O(N^2)$ 

<br>

**优雅的暴力** 

使用 $Hash$ 验证 $Prefix[i] == Suffix[i]$ 

复杂度 $O(N)$ , 常数很大, 容易构造 $Hash$ 冲突

<br>

### Border 的性质

**传递性** 

$S$ 的 $Border$ 的 $Border$ 也是 $S$ 的 $Border$ 

**求 $S$ 的所有 $Border$ 等价于求所有前缀的最大 $Border$ **

<br>

### KMP

**Next 数组**

$next[i] = Preffix[i]$ 的非平凡的最大 $Border$ 

$next[1] = 0$ 

考虑 $Prefix[i]$ 的所有 (长度大于 $1$ 的) $Border$ , 去掉最后一个字母, 就会变成 $Prefix[i - 1]$ 的 $Border$ 

因此求 $next[i]$ 的时候, 可以遍历 $Prefix[i - 1]$ 的所有 $Border$ , 即 $next[i - 1]$ , $next[next[i - 1]]$ , $\cdots$ , $0$ , 检查后一个字符是否等于 $S[i]$ 

<br>

**复杂度分析** 

考虑使用势能分析进行讨论:

+ 如果 $next[i] = next[i - 1] + 1$ , 则势能会增加 $1$ 
+ 否则势能会先减少到某个 $next[j]$ , 然后有 $next[i] = next[j] + 1$ , 势能也会增加 $1$ , 在寻找 $next[j]$ 的过程中, 势能会减少, 每次至少减少 $1$ 
+ 还有一种情况, $next[i] = 0$ , 势能清空, 且不会增加

综上, 势能总量为 $O(N)$ , 因此整体的复杂度也是 $O(N)$ , 常数为 $2$ 左右(很小), 空间复杂度也为 $O(N)$ 

<br>

**代码** 

```c++
void init(char* ss){
    len = strlen(ss+1);
    memcpy(t,ss,(len+2)*sizeof(char));
    for (int i=2;i<=len;i++){
        nxt[i] = nxt[i-1];
        while (nxt[i]&&ss[i]!=ss[nxt[i]+1]) nxt[i] = nxt[nxt[i]];
        nxt[i]+=(ss[i]==ss[nxt[i]+1]);
    }
}
```

<br>

### 字符串匹配

**Naive 的匹配** 

枚举起始位置, 然后暴力匹配. 复杂度 $O(N^2)$ 

<br>

**优雅的暴力** 

枚举起始位置, 然后用 $Hash$ 检查. 复杂度 $O(N)$ , 常数极大. 字符集很大时的处理比较繁琐

<br>

**KMP 匹配** 

$KMP$ 充分例用前缀匹配的有效信息, 即 $next$ 数组 ($Border$ 的性质), 进行快速转移

当遇到匹配失败的字符时, 只需要考虑 $Border$ 所有的长度即可, 非 $Border$ 长度一定不会匹配的更 "远"

<br>

**KMP 匹配的复杂度分析** 

使用 $KMP$ 进行字符串匹配时, 利用势能分析, 不难看出总势能为 $|S|$ , 再加上预处理 $T$ 的 $next$ 数组, 复杂度为 $O(|S| + |T|)$ 

<br>

**代码** 

```c++
 /* 求所有在ss串中的start_pos. 如果first_only设置为true，则只返回第一个位置*/
vector<int> match(char *ss,bool first_only = false){
    int len_s = strlen(ss+1);
    vector<int> start_pos(0);
    for (int i=1,j=1;i<=len_s;){
        while (j!=1 && ss[i] != t[j])j = nxt[j-1]+1;
        if (ss[i] == t[j]) j++,i++;
        else i++;
        if (j == len+1){
            start_pos.push_back(i-j+1);
            if (first_only)return start_pos;
            j = nxt[len]+1;
        }
    }
    return start_pos;
}
```

<br>

### 拓展

**Border 的性质** 

周期定理: 若 $p$ , $q$ 均为串 $S$ 的周期, 则 $gcd(p, q)$ 也为 $S$ 的周期

一个串的 $Border$ 数量是 $O(N)$ 个, 但他们组成了 $O(\log N)$ 个等差数列

<br>

**KMP 的推广** 

拓展 KMP (a.k.a Z 算法)

KMP 自动机, Border 树

AC 自动机, 即 KMP 的多串模式

Trie 图, 即 KMP 自动机的多串模式

<br>

### Border 树

**定义** 

对于一个字符串 $S$ , $n = |S|$ , 它的 **Border 树** (也叫 next 树) 共有 $n + 1$ 个节点: $0, 1, 2, \cdots, n$ 

**0** 是这棵有向树的根. 对于其他每个点 $1 \le i \le n$ , 父节点为 $next[i]$ 

![Border树](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\字符串专题\Border树.png)

**性质**

1. 每个前缀 $Prefix[i]$ 的所有 Border: 节点 $i$ 到根的链
2. 哪些前缀有长度为 $x$ 的 Border: $x$ 的子树
3. 求两个前缀的公共 Border 等价于求 LCA

<div style="page-break-after:always;"></div>

# Hash

### Hash 定义

**定义**

Hash 是一种单射函数, 可以将万物**单向**映射成一个整数值

字符串 Hash 就是指将一个字符串映射成一个整数值的方法, 通常用来快速比较两个字符串是否相等

约定: $H(S)$ 表示一个字符串 $S$ 通过 Hash 算法映射成的整数值

<br>

**性质** 

+ 必要性: 若字符串 $S = T$ , 则一定有 $H(S) = H(T)$ 
+ 非充分性: 若 $H(S) = H(T)$ , 不一定有 $S = T$ 

<br>

### Hash 检测

**Hash 检测** : 通过 $H(S)$ 和 $H(T)$ 是否相等, 来判断 $S$ 和 $T$ 是否相等的方法

Hash 冲突 : $H(S) = H(T)$ , 但 $S \ne T$ , 即为发生了 Hash 冲突

**<font color='red'> Hash 检测时发生 Hash 冲突的概率是衡量 Hash 算法好坏的重要指标 </font>**

<br>

### 设计 Hash 算法

**多项式 Hash** 

将字符串看作是某个进制 (Base) 下的数字串

$H(S) = \sum\limits_{i = 1}^{i \le |S| = n} S[i] * Base^{n - i} = H(S[1, |S| - 1]) * Base + S[|S|]$ 

$\quad\quad\ \ = S[1] * Base^{n - 1} + S[2] * Base^{n - 2} + \cdots + S[n] * Base^0$ 

优点: 字符串和 Hash 值一一对应, 不会发生 Hash 冲突

缺点: 数字范围过大, 难以用原始数据结构存储和比较

<br>

**多项式取模 Hash (模哈)** 

模哈是为了解决多项式 Hash 的缺点, 在效率和冲突率之间进行的折衷: 将多项式 Hash 的值对一个较大的质数取模

$H'(S) = H(S) \% Mod = (\sum\limits_{i = 1}^{i \le |S| = n} S[i] * Base^{n - i}) \% Mod$ 

$\quad\quad\ \  = (S[1] * Base^{n - 1} + S[2] * Base^{n - 2} + \cdots + S[n] * Base^0) \% Mod$ 

优点: 使得多项式 Hash 可以用原始数据结构 (uint / ulong) 存储和比较

缺点: 会有小概率发生 Hash 冲突

<br>

**模哈冲突概率** 

模哈冲突是指: $H(S) \ne H(T)$ 但 $H(S) \% Mod = H(T) \% Mod$ 

模运算可以看作一个均匀随机散列, 即每个 $H(S)$ 会被随机的映射成 $[0, Mod)$ 内的整数

根据生日悖论, 当检验次数超过 $\sqrt{Mod}$ 时, 就会有较大概率发生错误, 因此, **在模哈中使用的 Mod 最好超过 Hash 检验次数的平方**

<br>

### Hash 的三种姿势

**自然溢出** : 使用 `ULL` 保存 Hash 值, 利用硬件特性, 使 Hash 值自然溢出, 即实现模数为 $2^{64}$ , 但容易构造 Hash 冲突

**质数模哈 (单模)** : 选取 $10^9$ 到 $10^{10}$ 范围内的大质数作为 Hash 模数, 但也有广为人知的方法构造冲突

**双模 (多模)** : 进行多次不同质数的单模哈希, 有效降低冲突概率. 在不泄露模数的前提下, 没有已知方法可以构造冲突

<br>

优秀的 Hash 模数应满足: 足够大、质数

一些比较好的 Hash 素数: `53` , `97` , `193`, `389` , `769` , `1543` , `3079` , `6151` , `12289` , `24593` , `49157` , `98317` , `196613` , `393241` , `786433` , `1572869` , `3145739` , `6291469` , `12582917` , `25165843` , `50331653` , `100663319` , `201326611` , `402653189` , `805306457` , `1610612741` 

<br>

### 子串 Hash

$H(S[l, r]) = (S[l] * Base^{r - l} + S[l + 1] * Base^{(r - l - 1)} + \cdots + S[r]) \% Mod$ 

令 $F(i) = H(Prefix[i])$ 

$F(l - 1) = (S[1] * Base^{l - 2} + S[2] * Base^{l - 3} + \cdots + S[l - 1]) \% Mod$ 

$F(r) = (S[1] * Base^{r - 1} + S[2] * Base^{r - 2} + \cdots S[r]) \% Mod$ 

因此, $H(S[l, r]) = F(r) - F(l - 1) * Base^{r - l + 1}$ 

<br>

**代码** 

```c++
void init(){
    for (int i=1;i<=n;i++){
        sum[i] = (sum[i-1]*Seed%Mod+s[i])%Mod;
    }
    
    bas[0] = 1;
    for (int i = 1; i <= n; i++){
        bas[i] = bas[i - 1] * Seed % Mod;
    }
}

ULL getHash(int l,int r){
    return (sum[r]-sum[l-1]*bas[r-l+1]%Mod+Mod)%Mod;
}
```

<div style="page-break-after:always;"></div>

# Trie, Border 树

### 问题背景

**字典** : 一个字符串的集合称为字典

**字典串** : 在字典中的串称为字典串

在处理字符串的时候, 常会遇到这样的简单问题: 给出一个字典, 然后回答大量询问: 输入一个字符串, 判断它是否在字典中

<br>

### Trie

**定义** 

Trie 是一棵有根树, 每个点至多有 $|\sum|$ 个后继边, 每条边上有一个字符. 每个点表示一个前缀: 从根到这个点的边上的字符顺次连接形成的字符串

每个点还有一个终止标记: 是否这个点代表的字符串是一个字典串

可以支持向 Trie 插入新字典串, 删除字典串, 查询某个字符串是否是字典串, 以及一些稍微复杂的查询

作为一个数据结构, 它理所应当的还可以进行持久化

<br>

**代码**

```c++
struct Trie {
    int nxt[maxn][26], fail[maxn];
    // the node I should go when append a character
    int Go[maxn][26];
    int root = 0;
    int cnt = 0;
    void clear(){
        root = cnt = 0;
        memset(nxt[0],0,sizeof nxt[0]);
    }
    int newnode() {
        cnt++;
        //clear memory
        return cnt;
    }
    void insert(char *s) {
        int now = root;
        while (*s){
            now = insert(now,*s - 'a');
            s ++;
        }
    }
    int insert(int pre, int ch) {
        return nxt[pre][ch] ? nxt[pre][ch] : nxt[pre][ch] = newnode();
    }
    void build() {
        queue<int> Q;
        Q.push(0);
        memcpy(Go[0],nxt[0],sizeof nxt[0]);
        while (!Q.empty()) {
            int head = Q.front();
            Q.pop();
            for (int ch = 0; ch < 26; ch++) {
                int v = nxt[head][ch];
                if (!v) continue;
                if (head == 0) fail[v] = 0;
                else fail[v] = Go[fail[head]][ch];
                memcpy(Go[v],Go[fail[v]],sizeof Go[v]);
                for (int cc = 0; cc < 26; cc++) {
                    if (nxt[v][cc]) Go[v][cc] = nxt[v][cc];
                }
                Q.push(v);
            }
        }
    }
}trie;
```

<br>

### Border 树 (失配树)

**定义** 

对于一个字符串 $S$ , $n = |S|$ , 它的 **Border 树** (也叫 next 树) 共有 $n + 1$ 个节点: $0, 1, 2, \cdots, n$ 

**0** 是这棵有向树的根. 对于其他每个点 $1 \le i \le n$ , 父节点为 $next[i]$ 

![Border树](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\字符串专题\Border树.png)

**性质**

1. 每个前缀 $Prefix[i]$ 的所有 Border: 节点 $i$ 到根的链
2. 哪些前缀有长度为 $x$ 的 Border: $x$ 的子树
3. 求两个前缀的公共 Border 等价于求 LCA

<br>

### AC 自动机

AC 自动机 = Trie + Border 树

<div style="page-break-after:always;"></div>

# AC 自动机, Trie 图

### 问题背景

**背景** 

给出一个字典, 和若干询问: 多少个字典串在询问串中出现过. 即单串与多串的匹配问题

<br>

**暴力算法** 

**KMP 的打法** 

将问题看作是: 每个字典串与询问串的单模式匹配

缺点: 字典串形成了孤岛, 没有打通链路, 形成闭环, 导致复杂度很高

**Trie 的打法** 

利用字典树进行多模式匹配

缺点: 不能够在失配时进行合理的跳转, 盲目尝试, 导致复杂度很高

<br>

### AC 自动机

**AC 自动机 = Trie + KMP** 

AC 自动机基于 Trie, 将 KMP 的 Border 概念推广到多模式串上

AC 自动机是一种离线型数据结构, 即不支持增量添加新的字符串

AC 自动机常用于将字符串询问类的问题进行离线处理, 也经常与各种 DP 结合, 或是补全成 Trie 图

<br>

**border 概念的推广** 

**推广到两个串** : 对于两个串 $S$ 和 $T$ , 相等的 $p$ 长度的 $S$ 的后缀和 $T$ 的前缀称为一个 Border

**推广到一个字典** : 对于串 $S$ 和一个字典 $D$ , 相等的 $p$ 长度的 $S$ 的后缀, 和任意一个字典串 $T$ 的前缀称为一个 Border

**<font color='red'> 失配 (Fail) 指针 : </font>** 对于 Trie 中的每一个节点 (即某个字典串的前缀), 它与 Trie 中所有串的最大 Border 即为失配指针

<br>

**失配指针** 

类似于 KMP 求 Border , 任意节点的 Border 长度减一, 一定是父节点的 Border . 因此可以通过遍历父节点的失配指针链来求解

因此在求失配指针的时候, 一定要按长度从小到大来求, 即 bfs

<br>

**复杂度分析** 

类似于 KMP 的势能分析方法, 势能总量等于 Trie 的节点总数, 因此复杂度为线性的

<br>

### Trie 图

将 AC 自动机中跳 Fail 链的复杂度优化掉

求 $trans[u][ch]$ 时:

1. 如果 $u$ 节点有 $ch$ 后继边, 则 $trans[u][ch] = nxt[u][ch]$ 
2. 否则, $trans[u][ch] = trans[Fail[u]][ch]$ 

<br>

**代码** 

```c++
struct Trie {
    int nxt[maxn][26], fail[maxn];
    // the node I should go when append a character
    int Go[maxn][26];
    int root = 0;
    int cnt = 0;
    void clear(){
        root = cnt = 0;
        memset(nxt[0],0,sizeof nxt[0]);
    }
    int newnode() {
        cnt++;
        //clear memory
        return cnt;
    }
    void insert(char *s) {
        int now = root;
        while (*s){
            now = insert(now,*s - 'a');
            s ++;
        }
    }
    int insert(int pre, int ch) {
        return nxt[pre][ch] ? nxt[pre][ch] : nxt[pre][ch] = newnode();
    }
    void build() {
        queue<int> Q;
        Q.push(0);
        memcpy(Go[0], nxt[0], sizeof nxt[0]);
        while (!Q.empty()) {
            int head = Q.front();
            Q.pop();
            for (int ch = 0; ch < 26; ch++) {
                int v = nxt[head][ch];
                if (!v) continue;
                if (head == 0) fail[v] = 0;
                else fail[v] = Go[fail[head]][ch];
                memcpy(Go[v], Go[fail[v]], sizeof Go[v]);
                for (int cc = 0; cc < 26; cc++) {
                    if (nxt[v][cc]) Go[v][cc] = nxt[v][cc];
                }
                Q.push(v);
            }
        }
    }
}trie;
```

<div style="page-break-after:always;"></div>

# Manacher, PAM

### 回文串

**定义** 

**反转串 $R(S)$** : 一个字符串 $S = S[1]S[2]\cdots S[n]$ , 其反转串为 $R(S) = S[n]S[n - 1]\cdots S[1]$ 

**回文串** : 满足 $S = R(S)$ 的串为回文串

**回文中心** : 

1. 奇 (长度) 回文串, 回文中心为 $S[\frac{n + 1}{2}]$ , 如 $ab$<font color='red'>$c$</font>$ba$
2. 偶 (长度) 回文串, 回文中心为 $S[\frac{n}{2}]$ 与 $S[\frac{n}{2} + 1]$ 中间, 如 $abc$<font color='red'>$|$</font>$cba$

**回文半径 L** : 回文中心到回文串的左右端点的距离相等, 此距离称为回文半径

如 $ab$<font color='red'>$c$</font>$ba$ 半径为 $3$ , $abcd$<font color='red'>$|$</font>$dcba$ 半径为 $4$ 

常用二元组 < **回文中心** , **回文半径** > 来表示一个回文子串

<br>

**性质** 

**长度与半径的关系** :

1. 奇回文串: $|S| = 2L - 1$ 
2. 偶回文串: $|S| = 2L$ 

**回文半径的二分性** : 半径 $-1$ 等价于同时删掉回文串的首尾字母, 依然是回文串

**回文串和 Border** : 对于回文串 $S$ , 回文前 (后) 缀<font color='red'>等价于</font> Border

<br>

### Manacher

**复杂度分析**

每次暴力匹配一定伴随着最右回文串右端点 $R$ 的右移, 因此复杂度为线性

<br>

**用法** 

1. 求每个回文中心的回文半径
2. 求本质不同回文串: 在 Manacher 中, 新的回文串一定出现在使得最右串右移的时候. 因此本质不同回文串至多 $n$ 个, 把所有更新最右回文串去重即得到本质不同回文串

<br>

**代码** 

```c++
char s[MAX];
struct Manacher{
    int lc[MAX];
    char ch[MAX];
    int N;
    Manacher(char *s){init(s);manacher();}
    /* s 1 bas */
    void init(char *s){
        int n = strlen(s+1);
        ch[n*2 +1] = '#';
        ch[0] = '@';
        ch[n*2 +2] = '\0';
        for (int i=n;i>=1;i--){
            ch[i*2] = s[i];ch[i*2 -1] = '#';
        }
        N = 2* n +1;
    }
    void manacher(){
        lc[1]=1;  int k=1;
        for (int i=2;i<=N;i++){
            int p = k+lc[k]-1;
            if (i<=p){
                lc[i]=min(lc[2*k-i],p-i+1);
            }else{  lc[i]=1;  }
            while (ch[i+lc[i]]==ch[i-lc[i]])lc[i]++;
            if (i+lc[i]>k+lc[k])k=i;
        }
    }
    void debug(){
        puts(ch);
        for (int i=1;i<=N;i++){
            printf("lc[%d]=%d\n",i,lc[i]);
        }
    }
};
int main(){
    scanf("%s",s+1);
    Manacher manacher(s);
    manacher.debug();
    return 0;
}
```

<br>

### PAM

**定义** 

Palindrome Automaton (回文自动机, 回文树) 是一种能够识别所有回文子串的数据结构, 结构十分类似于 ACAM

+ 节点: 节点数至多 $N$ 个, 每个节点代表了一种回文串. 用 $S(u)$ 表示节点 $u$ 代表的回文串. $len[u] = |S(u)|$ 
+ 后继边: 每个后继边上有一个字母. 用 $trans(u, ch) = v$ 表示 $u$ 节点有后继边 $ch$ 指向 $v$ 节点. 则有 $S(v) = $ **ch** $S(u)$ **ch** , 以及 $len[v] = len[u] + 2$ 
+ 失配边: 每个节点都有一个失配边, 用 $fail[u] = v$ 表示 $u$ 节点的失配边指向了 $v$ 节点. 则有 $S(v)$ 是 $S(u)$ 的最大 Border, 即最长回文后缀

<br>

**PAM 的构造** 

PAM 在构造时, 实际上就是求每个前缀的最长回文后缀, 方法是枚举前一个位置的回文后缀, 即 fail 链

PAM 特殊之处在于: 对于奇回文串和偶回文串需要有两个根节点. 由于长度为 $2$ 的回文串是偶根的后继节点, 长度为 $1$ 的回文串是奇根的后继节点

因此偶根长度应设为 $0$ , 奇根应该设为 $-1$ 

<br>

**复杂度分析** 

使用 AC 自动机完全相同的势能分析方法, 即可得知时间复杂度为线性. 后继边至多 $N$ 条, 朴素数组存边空间复杂度为 $|S| \cdot |\sum|$ . Hash 表存边可以做到线性, 和期望 $O(1)$ 随机访问

如果字符集太大, 可以用 Map 或者手写线段树存边

<br>

### 拓展姿势

**Palindrome Series** 

用于解决枚举回文后缀的 DP : 

由于回文串的特殊性质, 回文串的回文后缀一定是 Border. 所以枚举回文后缀等价于枚举最大回文后缀的 Border, 而 Border 具有良好的等差数列性质, PAM 的 Fail 链接就是 Border 链接

因此: Palindrome Series = PAM + Border Series

<br>

**CF 932G** 

Given a string $s$ , find the number of ways to split $s$ to substrings such that if there are $k$ substrings $(p_1, p_2, p_3, \cdots, p_k)$ in partition, then $p_i = p_{k - i + 1}$ for all $i$ $(1 \le i \le k)$ and $k$ is even.

Since the number of ways can be large, print it modulo $10^9 + 7$ .

The only line of input contains a string $s$ $(2 \le |s| \le 10^6)$ of even length consisting of lowercase Latin letters.

Print one integer, the number of ways of partitioning the string modulo $10^9 + 7$ .

```markdown
abcdcdab
1

abbababababbab
3
```

<br>

**代码**

```c++
// 优化DP转移：枚举所有回文后缀转移
// 使用时，只需要修改3行TBD
struct Palindromic_AutoMaton{
    int s[maxn],now;
    int nxt[maxn][26],fail[maxn],l[maxn],last,tot;
    int diff[maxn],anc[maxn],g[maxn],f[maxn];
    void clear(){
        //1节点：奇数长度root 0节点：偶数长度root
        s[0] = l[1] = -1;
        fail[0] = tot = now =1;
        last = l[0] = 0;
        memset(nxt[0],0,sizeof nxt[0]);
        memset(nxt[1],0,sizeof nxt[1]);
    }
    Palindromic_AutoMaton(){clear();}
    int newnode(int len){
        tot++;
        memset(nxt[tot],0,sizeof nxt[tot]);
        fail[tot]=0;l[tot]=len;
        return tot;
    }
    int get_fail(int x){
        while (s[now-l[x]-2]!=s[now-1])x = fail[x];
        return x;
    }
    void add(int ch){
        s[now++] = ch;
        int cur = get_fail(last);
        if(!nxt[cur][ch]){
            int tt = newnode(l[cur]+2);
            fail[tt] = nxt[get_fail(fail[cur])][ch];
            nxt[cur][ch] = tt;
            diff[tt] = l[tt] - l[fail[tt]];
            anc[tt] = diff[tt] == diff[fail[tt]]? anc[fail[tt]] : fail[tt];
        }
        last = nxt[cur][ch];
    }
    void trans(int i){
        for (int p = last;p>1;p = anc[p]){
            g[p] = f[i - l[anc[p]] - diff[p]];/*TBD*/
            if (diff[p] == diff[fail[p]]){
                (g[p] += g[fail[p]]) %= mod;/*TBD*/
            }
            (f[i] += (i % 2 == 0) *g[p]) %= mod;/*TBD*/
        }
    }
    int init(char* s){
        f[0] = 1;
        int n = strlen(s + 1);
        for (int i=1;i<=n;i++){
            add(s[i] - 'a');
            trans(i);
        }
        return f[n];
    }
}pam;
char t[maxn], s[maxn];
int main(){
    scanf("%s",s + 1);
    int n = strlen(s+1);
    for (int i=1;i<=n/2;i++){
        t[2 * i - 1] = s[i];
        t[2 * i] = s[n + 1- i ];
    }
    cout<<pam.init(t)<<endl;
    return 0;
}
```

<div style="page-break-after:always;"></div>

# SA

### 后缀数组

**后缀 $S[i]$** : $S[i] = S[i, |S|]$ 

**字典序** : 对于两个字符串 $S$ 和 $T$ , 从左到右找到第一个不同的字母, 谁的字母小, 谁的字典序就小. 特殊的, 如果 $S$ 为 $T$ 的前缀, 认为 $S < T$ . 即空字符串最小

**后缀排序** : 将所有后缀 $S[i]$ 看作独立的串, 放在一起按照字典序进行升序排序

**后缀排名 $rk[i]$** : $rk[i]$ 表示后缀 $s[i]$ 在后缀排序中的排名, 即他是第几小的后缀

**后缀数组 $sa[i]$** : $sa[i]$ 表示排名第 $i$ 小的后缀

$rk[sa[i]] = i$ 

<br>

### 后缀数组性质

设有一组排序过的字符串 $A = [A_1, A_2, \cdots, A_n]$ , 如何快速求任意 $A_i$ 与 $A_j$ 的 $LCP$ ?

"区间可加性": 对于任意的 $k \in [i, j]$ , $LCP(A_i, A_j) = LCP(LCP(A_i, A_k), LCP(A_k, A_j)) = min(LCP(A_i, A_k), LCP(A_k, A_j))$ 

进而, $LCP(A_i, A_j) = min(LCP(A_i, A_{i + 1}), LCP(A_{i + 1}, A_{i + 1}), \cdots, LCP(A_{j - 1}, A_j))$ 

<br>

### Height 数组

$Height[i]$ 为后缀 $i$ 与排名在他前面一个的后缀的 $LCP$ , 即: $Height[i] = LCP(S[i, n], S[sa[rk[i] - 1], n])$ 

有了 $Height[i]$ 数组之后, 利用后缀数组的性质, 任意两个后缀的 $LCP$ 就变成了区间最小值查询

性质: $Height[i] \ge Height[i - 1] - 1$ 

求 $Height$ : 首先让 $Height[i]$ 继承 $Height[i - 1] - 1$ , 然后向后暴力延伸

应用: 求本质不同子串数量, $ans = \sum n - sa[i] + 1 - Height[i]$ 

<br>

### 玄学板子

```c++
#include <bits/stdc++.h>
#define rank rkrkrk
//#define _DEBUG
#define RMQ
using namespace std;
const int maxn = 3e5+100;
int w[maxn];
int lg[maxn];
struct Run{
    int l,r,k;
};
struct UFS {
    int fa[maxn];
    void init(int n) { iota(fa, fa + n + 1, 0); }
    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
    bool unite(int u, int v) {
        u = find(u); v = find(v);
        fa[u] = v;
        return u != v;
    }
} ufs[20];

int unite(int u, int v, int k) {
    if (ufs[k].unite(u, v)) {
        if (k == 0) return 1;
        return unite(u, v, k - 1) + unite(u + (1<<(k-1)), v + (1<<(k-1)), k - 1);
    } else return 0;
}

long long merge(int u, int v, int l) {
    int k = log2(l);
    int ret =  unite(u, v, k) +
               unite(u + l - (1<<k), v + l - (1<<k), k);
    return ret;
}
struct SA{
#ifndef RMQ
    struct Segment_Tree{
        int min_val[maxn*4];
        void up(int x){
            min_val[x] = min(min_val[x<<1],min_val[x<<1|1]);
        }
        void build(int x,int l,int r,int*h){
            if (l == r){
                min_val[x] = h[l];
                return;
            }
            int mid = l + r >>1;
            build(x<<1,l,mid,h);
            build(x<<1|1,mid+1,r,h);
            up(x);
        }
        int query(int x,int l,int r,int L,int R){
            if (l > R || L > r)return 0x3f3f3f3f;
            if (L<= l && r <= R)return min_val[x];
            int mid = l + r >> 1;
            return min(query(x<<1,l,mid,L,R),query(x<<1|1,mid+1,r,L,R));
        }
    }segtree;
#else
    int st[maxn][20];
    void st_init(int n,int*h){
        for (int i=1;i<=n;i++){
            st[i][0] = h[i];
        }
        for (int j=1;(1<<j)<=n;j++){
            for (int i=1;i<=n-(1<<j)+1;i++){
                st[i][j] = min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
            }
        }
    }
#endif
    int cntA[maxn],cntB[maxn],tsa[maxn],A[maxn],B[maxn];
    int sa[maxn],rank[maxn],height[maxn];
    void get_sa(int * ch,int n){
        ch[0] = ch[n+1] = -1;
        for (int i=0;i<=n;i++)cntA[i] = 0;
        for (int i=1;i<=n;i++)cntA[ch[i]]++;
        for (int i=1;i<=n;i++)cntA[i] += cntA[i-1];
        for (int i=n;i>=1;i--)sa[cntA[ch[i]]--] = i;
        rank[sa[1]] = 1;
        for (int i=2;i<=n;i++){
            rank[sa[i]] = rank[sa[i-1]];
            if (ch[sa[i]] != ch[sa[i-1]])rank[sa[i]] ++;
        }
        for (int l=1;rank[sa[n]]<n;l<<=1){
            for (int i=0;i<=n;i++)cntA[i] = cntB[i] = 0;
            for (int i=1;i<=n;i++){
                cntA[A[i] = rank[i]] ++;
                cntB[B[i]=(i+l<=n)?rank[i+l]:0]++;
            }
            for (int i=1;i<=n;i++)cntB[i] += cntB[i-1];
            for (int i=n;i>=1;i--)tsa[cntB[B[i]]--] = i;
            for (int i=1;i<=n;i++)cntA[i] += cntA[i-1];
            for (int i=n;i>=1;i--)sa[cntA[A[tsa[i]]]--] = tsa[i];
            rank[sa[1]] = 1;
            for (int i=2;i<=n;i++){
                rank[sa[i]] = rank[sa[i-1]];
                if (A[sa[i]] != A[sa[i-1]] || B[sa[i]] != B[sa[i-1]])rank[sa[i]] ++;
            }
        }
    }
    void get_height(int *ch,int n){
        get_sa(ch,n);
        sa[0] = rank[0] = 0;
        for (int i=1,j=0;i<=n;i++){
            if (j) j--;
            while (ch[i+j] == ch[sa[rank[i]-1]+j])j++;
            height[rank[i]] = j;
        }
#ifdef _DEBUG
        for (int i=1;i<=n;i++){
            printf("height[%d]=%d\n",i,height[i]);
        }
#endif
#ifndef RMQ
        segtree.build(1,1,n,height);
#else
        st_init(n,height);
#endif
    }
    int get_lcp(int x,int y,int n){
        int rkx = rank[x];
        int rky = rank[y];
        if (rkx>rky)swap(rkx,rky);
        rkx++;
#ifndef RMQ
        int lcp = segtree.query(1,1,n,rkx,rky);
#else
        int k = lg[(rky - rkx+1)];
        int lcp = min(st[rkx][k],st[rky - (1<<k)+1][k]);
#endif

#ifdef _DEBUG
        printf("[get_lcp] x=%d y=%d rkx=%d,rky=%d,lcp =%d\n",x,y,rkx,rky,lcp);
#endif
        return lcp;
    }
}sa1,sa2;
int ch2[maxn];
vector<Run> get_run(int*ch,int n){
    sa1.get_height(ch,n);
    for (int i=0;i<=n+1;i++){
        ch2[i] = ch[i];
    }
    reverse(ch2+1,ch2+1+n);
    sa2.get_height(ch2,n);
    vector<Run> result(0);
    int len_max = n/2;
    for (int len = 1;len <=len_max;len ++){
        //get_len_run
        for (int i=1;i<=n;i+=len){
            int j = i+len;
            if (j >n)break;
            int lcp = sa1.get_lcp(i,j,n);
            int lcs = sa2.get_lcp(n+1-i,n+1-j,n);
            lcp = min(lcp,len);
            lcs = min(lcs,len);
            assert(j+lcp-1<=n);
            assert(i-lcs+1>=1);
#ifdef _DEBUG
            printf("i=%d,j=%d,len=%d,lcp=%d,lcs=%d\n",i,j,len,lcp,lcs);
#endif
            if (lcp + lcs - 1 < len)continue;
            int L = j-lcs+1;
            int R = j + lcp -1;
            result.push_back((Run){L,R,len});
        }
    }
#ifdef _DEBUG
    for (Run run : result){
        printf("[run]: l=%d, r=%d,k=%d\n",run.l,run.r,run.k);
    }
#endif
    return result;
}
int n;
typedef long long ll;
ll spanning_forest(vector<Run> &runs){
    sort(runs.begin(),runs.end(),[](Run x,Run y){
        return w[x.k] < w[y.k];
    });
    ll ans = 0;
    for (auto& R : runs) {
        int l = R.l, r = R.r;
        ans += 1ll * merge(l - R.k, l, r - l + 1) * w[R.k];
    }
    return ans;
}
int ch[maxn];
int main(){
    for (int i=2;i<maxn;i++)lg[i] = lg[i/2] + 1;
    int T;
    scanf("%d",&T);
    while (T--){
        scanf("%d",&n);
        for (int i = 0; i < 20 ; i++) ufs[i].init(n);
        ch[n+1] = -1;
        ch[0] = -1;
        for (int i=1;i<=n;i++){
            scanf("%d",ch+i);
        }
        int m = n/2;
        for (int i=1;i<=m;i++){
            scanf("%d",w+i);
        }
        vector<Run> all_run = get_run(ch,n);
        printf("%lld\n",spanning_forest(all_run));
    }
    return 0;
}
```

```c++
/** SA from oval_m
 * n 长度
 * m 字符集大小
 * s 字符串     0 base
 * sa 字典序第 i 小是哪个后缀
 * rk 后缀 i 的排名
 * ht lcp(sa[i], sa[i - 1])
*/
int sa[N], rk[N], ht[N];
void getSA(string& s, int m=128)
{
	static int xx[N], yy[N], c[N];
	int *x=xx, *y=yy;
	int n = s.size();
	for(int i = 0; i < m; i++) c[i] = 0;
	for(int i = 0; i < n; i++) c[x[i] = s[i]]++;
	for(int i = 1; i < m; i++) c[i] += c[i - 1];
	for(int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;
	for(int k = 1; k < n; k <<= 1) {
		int p = 0;
		for(int i = n - 1; i >= n - k; i--) y[p++] = i;
		for(int i = 0; i < n; i++) if(sa[i] >= k) y[p++] = sa[i] - k;
		for(int i = 0; i < m; i++) c[i] = 0;
		for(int i = 0; i < n; i++) c[x[y[i]]]++;
		for(int i = 1; i < m; i++) c[i] += c[i - 1];
		for(int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];
		swap(x, y);
		p = 1; x[sa[0]] = 0; y[n] = -1;
		for(int i = 1; i < n; i++) {
			if(y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k])
				x[sa[i]] = p - 1;
			else  x[sa[i]] = p++;
		}
		if(p == n)break;
		m = p;
	}
	// 计算ht
	for(int i = 0; i < n; i++)rk[sa[i]] = i;
	int k = 0;
	for(int i = 0; i < n; i++) {
		k = max(k-1, 0ll);
		if(rk[i] == 0)continue;
		int j = sa[rk[i] - 1];
		while(s[i + k] == s[j + k]) k++;
		ht[rk[i]] = k;
	}
}
```

<div style="page-break-after:always;"></div>

# 计算几何板子

```c++
#include <bits/stdc++.h>
using namespace std;

// using point_t=long long;
using point_t=long double;  //全局数据类型

constexpr point_t eps=1e-8;
constexpr point_t INF=numeric_limits<point_t>::max();
constexpr long double PI=3.1415926535897932384l;

// 点与向量
template<typename T> struct point
{
    T x,y;

    bool operator==(const point &a) const {return (abs(x-a.x)<=eps && abs(y-a.y)<=eps);}
    bool operator<(const point &a) const {if (abs(x-a.x)<=eps) return y<a.y-eps; return x<a.x-eps;}
    bool operator>(const point &a) const {return !(*this<a || *this==a);}
    point operator+(const point &a) const {return {x+a.x,y+a.y};}
    point operator-(const point &a) const {return {x-a.x,y-a.y};}
    point operator-() const {return {-x,-y};}
    point operator*(const T k) const {return {k*x,k*y};}
    point operator/(const T k) const {return {x/k,y/k};}
    T operator*(const point &a) const {return x*a.x+y*a.y;}  // 点积
    T operator^(const point &a) const {return x*a.y-y*a.x;}  // 叉积，注意优先级
    int toleft(const point &a) const {const auto t=(*this)^a; return (t>eps)-(t<-eps);}  // to-left 测试
    T len2() const {return (*this)*(*this);}  // 向量长度的平方
    T dis2(const point &a) const {return (a-(*this)).len2();}  // 两点距离的平方

    // 涉及浮点数
    long double len() const {return sqrtl(len2());}  // 向量长度
    long double dis(const point &a) const {return sqrtl(dis2(a));}  // 两点距离
    long double ang(const point &a) const {return acosl(max(-1.0l,min(1.0l,((*this)*a)/(len()*a.len()))));}  // 向量夹角
    point rot(const long double rad) const {return {x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)};}  // 逆时针旋转（给定角度）
    point rot(const long double cosr,const long double sinr) const {return {x*cosr-y*sinr,x*sinr+y*cosr};}  // 逆时针旋转（给定角度的正弦与余弦）
};

using Point=point<point_t>;

// 极角排序
struct argcmp
{
    bool operator()(const Point &a,const Point &b) const
    {
        const auto quad=[](const Point &a)
        {
            if (a.y<-eps) return 1;
            if (a.y>eps) return 4;
            if (a.x<-eps) return 5;
            if (a.x>eps) return 3;
            return 2;
        };
        const int qa=quad(a),qb=quad(b);
        if (qa!=qb) return qa<qb;
        const auto t=a^b;
        // if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开
        return t>eps;
    }
};

// 直线
template<typename T> struct line
{
    point<T> p,v;  // p 为直线上一点，v 为方向向量

    bool operator==(const line &a) const {return v.toleft(a.v)==0 && v.toleft(p-a.p)==0;}
    int toleft(const point<T> &a) const {return v.toleft(a-p);}  // to-left 测试
    bool operator<(const line &a) const  // 半平面交算法定义的排序
    {
        if (abs(v^a.v)<=eps && v*a.v>=-eps) return toleft(a.p)==-1;
        return argcmp()(v,a.v);
    }

    // 涉及浮点数
    point<T> inter(const line &a) const {return p+v*((a.v^(p-a.p))/(v^a.v));}  // 直线交点
    long double dis(const point<T> &a) const {return abs(v^(a-p))/v.len();}  // 点到直线距离
    point<T> proj(const point<T> &a) const {return p+v*((v*(a-p))/(v*v));}  // 点在直线上的投影
};

using Line=line<point_t>;

//线段
template<typename T> struct segment
{
    point<T> a,b;

    bool operator<(const segment &s) const {return make_pair(a,b)<make_pair(s.a,s.b);}

    // 判定性函数建议在整数域使用

    // 判断点是否在线段上
    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const point<T> &p) const  
    {
        if (p==a || p==b) return -1;
        return (p-a).toleft(p-b)==0 && (p-a)*(p-b)<-eps;
    }

    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const line<T> &l) const
    {
        if (l.toleft(a)==0 || l.toleft(b)==0) return -1;
        return l.toleft(a)!=l.toleft(b);
    }
    
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const segment<T> &s) const
    {
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const line<T> l{a,b-a},ls{s.a,s.b-s.a};
        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;
    }

    // 点到线段距离
    long double dis(const point<T> &p) const
    {
        if ((p-a)*(b-a)<-eps || (p-b)*(a-b)<-eps) return min(p.dis(a),p.dis(b));
        const line<T> l{a,b-a};
        return l.dis(p);
    }

    // 两线段间距离
    long double dis(const segment<T> &s) const
    {
        if (is_inter(s)) return 0;
        return min({dis(s.a),dis(s.b),s.dis(a),s.dis(b)});
    }
};

using Segment=segment<point_t>;

// 多边形
template<typename T> struct polygon
{
    vector<point<T>> p;  // 以逆时针顺序存储

    size_t nxt(const size_t i) const {return i==p.size()-1?0:i+1;}
    size_t pre(const size_t i) const {return i==0?p.size()-1:i-1;}
    
    // 回转数
    // 返回值第一项表示点是否在多边形边上
    // 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
    pair<bool,int> winding(const point<T> &a) const
    {
        int cnt=0;
        for (size_t i=0;i<p.size();i++)
        {
            const point<T> u=p[i],v=p[nxt(i)];
            if (abs((a-u)^(a-v))<=eps && (a-u)*(a-v)<=eps) return {true,0};
            if (abs(u.y-v.y)<=eps) continue;
            const Line uv={u,v-u};
            if (u.y<v.y-eps && uv.toleft(a)<=0) continue;
            if (u.y>v.y+eps && uv.toleft(a)>=0) continue;
            if (u.y<a.y-eps && v.y>=a.y-eps) cnt++;
            if (u.y>=a.y-eps && v.y<a.y-eps) cnt--;
        }
        return {false,cnt};
    }

    // 多边形面积的两倍
    // 可用于判断点的存储顺序是顺时针或逆时针
    T area() const
    {
        T sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i]^p[nxt(i)];
        return sum;
    }

    // 多边形的周长
    long double circ() const
    {
        long double sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i].dis(p[nxt(i)]);
        return sum;
    }
};

using Polygon=polygon<point_t>;

//凸多边形
template<typename T> struct convex: polygon<T>
{
    // 闵可夫斯基和
    convex operator+(const convex &c) const  
    {
        const auto &p=this->p;
        vector<Segment> e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());
        vector<point<T>> res; res.reserve(p.size()+c.p.size());
        const auto cmp=[](const Segment &u,const Segment &v) {return argcmp()(u.b-u.a,v.b-v.a);};
        for (size_t i=0;i<p.size();i++) e1[i]={p[i],p[this->nxt(i)]};
        for (size_t i=0;i<c.p.size();i++) e2[i]={c.p[i],c.p[c.nxt(i)]};
        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());
        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());
        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);
        const auto check=[](const vector<point<T>> &res,const point<T> &u)
        {
            const auto back1=res.back(),back2=*prev(res.end(),2);
            return (back1-back2).toleft(u-back1)==0 && (back1-back2)*(u-back1)>=-eps;
        };
        auto u=e1[0].a+e2[0].a;
        for (const auto &v:edge)
        {
            while (res.size()>1 && check(res,u)) res.pop_back();
            res.push_back(u);
            u=u+v.b-v.a;
        }
        if (res.size()>1 && check(res,res[0])) res.pop_back();
        return {res};
    }

    // 旋转卡壳
    // 例：凸多边形的直径的平方
    T rotcaliper() const
    {
        const auto &p=this->p;
        if (p.size()==1) return 0;
        if (p.size()==2) return p[0].dis2(p[1]);
        const auto area=[](const point<T> &u,const point<T> &v,const point<T> &w){return (w-u)^(w-v);};
        T ans=0;
        for (size_t i=0,j=1;i<p.size();i++)
        {
            const auto nxti=this->nxt(i);
            ans=max({ans,p[j].dis2(p[i]),p[j].dis2(p[nxti])});
            while (area(p[this->nxt(j)],p[i],p[nxti])>=area(p[j],p[i],p[nxti]))
            {
                j=this->nxt(j);
                ans=max({ans,p[j].dis2(p[i]),p[j].dis2(p[nxti])});
            }
        }
        return ans;
    }
    
    // 判断点是否在凸多边形内
    // 复杂度 O(logn)
    // -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int is_in(const point<T> &a) const
    {
        const auto &p=this->p;
        if (p.size()==1) return a==p[0]?-1:0;
        if (p.size()==2) return segment<T>{p[0],p[1]}.is_on(a)?-1:0; 
        if (a==p[0]) return -1;
        if ((p[1]-p[0]).toleft(a-p[0])==-1 || (p.back()-p[0]).toleft(a-p[0])==1) return 0;
        const auto cmp=[&](const point<T> &u,const point<T> &v){return (u-p[0]).toleft(v-p[0])==1;};
        const size_t i=lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();
        if (i==1) return segment<T>{p[0],p[i]}.is_on(a)?-1:0;
        if (i==p.size()-1 && segment<T>{p[0],p[i]}.is_on(a)) return -1;
        if (segment<T>{p[i-1],p[i]}.is_on(a)) return -1;
        return (p[i]-p[i-1]).toleft(a-p[i-1])>0;
    }

    // 凸多边形关于某一方向的极点
    // 复杂度 O(logn)
    // 参考资料：https://codeforces.com/blog/entry/48868
    template<typename F> size_t extreme(const F &dir) const
    {
        const auto &p=this->p;
        const auto check=[&](const size_t i){return dir(p[i]).toleft(p[this->nxt(i)]-p[i])>=0;};
        const auto dir0=dir(p[0]); const auto check0=check(0);
        if (!check0 && check(p.size()-1)) return 0;
        const auto cmp=[&](const point<T> &v)
        {
            const size_t vi=&v-p.data();
            if (vi==0) return 1;
            const auto checkv=check(vi);
            const auto t=dir0.toleft(v-p[0]);
            if (vi==1 && checkv==check0 && t==0) return 1;
            return checkv^(checkv==check0 && t<=0);
        };
        return partition_point(p.begin(),p.end(),cmp)-p.begin();
    }

    // 过凸多边形外一点求凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    // 必须保证点在多边形外
    pair<size_t,size_t> tangent(const point<T> &a) const
    {
        const size_t i=extreme([&](const point<T> &u){return u-a;});
        const size_t j=extreme([&](const point<T> &u){return a-u;});
        return {i,j};
    }

    // 求平行于给定直线的凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    pair<size_t,size_t> tangent(const line<T> &a) const
    {
        const size_t i=extreme([&](...){return a.v;});
        const size_t j=extreme([&](...){return -a.v;});
        return {i,j};
    }
};

using Convex=convex<point_t>;

// 圆
struct Circle
{
    Point c;
    long double r;

    bool operator==(const Circle &a) const {return c==a.c && abs(r-a.r)<=eps;}
    long double circ() const {return 2*PI*r;}  // 周长
    long double area() const {return PI*r*r;}  // 面积

    // 点与圆的关系
    // -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &p) const {const long double d=p.dis(c); return abs(d-r)<=eps?-1:d<r-eps;}

    // 直线与圆关系
    // 0 相离 | 1 相切 | 2 相交
    int relation(const Line &l) const
    {
        const long double d=l.dis(c);
        if (d>r+eps) return 0;
        if (abs(d-r)<=eps) return 1;
        return 2;
    }

    // 圆与圆关系
    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &a) const
    {
        if (*this==a) return -1;
        const long double d=c.dis(a.c);
        if (d>r+a.r+eps) return 0;
        if (abs(d-r-a.r)<=eps) return 1;
        if (abs(d-abs(r-a.r))<=eps) return 3;
        if (d<abs(r-a.r)-eps) return 4;
        return 2;
    }

    // 直线与圆的交点
    vector<Point> inter(const Line &l) const
    {
        const long double d=l.dis(c);
        const Point p=l.proj(c);
        const int t=relation(l);
        if (t==0) return vector<Point>();
        if (t==1) return vector<Point>{p};
        const long double k=sqrt(r*r-d*d);
        return vector<Point>{p-(l.v/l.v.len())*k,p+(l.v/l.v.len())*k};
    }

    // 圆与圆交点
    vector<Point> inter(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1 || t==0 || t==4) return vector<Point>();
        Point e=a.c-c; e=e/e.len()*r;
        if (t==1 || t==3) 
        {
            if (r*r+d*d-a.r*a.r>=-eps) return vector<Point>{c+e};
            return vector<Point>{c-e};
        }
        const long double costh=(r*r+d*d-a.r*a.r)/(2*r*d),sinth=sqrt(1-costh*costh);
        return vector<Point>{c+e.rot(costh,-sinth),c+e.rot(costh,sinth)};
    }

    // 圆与圆交面积
    long double inter_area(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1) return area();
        if (t<2) return 0;
        if (t>2) return min(area(),a.area());
        const long double costh1=(r*r+d*d-a.r*a.r)/(2*r*d),costh2=(a.r*a.r+d*d-r*r)/(2*a.r*d);
        const long double sinth1=sqrt(1-costh1*costh1),sinth2=sqrt(1-costh2*costh2);
        const long double th1=acos(costh1),th2=acos(costh2);
        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);
    }

    // 过圆外一点圆的切线
    vector<Line> tangent(const Point &a) const
    {
        const int t=is_in(a);
        if (t==1) return vector<Line>();
        if (t==-1)
        {
            const Point v={-(a-c).y,(a-c).x};
            return vector<Line>{{a,v}};
        }
        Point e=a-c; e=e/e.len()*r;
        const long double costh=r/c.dis(a),sinth=sqrt(1-costh*costh);
        const Point t1=c+e.rot(costh,-sinth),t2=c+e.rot(costh,sinth);
        return vector<Line>{{a,t1-a},{a,t2-a}};
    }

    // 两圆的公切线
    vector<Line> tangent(const Circle &a) const
    {
        const int t=relation(a);
        vector<Line> lines;
        if (t==-1 || t==4) return lines;
        if (t==1 || t==3)
        {
            const Point p=inter(a)[0],v={-(a.c-c).y,(a.c-c).x};
            lines.push_back({p,v});
        }
        const long double d=c.dis(a.c);
        const Point e=(a.c-c)/(a.c-c).len();
        if (t<=2)
        {
            const long double costh=(r-a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c+d1*a.r,v2=a.c+d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        if (t==0)
        {
            const long double costh=(r+a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c-d1*a.r,v2=a.c-d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        return lines;
    }

    // 圆的反演
    tuple<int,Circle,Line> inverse(const Line &l) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        if (l.toleft(c)==0) return {2,null_c,l};
        const Point v=l.toleft(c)==1?Point{l.v.y,-l.v.x}:Point{-l.v.y,l.v.x};
        const long double d=r*r/l.dis(c);
        const Point p=c+v/v.len()*d;
        return {1,{(c+p)/2,d/2},null_l};
    }
    
    tuple<int,Circle,Line> inverse(const Circle &a) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        const Point v=a.c-c;
        if (a.is_in(c)==-1)
        {
            const long double d=r*r/(a.r+a.r);
            const Point p=c+v/v.len()*d;
            return {2,null_c,{p,{-v.y,v.x}}};
        }
        if (c==a.c) return {1,{c,r*r/a.r},null_l};
        const long double d1=r*r/(c.dis(a.c)-a.r),d2=r*r/(c.dis(a.c)+a.r);
        const Point p=c+v/v.len()*d1,q=c+v/v.len()*d2;
        return {1,{(p+q)/2,p.dis(q)/2},null_l};
    }
};

// 圆与多边形面积交
long double area_inter(const Circle &circ,const Polygon &poly)
{
    const auto cal=[](const Circle &circ,const Point &a,const Point &b)
    {
        if ((a-circ.c).toleft(b-circ.c)==0) return 0.0l;
        const auto ina=circ.is_in(a),inb=circ.is_in(b);
        const Line ab={a,b-a};
        if (ina && inb) return ((a-circ.c)^(b-circ.c))/2;
        if (ina && !inb)
        {
            const auto t=circ.inter(ab);
            const Point p=t.size()==1?t[0]:t[1];
            const long double ans=((a-circ.c)^(p-circ.c))/2;
            const long double th=(p-circ.c).ang(b-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        if (!ina && inb)
        {
            const Point p=circ.inter(ab)[0];
            const long double ans=((p-circ.c)^(b-circ.c))/2;
            const long double th=(a-circ.c).ang(p-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        const auto p=circ.inter(ab);
        if (p.size()==2 && Segment{a,b}.dis(circ.c)<=circ.r+eps)
        {
            const long double ans=((p[0]-circ.c)^(p[1]-circ.c))/2;
            const long double th1=(a-circ.c).ang(p[0]-circ.c),th2=(b-circ.c).ang(p[1]-circ.c);
            const long double d1=circ.r*circ.r*th1/2,d2=circ.r*circ.r*th2/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d1+d2;
            return ans-d1-d2;
        }
        const long double th=(a-circ.c).ang(b-circ.c);
        if ((a-circ.c).toleft(b-circ.c)==1) return circ.r*circ.r*th/2;
        return -circ.r*circ.r*th/2;
    };

    long double ans=0;
    for (size_t i=0;i<poly.p.size();i++)
    {
        const Point a=poly.p[i],b=poly.p[poly.nxt(i)];
        ans+=cal(circ,a,b);
    }
    return ans;
}

// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
Convex convexhull(vector<Point> p)
{
    vector<Point> st;
    if (p.empty()) return Convex{st};
    sort(p.begin(),p.end());
    const auto check=[](const vector<Point> &st,const Point &u)
    {
        const auto back1=st.back(),back2=*prev(st.end(),2);
        return (back1-back2).toleft(u-back1)<=0;
    };
    for (const Point &u:p)
    {
        while (st.size()>1 && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    size_t k=st.size();
    p.pop_back(); reverse(p.begin(),p.end());
    for (const Point &u:p)
    {
        while (st.size()>k && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    st.pop_back();
    return Convex{st};
}

// 半平面交
// 排序增量法，复杂度 O(nlogn)
// 输入与返回值都是用直线表示的半平面集合
vector<Line> halfinter(vector<Line> l, const point_t lim=1e9)
{
    const auto check=[](const Line &a,const Line &b,const Line &c){return a.toleft(b.inter(c))<0;};
    // 无精度误差的方法，但注意取值范围会扩大到三次方
    /*const auto check=[](const Line &a,const Line &b,const Line &c)
    {
        const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);
        return p.toleft(q)<0;
    };*/
    l.push_back({{-lim,0},{0,-1}}); l.push_back({{0,-lim},{1,0}});
    l.push_back({{lim,0},{0,1}}); l.push_back({{0,lim},{-1,0}});
    sort(l.begin(),l.end());
    deque<Line> q;
    for (size_t i=0;i<l.size();i++)
    {
        if (i>0 && l[i-1].v.toleft(l[i].v)==0 && l[i-1].v*l[i].v>eps) continue;
        while (q.size()>1 && check(l[i],q.back(),q[q.size()-2])) q.pop_back();
        while (q.size()>1 && check(l[i],q[0],q[1])) q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v)<=0) return vector<Line>();
        q.push_back(l[i]);
    }
    while (q.size()>1 && check(q[0],q.back(),q[q.size()-2])) q.pop_back();
    while (q.size()>1 && check(q.back(),q[0],q[1])) q.pop_front();
    return vector<Line>(q.begin(),q.end());
}

// 点集形成的最小最大三角形
// 极角序扫描线，复杂度 O(n^2logn)
// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)
pair<point_t,point_t> minmax_triangle(const vector<Point> &vec)
{
    if (vec.size()<=2) return {0,0};
    vector<pair<int,int>> evt;
    evt.reserve(vec.size()*vec.size());
    point_t maxans=0,minans=INF;
    for (size_t i=0;i<vec.size();i++)
    {
        for (size_t j=0;j<vec.size();j++)
        {
            if (i==j) continue;
            if (vec[i]==vec[j]) minans=0;
            else evt.push_back({i,j});
        }
    }
    sort(evt.begin(),evt.end(),[&](const pair<int,int> &u,const pair<int,int> &v)
    {
        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];
        return argcmp()({du.y,-du.x},{dv.y,-dv.x});
    });
    vector<size_t> vx(vec.size()),pos(vec.size());
    for (size_t i=0;i<vec.size();i++) vx[i]=i;
    sort(vx.begin(),vx.end(),[&](int x,int y){return vec[x]<vec[y];});
    for (size_t i=0;i<vx.size();i++) pos[vx[i]]=i;
    for (auto [u,v]:evt)
    {
        const size_t i=pos[u],j=pos[v];
        const size_t l=min(i,j),r=max(i,j);
        const Point vecu=vec[u],vecv=vec[v];
        if (l>0) minans=min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));
        if (r<vx.size()-1) minans=min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));
        maxans=max({maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))});
        if (i<j) swap(vx[i],vx[j]),pos[u]=j,pos[v]=i;
    }
    return {minans,maxans};
}

// 平面最近点对
// 扫描线，复杂度 O(nlogn)
point_t closest_pair(vector<Point> points)
{
    sort(points.begin(),points.end());
    const auto cmpy=[](const Point &a,const Point &b){if (abs(a.y-b.y)<=eps) return a.x<b.x-eps; return a.y<b.y-eps;};
    multiset<Point,decltype(cmpy)> s{cmpy};
    point_t ans=INF;
    for (size_t i=0,l=0;i<points.size();i++)
    {
        const point_t sqans=sqrtl(ans)+1;  // 整数情况
        // const point_t sqans=sqrtl(ans)+1;  // 浮点数情况
        while (l<i && points[i].x-points[l].x>=sqans) s.erase(s.find(points[l++]));
        for (auto it=s.lower_bound(Point{-INF,points[i].y-sqans});it!=s.end()&&it->y-points[i].y<=sqans;it++)
        {
            ans=min(ans,points[i].dis2(*it));
        }
        s.insert(points[i]);
    }
    return ans;
}

// 判断多条线段是否有交点
// 扫描线，复杂度 O(nlogn)
bool segs_inter(const vector<Segment> &segs)
{
    if (segs.empty()) return false;
    using seq_t=tuple<point_t,int,Segment>;
    const auto seqcmp=[](const seq_t &u, const seq_t &v)
    {
        const auto [u0,u1,u2]=u;
        const auto [v0,v1,v2]=v;
        if (abs(u0-v0)<=eps) return make_pair(u1,u2)<make_pair(v1,v2);
        return u0<v0-eps;
    };
    vector<seq_t> seq;
    for (auto seg:segs)
    {
        if (seg.a.x>seg.b.x+eps) swap(seg.a,seg.b);
        seq.push_back({seg.a.x,0,seg});
        seq.push_back({seg.b.x,1,seg});
    }
    sort(seq.begin(),seq.end(),seqcmp);
    point_t x_now;
    auto cmp=[&](const Segment &u, const Segment &v)
    {
        if (abs(u.a.x-u.b.x)<=eps || abs(v.a.x-v.b.x)<=eps) return u.a.y<v.a.y-eps;
        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)<((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;
    };
    multiset<Segment,decltype(cmp)> s{cmp};
    for (const auto [x,o,seg]:seq)
    {
        x_now=x;
        const auto it=s.lower_bound(seg);
        if (o==0)
        {
            if (it!=s.end() && seg.is_inter(*it)) return true;
            if (it!=s.begin() && seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        }
        else
        {
            if (next(it)!=s.end() && it!=s.begin() && (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        }
    }
    return false;
}

// 多边形面积并
// 轮廓积分，复杂度 O(n^2logn)，n为边数
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Polygon> &polys)
{
    const size_t siz=polys.size();
    vector<vector<pair<Point,Point>>> segs(siz);
    const auto check=[](const Point &u,const Segment &e){return !((u<e.a && u<e.b) || (u>e.a && u>e.b));};

    auto cut_edge=[&](const Segment &e,const size_t i)
    {
        const Line le{e.a,e.b-e.a};
        vector<pair<Point,int>> evt;
        evt.push_back({e.a,0}); evt.push_back({e.b,0});
        for (size_t j=0;j<polys.size();j++)
        {
            if (i==j) continue;
            const auto &pj=polys[j];
            for (size_t k=0;k<pj.p.size();k++)
            {
                const Segment s={pj.p[k],pj.p[pj.nxt(k)]};
                if (le.toleft(s.a)==0 && le.toleft(s.b)==0)
                {
                    evt.push_back({s.a,0});
                    evt.push_back({s.b,0});
                }
                else if (s.is_inter(le))
                {
                    const Line ls{s.a,s.b-s.a};
                    const Point u=le.inter(ls);
                    if (le.toleft(s.a)<0 && le.toleft(s.b)>=0) evt.push_back({u,-1});
                    else if (le.toleft(s.a)>=0 && le.toleft(s.b)<0) evt.push_back({u,1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        if (e.a>e.b) reverse(evt.begin(),evt.end());
        int sum=0;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            const Point u=evt[i].first,v=evt[i+1].first;
            if (!(u==v) && check(u,e) && check(v,e)) segs[sum].push_back({u,v});
            if (v==e.b) break;
        }
    };
    
    for (size_t i=0;i<polys.size();i++)
    {
        const auto &pi=polys[i];
        for (size_t k=0;k<pi.p.size();k++)
        {
            const Segment ei={pi.p[k],pi.p[pi.nxt(k)]};
            cut_edge(ei,i);
        }
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(segs[i].begin(),segs[i].end());
        int cnt=0;
        for (size_t j=0;j<segs[i].size();j++)
        {
            if (j>0 && segs[i][j]==segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);
            else cnt=0,sum+=segs[i][j].first^segs[i][j].second;
        }
        ans[i]=sum/2;
    }
    return ans;
}

// 圆面积并
// 轮廓积分，复杂度 O(n^2logn)
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Circle> &circs)
{
    const size_t siz=circs.size();
    using arc_t=tuple<Point,long double,long double,long double>;
    vector<vector<arc_t>> arcs(siz);
    const auto eq=[](const arc_t &u,const arc_t &v)
    {
        const auto [u1,u2,u3,u4]=u;
        const auto [v1,v2,v3,v4]=v;
        return u1==v1 && abs(u2-v2)<=eps && abs(u3-v3)<=eps && abs(u4-v4)<=eps;
    };

    auto cut_circ=[&](const Circle &ci,const size_t i)
    {
        vector<pair<long double,int>> evt;
        evt.push_back({-PI,0}); evt.push_back({PI,0});
        int init=0;
        for (size_t j=0;j<circs.size();j++)
        {
            if (i==j) continue;
            const Circle &cj=circs[j];
            if (ci.r<cj.r-eps && ci.relation(cj)>=3) init++;
            const auto inters=ci.inter(cj);
            if (inters.size()==1) evt.push_back({atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0});
            if (inters.size()==2)
            {
                const Point dl=inters[0]-ci.c,dr=inters[1]-ci.c;
                long double argl=atan2l(dl.y,dl.x),argr=atan2l(dr.y,dr.x);
                if (abs(argl+PI)<=eps) argl=PI;
                if (abs(argr+PI)<=eps) argr=PI;
                if (argl>argr+eps)
                {
                    evt.push_back({argl,1}); evt.push_back({PI,-1});
                    evt.push_back({-PI,1}); evt.push_back({argr,-1});
                }
                else
                {
                    evt.push_back({argl,1});
                    evt.push_back({argr,-1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        int sum=init;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            if (abs(evt[i].first-evt[i+1].first)>eps) arcs[sum].push_back({ci.c,ci.r,evt[i].first,evt[i+1].first});
            if (abs(evt[i+1].first-PI)<=eps) break;
        }
    };

    const auto oint=[](const arc_t &arc)
    {
        const auto [cc,cr,l,r]=arc;
        if (abs(r-l-PI-PI)<=eps) return 2.0l*PI*cr*cr;
        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));
    };

    for (size_t i=0;i<circs.size();i++)
    {
        const auto &ci=circs[i];
        cut_circ(ci,i);
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(arcs[i].begin(),arcs[i].end());
        int cnt=0;
        for (size_t j=0;j<arcs[i].size();j++)
        {
            if (j>0 && eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);
            else cnt=0,sum+=oint(arcs[i][j]);
        }
        ans[i]=sum/2;
    }
    return ans;
}
```


<div style="page-break-after:always;"></div>

# Introduction

### 博弈 (game theory)

**博弈:** 博弈论是研究具有斗争或竞争性质现象的数学理论和方法

假设玩家的集合是 $N$ , 第 $i$ 个玩家的策略集合是 $\sum^{i}$ , 游戏的结果集合为 $\Gamma$ 

关于每个玩家使用不同的策略, 游戏产生对应的结果, 即 $\pi : \prod\limits_{i \in N} \sum^{i} \to \Gamma$

每个玩家对结果有不同的偏好, 用一个偏好函数 $v^{i} : \Gamma \to {\Bbb {R}}$ 描述, 则各玩家的最优策略可以看成是一个优化问题 $\max\limits_{s_i \in \sum^{i}} v^{i} (\pi (\dots, s_i, \dots))$ 

<br>

### 组合游戏 (combinatorial game)

**组合游戏**

+ 两个玩家
+ 一个状态集合
+ 游戏规则是指明玩家在一个状态下可以移动到哪些其它状态
+ 玩家轮流进行移动
+ 如果当前处于某个状态, 玩家根据规则无法移动, 则游戏结束
+ (大部分时候) 无论玩家如何选择, 游戏会在有限步以内结束

<br>

### Bash 游戏

```markdown
Bash 游戏
有一堆石子, 共 n 个, Alice 和 Bob 轮流取石子, 每次最少取 1 个, 最多取 k 个, 如果轮到某个玩家, 无法取石子, 则该玩家输
```

+ $Bash$ 游戏是一个组合游戏
+ 讨论这个游戏的最优策略, 以及在最优策略下谁会赢

**P 态和 N 态**

+ $P$ 态: 走到这个状态的玩家 $(previous \ player)$ 赢的状态
+ $N$ 态: 从这个状态走的玩家 $(next \ player)$ 赢的状态

**性质**

+ 至少能走到一个 $P$ 态的状态是 $N$ 态
+ 下一步只能走到 $N$ 态的状态是 $P$ 态

**正常规则与反常规则**

+ 正常规则 $(normal \ play \ rule)$: 终态是 $P$ 态 (无法走的人输)
+ 反常规则 $(misere \ play \ rule)$: 终态是 $N$ 态 (无法走的人赢)

$n$ 和 $k$ 都是变量, 怎么知道 $PN$ 态 ?

+ 打表, 找规律 ($DP$ 、搜索)
+ 猜结论
+ 证明 (利用 $PN$ 态的性质)

> 规律: `n % (k + 1) == 0` 的状态是 $P$ 态

<br>

### Nim 游戏

```markdown
Nim 游戏
假设有 n 堆石子, 第 i 堆石子一开始有 xi 个, Alice 和 Bob 轮流取石子, 每次当前玩家可以从某堆石子中取出一个到多个石子(可以取完, 但不能不取), 无法取石子的玩家输
```

**结论**

+ $P$ 态当且仅当 $x_1 \oplus x_2 \oplus \dots \oplus x_n = 0$ 
+ $N$ 态当且仅当 $x_1 \oplus x_2 \oplus \dots \oplus x_n > 0$ 

```markdown
反常 Nim 游戏
假设有 n 堆石子, 第 i 堆石子一开始有 xi 个, Alice 和 Bob 轮流取石子, 每次当前玩家可以从某堆石子中取出一个到多个石子(可以取完, 但不能不取), 无法取石子的玩家赢
```

**结论:** 如果所有 $1 \le i \le n$ , $x_i = 1$ , 则 $n$ 为奇数是 $P$ 态, 偶数为 $N$ 态. 否则和 $Nim$ 游戏一样

<br>

### 不平等游戏 (partizan game)

+ 平等游戏 $(impartial \ game)$: 规则对两个玩家是一致的
+ 不平等游戏 $(partizan \ game)$: 规则对两个玩家不一致

```markdown
不平等的 Bash 游戏
有一堆石子, 共 n 个, Alice 和 Bob 轮流取石子, Alice 每次可以取 1 到 3 个, Bob 每次可以取 1 到 2 个, 如果轮到某个玩家, 无法取石子, 则该玩家输. 讨论 Alice 先手和 Bob 先手的情况下的最优策略和结果
```

<div style="page-break-after:always;"></div>

# Sprague-Grundy 函数

### 图游戏

图游戏是一种组合游戏的抽象描述

**图游戏:** 给定一个有向图 $G = (V, E)$ , 其中 $V$ 是非空的节点集, $E$ 是有向边集. 两个人在图 $G$ 上进行游戏. 从起始节点 $x_0$ 出发, 轮流移动. 每一轮当前玩家可以从当前节点 $x$ 按照有向边集移动到下一个节点, 把 $x$ 可以一步移动到的节点集合记为 $F(x)$ . 如果 $F(x)$ 为空, 则 $x$ 为终止节点, 此时玩家不能移动, 游戏结束. (在正常游戏下不能移动的玩家输)

<br>

### Sprague-Grundy 函数

**SG 函数:** 定义有向无环图 $G = (V, E)$ 的 $SG$ 函数是一个节点集 $V$ 到非负整数 ${\Bbb{Z}}_{\ge 0}$ 的映射 $g: V \to {\Bbb{Z}}_{\ge 0}$ , 满足 $g(x) = mex \ \{g(y) \ | \ y \in F(x) \}$ 

**SG 函数 vs PN 态**

(正常游戏下)

+ $x$ 是 $P$ 态当且仅当 $g(x) = 0$ 
+ $x$ 是 $N$ 态当且仅当 $g(x) > 0$ 

<br>

### 组合游戏的和

**组合游戏的和:** 给定多个组合游戏, 可以用如下方式把它们进行组合. 每个游戏都有一个初始状态, 每次当前玩家可以选择一个游戏, 并按照该游戏的规则移动一次, 如果轮到当前玩家, 所有游戏都不能移动, 则该玩家输 (正常规则). 称这个新的组合游戏为这些组合游戏的和

**图游戏的和**

假设给定 $n$ 个有向无环图 $G_i(V_i, E_i)$ , 则它们的图游戏的和 $G(V, E)$ 满足

+ $V = V_1 \times V_2 \times V_3 \times \dots \times V_n$ 
+ 节点 $x = (x_1, x_2, \dots , x_n)$ 一步能到 $F(x) = \bigcup_{i = 1}^{n} \{(x_1, x_2, \dots, y_i, \dots, x_n) \ | \ y_i \in F_i(x_i) \}$ 

记 $G$ 为 $G_1 + G_2 + \dots + G_n$ 

<br>

### Sprague-Grundy 定理

**SG 定理:** 假设有 $n$ 个组合游戏 $G_1, G_2, \dots, G_n$ , 记 $g_i$ 为第 $i$ $(1 \le i \le n)$ 个组合游戏的 $SG$ 函数, 则它们的和 $G = G_1 + G_2 + \dots + G_n$ 的 $SG$ 函数 $g(x) = g((x_1, x_2, \dots, x_n)) = g_1(x_1) \oplus g_2(x_2) \oplus \dots\oplus g_n(x_n)$ 

**SG 定理的推论**

假设 $G = G_1 + G_2 + \dots + G_n$ 

+ $x = (x_1, x_2, \dots, x_n)$ 是 $P$ 态当且仅当 $g_1(x_1) \oplus g_2(x_2) \oplus \dots \oplus g_n(x_n) = 0$ 
+ $x = (x_1, x_2, \dots, x_n)$ 是 $N$ 态当且仅当 $g_1(x_1) \oplus g_2(x_2) \oplus \dots \oplus g_n(x_n) > 0$ 

<br>

### 分裂游戏 (Take-and-Break Games)

```markdown
Lasker's Nim
n 堆石子, 每次玩家可以
	+ 从一堆中取走若干个石子
	+ 把一堆石子分成两非空的堆 
```

**Lasker's Nim 的 SG 函数**

$sg(x) = mex \ \{sg(0), sg(1), \dots, sg(x - 1), sg(1) \oplus sg(x - 1), sg(2) \oplus sg(x - 2), \dots, sg(x - 1) \oplus sg(1) \}$

$sg(x) = \left\{\begin{matrix} 
  0 \quad\quad\quad\quad x = 0 \quad\quad\quad\\  
  x \quad x = 4k + 1 或 4k + 2\\
  4k + 4 \quad\quad x = 4k + 3 \quad\quad\quad\\
  4k + 3 \quad\quad x = 4k + 4 \quad\quad\quad
\end{matrix}\right. $ 

<br>

### 隐藏的 Nim

```markdown
移动棋子
有一个 1 × n 的棋盘, 其中每个格子可以有多个棋子, 每次选择一个棋子, 将其移动到更左边的任意一个格子, 两人轮流移动, 不能移动则输
```

```markdown
取放石子
有 n 堆石子, 排成一行, 标号为 1, 2, ..., n, 每次可以选择两堆 i < j, 满足第 i 堆中至少有一个石子, 当前玩家从第 i 堆中取走一个石子, 并把一个石子放到第 j 堆中. 两人轮流操作, 不能操作的人输
```

<br>

### 树上的 Green Hackenbush

```markdown
Green Hackenbush
有一个无向图, 其中一些节点在地面(ground)上, 轮流操作, 每次操作可以任选一条边删除, 如果产生了一个不与地面连接的连通分量, 则这个连通分量也一并删除. 不能操作的人输
```

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\图：树的一个例子.png" alt="图：树的一个例子" style="zoom: 33%;" />

**Colon 原则 (简化版)**

假设 $H_1$ , $H_2$ 是两个 $Green \ Hackenbush$ 游戏, $G_1$ 是 $H_1$ 建立一个新的地面, 将原地面作为一个节点, 且这个节点与新的地面接触得到的游戏, $G_2$ 是 $H_2$ 以同样的方式得到的游戏. 若 $g(H_1) = g(H_2)$ , 则 $g(G_1) = g(G_2)$ 

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\图：Colon原则.png" alt="图：Colon原则" style="zoom: 25%;" />

```markdown
一棵 n 个节点是树, 每次删掉一条边, 并且删掉不与根相连的联通分量, 不能删的人输, 求谁赢
```

+ $g(u) = \oplus \{g(v) + 1 \}$ 其中遍历 $v$ 是 $u$ 的孩子

<div style="page-break-after:always;"></div>

# 经典的组合游戏

### Fibonacci Nim

```markdown
Fibonacci Nim
初始时有 n 个石子, 两个人轮流取石子. 规则为
	+ 先手第一次可以取 1 到 n - 1 个石子
	+ 之后每一次, 可取的数量为 1 到上一个人取的石子数的 2 倍
不能取的人输
```

**Zeckendorf's Theorem:** 每个正整数可以唯一的写成一些不相邻的 $Fibonacci$ 数的和

**PN 态:** 局面是 $P$ 态当且仅当 $n$ 为 $Fibonacci$ 数

**必胜策略**

+ 若 $n$ 不是 $Fibonacci$ 数, 假设 $n = F_{x_1} + F_{x_2} + \dots + F_{x_k}$ , 其中 $x_i > x_{i + 1} + 1$ $(1 \le i < k)$ , 则先手可取 $F_{x_k}$ 
+ 若 $n = F_x$ 是 $Fibonacci$ 数, 假设先手取 $m$ , $m < F_x$ 
  + 如果 $m \ge F_{x - 2}$ , 直接取完 $F_x - m$ 
  + 如果 $m < F_{x - 2}$ 
    + 如果 $m \ge F_{x - 4}$ , 取 $F_{x - 2} - m$ , 剩下一个 $F_{x - 1}$ 
    + 如果 $m < F_{x - 4}$ , $\dots$ 

<br>

### Chomp!

```markdown
Chomp 游戏
一开始有 n × m 块饼干, 排列成一个 n 行 m 列的矩形, 其中位于(1, 1) (左上角)的饼干是有毒的. 两个人轮流进行游戏, 每次可以取当前还没被取的一块饼干(x, y), 并把所有(i, j) 满足 i ≥ x 或 j ≥ y 的饼干都吃掉. 吃到有毒的饼干就会死. 请问先手死还是后手死
```

**PN 态**

+ 所有 $n$ , $m$ , 满足 $\max (n, m) > 1$ 的矩形均为 $N$ 态
+ 证明: 如果先手取 $(n, m)$ 时后手存在必胜策略 $(a, b)$ , 则先手可以直接取 $(a, b)$ 

```markdown
有限偏序集上的 Chomp 游戏
设偏序集 (S, ≤), 其中 S 有限, 且 S 中存在最小元. 一开始 T = S, 可以取 x ∈ T, 并把 x ≤ y 的元素 y 从 T 中去掉. 取到最小元的人输
```

**结论:** 如果偏序集 $(S, \le)$ 存在最大元, 且 $|S| > 1$ , 则先手必胜

<br>

### Wythoff 游戏

```markdown
Wythoff 游戏
有两堆石子, 石子数分别为 n, m. 两个玩家轮流进行, 轮到一方的时候, 该玩家可以
	+ 从其中一堆石子中取走 x ≥ 1 个 (x不能超过该堆的石子数)
	+ 从两堆石子中同时取走 x ≥ 1 个 (x不能超过任意一堆的石子数)
如果轮到某方的时候, 玩家无法操作, 则该玩家输
```

$PN$ 态如图所示:

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Wythoff PN图.png" alt="Wythoff PN图" style="zoom: 25%;" />

$PN$ 态关于 $n$ , $m$ 是对称的, 将所有满足 $n \le m$ 的 $P$ 态按 $n$ 从小到大列出: $(0, 0)$ , $(1, 2)$ , $(3, 5)$ , $(4, 7)$ $\dots$ 

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Wythoff PN态.png" alt="Wythoff PN态" style="zoom: 25%;" />

**结论**

按上述过程得到的序列 $(a_i)_{i \ge 0}$ , $(b_i)_{i \ge 0}$ , 满足 $a_i = \lfloor \phi i \rfloor$ , $b_i = \lfloor \phi^2 i \rfloor$ 

其中 $\phi = \dfrac{1 + \sqrt{5}}{2}$ 是黄金分割比

**Beatty 序列:** 一个正无理数 $r$ 生成的 $Beatty$ 序列是指这样的一个序列 ${\cal{B}}_r = (\lfloor ri \rfloor)_{i \ge 1}$ 

**Rayleigh 定理:** 假设正无理数 $r > 1$ , $s$ 满足 $\dfrac{1}{r} + \dfrac{1}{s} = 1$ , 则 ${\cal{B}}_r$ 与 ${\cal{B}}_s$ 是全体正整数的一个分割. 即任意一个正整数存在且仅存在于 ${\cal{B}}_r$ 和 ${\cal{B}}_s$ 的其中一个序列

**结论证明**

思路: 证明 $a$ , $b$ 和 ${\cal{B}}_{\phi}$ , ${\cal{B}}_{\phi^2}$ 具有相同的递推关系, 且首项一致

***a, b 的递推关系***

$a_0 = b_0 = 0$ , 且对于 $i \ge 1$ , 满足 $a_i = mex \ \{a_j, b_j \ | \ j < i \}$ , $b_i = a_i + i$ 

***${\cal{B}}_r$ , ${\cal{B}}_s$ 的递推关系***

假设正无理数 $r$ , $s$ 满足 $1 < r < s$ 且 $\dfrac{1}{r} + \dfrac{1}{s} = 1$ , 则有 $({\cal{B}}_r)_i = mex \ \{0, ({\cal{B}}_r)_j, ({\cal{B}}_s)_j \ | \ j < i \}$ 

由于 $\phi^2 = \phi + 1$ , 得证

<br>

### 二分图博弈

```markdown
二分图博弈
给出一个二分图和一个起始点 H, 两人轮流操作, 每次只能选择一个与当前点相邻的之前没有被走过的点, 并走到该相邻点, 不能走的人输
```

**结论:** 如果二分图的最大匹配一定包含起始点 $H$ , 则先手必胜, 否则先手必败

**必胜策略**

+ 如果 $H$ 一定在最大匹配上, 先手按 $H$ 的匹配边走到下一个点
+ 如果 $H$ 不在其中一个最大匹配 ${\cal{M}}$ 上, 不管先手走哪个点 $P$ , 后手按 $P$ 的匹配边走到下一个点

<div style="page-break-after:always;"></div>

# Nim 积

### Coin Turning Games

```markdown
翻硬币游戏
有一些硬币, 排成一行, 其两面分别记成 T(tail) 和 H(head). 翻硬币游戏的规则如下:
	+ 每次可以翻一些硬币(H变为T, T变为H), 需要满足最右边的硬币是 H 翻到 T
	+ 每次可以翻的硬币集合, 只取决于最右边硬币
	+ 不能操作的人输(正常规则)
```

```markdown
每次可以翻一个当前为 H 的硬币. 假设该硬币从左到右数为第 k 个, 则可以再选择一个 1 ≤ i < k, 并翻转从左到右第 i 个硬币
```

+ 这个例子可以看成是一个 $Nim$ 游戏的变种
+ 假设局面为 $TTHTH$ , 则可以看成是两堆石子, 数量分别为 $3$ 和 $5$ 
+ 如果当前局面, 从左到右第 $x_1, x_2, \dots, x_k$ 个硬币为 $H$ , 其余为 $T$ , 把该局面记为 $(x_1, x_2, \dots, x_k)$ , 则它等价于 $k$ 个游戏 $(x_1), (x_2), \dots, (x_k)$ 的和
+ 这个性质可以推广到任何"翻硬币游戏"中

**SG 函数:** 假设当前局面为 $(x_1, x_2, \dots, x_k)$ , 则 $g(x_1, x_2, \dots, x_k) = g(x_1) \oplus g(x_2) \oplus \dots \oplus g(x_k)$ 

```markdown
每次可以翻一到三个硬币, 需要保证最右边的硬币为 H 
```

+ 为了方便, 用 $0-based$ 编号

$g(x) = mex \ \{0, g(0), g(1), \dots, g(x - 1), g(0) \oplus g(1), g(0) \oplus g(2), \dots, g(x - 1) \oplus g(x - 1) \}$ 

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\g(x).png" alt="g(x)" style="zoom: 25%;" />

+ 规律: $g(x) = 2x + [count(x) \equiv 0 \ (mod \ 2)]$ 

```markdown
二维的翻硬币游戏
一个硬币矩阵, 翻一些硬币, 保证右下角的硬币为 H. 能翻的硬币集合取决于所翻的右下角的硬币
```

```markdown
Turning Corners
每次可以翻一个矩形的四个角(a, b), (a, y), (x, b), (x, y), 其中 0 ≤ a < x, 0 ≤ b < y, 满足(x, y) 是 H
```

**SG 函数:** $g(x, y) = mex \ \{g(x, b) \oplus g(a, y) \oplus g(a, b) \ | \ 0 \le a < x, 0 \le b < y \}$ 

![Nim 积](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Nim 积.png)

<br>

### Nim 积

定义 $x \otimes y$ : $= mex \ \{(x \otimes b) \oplus (a \otimes y) \oplus (a \otimes b) \ | \ 0 \le a < x, 0 \le b < y\}$ 

+ 交换律: $\forall x, y \in {\Bbb{N}}.$ $x \otimes y = y \otimes x$ 
+ 结合律: $\forall x, y, z \in {\Bbb{N}}.$ $(x \otimes y) \otimes z = x \otimes (y \otimes z)$ 
+ 单位元: $\forall x \in {\Bbb{N}}.$ $1 \otimes x = x \otimes 1 = x$ 
+ 逆元: $\forall x \in {\Bbb{N}}.$ $\exist \  y \in {\Bbb{N}}.$ $x \otimes y = 1$ 
+ 分配律: $\forall x, y, z \in {\Bbb{N}}.$ $(x \oplus y) \otimes z = (x \otimes z) \oplus (y \otimes z)$ 

**定理:** $({\Bbb{N}}, \oplus, \otimes)$ 是一个域

**引理**

设 $A, B \subseteq {\Bbb{N}}$ , $mex \ A = a$ , $mex \ B = b$ , 则

+ $a \oplus b = mex \ \{a^* \oplus b, a \oplus b^* \ | \ a^* \in A, b^* \in B \}$​ 
+ $a \otimes b = mex \ \{(a^* \otimes b) \oplus (a \otimes b^*) \oplus (a^* \otimes b^*) \ | \ a^* \in A, b^* \in B \}$ 

<br>

### 计算 $x \otimes y$ 

+ $Fermat \ 2-power$: $F_n = 2^{2^n}$ 

+ **计算 $F_n \otimes F_m$** 
  + $n < m$ , $F_n \otimes F_m = F_nF_m$ 
  + $n = m$ , $F_n \otimes F_m = \dfrac{3}{2}F_n$ 

+ 计算 $2^a \otimes 2^b$ , 设 $a = \sum_{i \in I} 2^i$ , $b = \sum_{j \in J}2^j$ 
  + $2^a \otimes 2^b = (\bigotimes\limits_{i \in I}2^{2^i}) \otimes (\bigotimes\limits_{j \in J}2^{2^j}) = (\prod\limits_{k \in (I \cup J) - (I \cap J)} 2^{2^k}) \otimes (\prod\limits_{p \in (I \cap J)} \dfrac{3}{2}2^{2^p})$ 

+ 计算 $x \otimes y$ , 分配律

```c++
int sg[40][40]; //需要初始化为-1
int f(int, int); //声明一下, 因为f与g互相嵌套调用
int g(int x, int y) //计算2^x与2^y的nim积
{
    if(sg[x][y] != -1) //记忆化搜索
    {
        return sg[x][y];
    }
    if(!x) //x==0也就是1与2^y的nim积, 等于2^y
    {
        return sg[x][y] = 1 << y;
    }
    if(!y) //同上
    {
        return sg[x][y] = 1 << x;
    }
    int ans = 1, k = 1, t;
    int x1 = x, y1 = y;
    while(x || y) //再将x和y分为二进制, 这里计算那些普通乘积的(即对应二进制位不同的)
    {
        t = 1 << k; //从此位得到的最终的数2^k
        if((x & 1 || y & 1) && !((x & 1) && (y & 1))) //该位不同
        {
            ans *= t;
        }
        x >>= 1;
        y >>= 1;
        k <<= 1; //从此位得到的指数(本身也是2的幂)
    }
    k = 1;
    x = x1;
    y = y1;
    while(x || y) //计算那些相同的fermat 2-power 数, 与已得出的数的nim积
    {
        t = 1 << k;
        if((x & 1) && (y & 1)) //该位相同
        {
            ans = f(ans, t / 2 * 3);
        }
        x >>= 1;
        y >>= 1;
        k <<= 1; //从此位得到的指数(本身也是2的幂)
    }
    return (sg[x1][y1] = ans);
}
int f(int x, int y) //计算二维的nim积
{
    if(!x || !y) return 0;
    if(x == 1) return y;
    if(y == 1) return x;
    int ans = 0;
    for(int i = x, a = 0; i; i >>= 1, a++) //完成(将x和y分解后)按分配律计算其积
    {
        if((i & 1) == 0) continue; //该位(bit)是1才计算, 否则跳过
        for(int j = y, b = 0; j; j >>= 1, b++)
        {
            if((j & 1) == 0) continue;
            ans ^= g(a, b);
        }
    }
    return ans;
}
```

```c++
//单次 O(log^2 n) 分治实现
ull nimProd(ull x, ull y, int p = 32) {
    if (x <= 1 || y <= 1) return x * y;
    if (p < 8 && rem[x][y]) return rem[x][y];
    ull a = x >> p, b = ((1ull << p) - 1) & x, c = y >> p, d = ((1ull << p) - 1) & y;
    ull bd = nimProd(b, d, p >> 1), ac = nimProd(nimProd(a, c, p >> 1), 1ull << p >> 1, p >> 1), ans;
    ans = ((nimProd(a ^ b, c ^ d, p >> 1) ^ bd) << p) ^ ac ^ bd;
    if (p < 8) rem[x][y] = rem[y][x] = ans;
    return ans;
}
```

<br>

### 逆元

**逆元:** $\forall a \in {\Bbb{N}}.$ $\exist \ b \in {\Bbb{N}} \ a \otimes b = 1$ , 记其为 $1 / a$ 或 $a^{-1}$ 

**计算 $1 / a$ :** 假设 $a < F_n$ , 则 $1 / a = a^{\otimes F_n - 2}$ , 其中 $a^{\otimes k} = \underbrace{a \otimes a \otimes \dots \otimes a}_{k}$ 

**递归构造**

$1 / a$ 由 $mex(S)$ 给定, 其中 $S$ 是满足以下条件的最小的 $S$ :

+ $0 \in S$ 
+ 如果 $1 \le a' < a, b \in S$ , 那么 $\dfrac{1 \otimes ((a' \otimes a) \otimes b)}{a'} \in S$ 

<br>

### Nim 积对应的组合游戏

**$G_1 \times G_2$** 

假设 $G_1 = (V_1, E_1)$ , $G_2 = (V_2, E_2)$ , 是两个翻硬币游戏, 定义游戏 $G_1 \times G_2$ 为这两个游戏的乘积, 其状态集为 $V_1 \times V_2$ , 一个移动 $(x, y) \to (x', y')$ 是合法的, 当且仅当 $x \to x'$ 和 $y \to y'$ 分别在 $G_1$ 和 $G_2$ 中是合法的

**Tartan 定理**

假设 $G_1$ 和 $G_2$ 的 $SG$ 函数分别为 $g_1(x)$ 和 $g_2(y)$ , 则 $G_1 \times G_2$ 的 $SG$ 函数为 $g(x, y) = g_1(x) \otimes g_2(y)$ 

<div style="page-break-after:always;"></div>

# 不平等博弈

### Hackenbush

```markdown
Blue-Red Hackenbush
有一个图, 其中一个节点是地, 图的边有两种颜色: 蓝色和红色. 有两个玩家 Left 和 Right, 他们轮流进行游戏, 规则如下:
	+ 如果轮到 Left, 他可以任意删除一根蓝色的边, 并且删除所有不和地连接的节点/边
	+ 如果轮到 Right, 他可以任意删除一根红色的边, 并且删除所有不和地连接的节点/边
	+ 不能操作的人输 (正常规则)
```

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Hackenbush1.png" alt="Hackenbush1" style="zoom:25%;" />

**分析问题**

+ 假设当前局面是 $P$ 
+ 当前局面下, $Left$ 走一步可以得到的所有局面的集合为 $P_L$ 
+ 当前局面下, $Right$ 走一步可以得到的所有局面的集合为 $P_R$ 
+ 局面 $P$ 完全由 $P_L$ , $P_R$ 决定, 我们把 $P$ 记为 $\{P_L \ | \ P_R \}$ 

例: 没有任何边的图, 双方都没有任何选择, 当前局面为 $\{\empty \ | \ \empty \}$ 

例: 只有一条红边, $Left$ 没有任何选择, $Right$ 可以选择删除红边, 当前局面为 $\{\empty \ | \ \{\empty \ | \ \empty \} \}$ 

**局面的优势**

+ 对于 $\{ | \}$ , 此时先手必败, 双方都没有优势, 用 $0$ 标记这样的局面
+ 对于 $\{0 \ |  \}$ , 此时 $Left$ 必胜, 但 $Left$ 走一步后的局面是先手必败, 因此 $Left$ 的优势是 $1$ , 用 $1$ 标记这样的局面
+ 对于 $\{| \ 0 \}$ , 此时 $Right$ 必胜, 但 $Right$ 走一步后的局面是先手必败, 因此 $Left$ 的优势是 $-1$ , 用 $-1$ 标记这样的局面
+ 对于 $\{1 \ | \}$ , 此时 $Left$ 必胜, $Left$ 走一步后仍有优势 $1$ , 因此 $Left$ 的优势是 $2$ , 用 $2$ 标记这样的局面
+ 对于 $\{n - 1 \ | \}$ , 此时 $Left$ 走一步仍有优势 $n - 1$ , 因此 $Left$ 的优势是 $n$ , 用 $n$ 标记这样的局面 $(n > 0, n \in {\Bbb{N}})$ 
+ 对于 $\{| \ -(n - 1) \}$ , 此时 $Right$ 走一步仍有优势 $n - 1$ , 因此 $Left$ 的优势是 $-n$ , 用 $-n$ 标记这样的局面 $(n > 0, n \in {\Bbb{N}})$ 

**$1 / 2$ 的优势**

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Hackenbush2.png" alt="Hackenbush2" style="zoom:25%;" />

+ 考虑上图, $Left$ 走一步后局面为 $0$ , $Right$ 一步后局面为 $1$ , 因此当前局面为 $\{0 \ | \ 1 \}$ 
+ 把这个局面和 $-1$ 放在一起玩, 组合而成的局面 $\{0 \ | \ 1 \} + (-1)$ 是 $Right$ 必胜, 所以可以认为 $Left$ 的优势 $< 1$ 
+ 把两个 $\{0 \ | \ 1 \}$ 和 $-1$ 放在一起, 组合而成的局面是先手必败, 因此当前局面的优势为 $1 / 2$ 

**$1 / 4$ 的优势**

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Hackenbush3.png" alt="Hackenbush3" style="zoom:25%;" />

**规律**

![规律](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\规律.png)

**Hackenbush Tree**

将子树等价成一条链

<img src="E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\博弈专题\Hackenbush4.png" alt="Hackenbush4" style="zoom: 25%;" />

<div style="page-break-after:always;"></div>

# 初始与杂类模板

### wida.h

```c++
#include <bits/stdc++.h>
using namespace std;


/* tuple流输出定义 */
// helper: print elements with index IDX and higher of tuple t having MAX elements
template<int IDX, int MAX, typename... Args> struct PRINT_TUPLE {
    static void print(ostream &os, const tuple<Args...> &t) {
        os << get<IDX>(t) << (IDX + 1 == MAX ? "" : ",");
        PRINT_TUPLE<IDX + 1, MAX, Args...>::print(os, t);
    }
};
// partial specialization to end the recursion
template<int MAX, typename... Args> struct PRINT_TUPLE<MAX, MAX, Args...> {
    static void print(ostream &os, const tuple<Args...> &t) {}
};
// output operator for tuples
template<typename... Args> ostream &operator<<(ostream &os, const tuple<Args...> &t) {
    os << "[";
    PRINT_TUPLE<0, sizeof...(Args), Args...>::print(os, t);
    return os << "]";
}


/* pair流输出定义 */
template<class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) {
    return os << '[' << p.first << "," << p.second << ']';
}


/* 顺序容器流输出定义 */
template<class T, class = decay_t<decltype(*begin(declval<T>()))>,
class = enable_if_t<!is_same<T, string>::value>>
ostream &operator<<(ostream &os, const T &c) {
    os << "[";
    for (auto it = c.begin(); it != c.end(); ++it) {
        if (it != prev(c.end())) {
            os << *it << ", ";
        } else {
            os << *it << "]";
        }
    }
    return os;
}


/* stack流输出定义 */
template <class T>
ostream &operator<<(ostream &os, const stack<T> &S) {
    stack<T> s = S;
    os << "S[";
    while (s.size() > 1) {
        os << s.top() << ",";
        s.pop();
    }
    if (s.size()) {
        os << s.top();
    }
    os << ">";
    return os;
}


/* queue流输出定义 */
template <class T>
ostream &operator<<(ostream &os, const queue<T> &S) {
    queue<T> s = S;
    os << "Q<";
    while (s.size() > 1) {
        os << s.front() << ",";
        s.pop();
    }
    if (s.size()) {
        os << s.front();
    }
    os << "]";
    return os;
}


/* deque流输出定义 */
template <class T>
ostream &operator<<(ostream &os, const deque<T> &S) {
    deque<T> s = S;
    os << "[";
    while (s.size() > 1) {
        os << s.front() << ", ";
        s.pop_front();
    }
    if (s.size()) {
        os << s.front();
    }
    os << "]";
    return os;
}


/* priority_queue流输出定义 */
template <class T>
ostream &operator<<(ostream &os, const priority_queue<T> &S) { // 大根堆
    priority_queue<T> s = S;
    os << "[";
    while (s.size() > 1) {
        os << s.top() << ", ";
        s.pop();
    }
    if (s.size()) {
        os << s.top();
    }
    os << "]";
    return os;
}
template <class T>
ostream &operator<<(ostream &os, const priority_queue<T, vector<T>, greater<T>> &S) { // 小根堆
    priority_queue<T, vector<T>, greater<T>> s = S;
    os << "[";
    while (s.size() > 1) {
        os << s.top() << ", ";
        s.pop();
    }
    if (s.size()) {
        os << s.top();
    }
    os << "]";
    return os;
}


/* 可变模板输出 */
template<class... Args> void _(Args... args) {
    auto _ = [&](auto x) -> void { cout << x << "▏"; };
    cout << "●";
    int arr[] = {(_(args), 0)...};
    cout << "\n";
}
template<class... Args> void _1(Args... args) {
    auto _ = [&](auto x) -> void { cout << x << "▏"; };
    cout << "  ●";
    int arr[] = {(_(args), 0)...};
    cout << "\n";
}
template<class... Args> void _2(Args... args) {
    auto _ = [&](auto x) -> void { cout << x << "▏"; };
    cout << "  ▲";
    int arr[] = {(_(args), 0)...};
    cout << "\n";
}
template<class... Args> void _3(Args... args) {
    auto _ = [&](auto x) -> void { cout << x << "▏"; };
    cout << "  ▼";
    int arr[] = {(_(args), 0)...};
    cout << "\n";
}

// 常用宏定义
#define FOR(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)
#define FOR2(i, a, b) for (int i = (int)(a); i <= (int)(b); i += 2)
#define FORD(i, b, a) for (int i = (int)(a); i >= (int)(b); i--)
#define ALL(a) a.begin(), a.end()
#define rALL(a) a.rbegin(), a.rend()
#define ED exit(0);
#define CE continue;
#define CO continue;
#define BK break;
```

<div style="page-break-after:always;"></div>

### 在线头文件

```c++
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

namespace WIDA {
    // 常用宏定义
    using PII = pair<int, int>;
    using TII = tuple<int, int, int>;
    #define mymap __gnu_pbds::gp_hash_table
    #define FOR(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)
    #define FOR2(i, a, b) for (int i = (int)(a); i <= (int)(b); i += 2)
    #define FORD(i, b, a) for (int i = (int)(a); i >= (int)(b); i--)
    #define ALL(a) a.begin(), a.end()
    #define RALL(a) a.rbegin(), a.rend()
    #define VI vector<int>
    #define MI map<int, int>
    #define RE return;
    #define RET return true;
    #define REF return false;
    #define Yes cout << "Yes" << endl;
    #define YES cout << "YES" << endl;
    #define No cout << "No" << endl;
    #define NO cout << "NO" << endl;
    #define pb push_back
    #define fi first
    #define se second
    #define sz size()
    
    // 常用库函数重定义
    template<typename T> T min(const vector<T> &v) {
        return *min_element(v.begin(), v.end());
    }
    template<typename T> T max(const vector<T> &v) {
        return *max_element(v.begin(), v.end());
    }
    template<typename T> T acc(const vector<T> &v) {
        return accumulate(v.begin(), v.end(), T(0LL));
    }
    template<class T> void reverse(vector<T> &v) {
        reverse(v.begin(), v.end());
    }
    template<class T> void sort(vector<T> &v) {
        sort(v.begin(), v.end());
    }
    template<class T> void rsort(vector<T> &v) {
        sort(v.rbegin(), v.rend());
    }
    template<class T> T mymax(T x, T y) {
        return x < y ? y : x;
    }
    template<class T> T mymin(T x, T y) {
        return x > y ? y : x;
    }
    template<class T> void cmax(T &x, T y) {
        x = mymax(x, y);
    }
    template<class T> void cmin(T &x, T y) {
        x = mymin(x, y);
    }
    template<class T> T sign(const T &a) {
        return a == 0 ? 0 : (a < 0 ? -1 : 1);
    }
    template<class T> T floor(const T &a, const T &b) {
        T A = abs(a), B = abs(b);
        assert(B != 0);
        return sign(a) * sign(b) > 0 ? A / B : -(A + B - 1) / B;
    }
    template<class T> T ceil(const T &a, const T &b) {
        T A = abs(a), B = abs(b);
        assert(b != 0);
        return sign(a) * sign(b) > 0 ? (A + B - 1) / B : -A / B;
    }
    int mypow(int n, int k, int p) {
        int r = 1;
        for (; k; k >>= 1, n = n * n % p) {
            if (k & 1) r = r * n % p;
        }
        return r;
    }
    template<class... Args> void __(Args... args) {
        auto _ = [&](auto x) { cout << x << " "; };
        int __[] = {(_(args), 0)...};
        cout << "\n";
    }
    const int N = 1e6 + 7;
    const int INF = numeric_limits<int>::max();
} // namespace WIDA

using namespace WIDA;


#ifndef ONLINE_JUDGE
    #define tout cout
    #include <bits/wida.h>
#else
    #define _(...)
#endif

#define endl "\n"
#define int long long


void solve() {
    
}

signed main() {
    
}

int __OI_INIT__ = []() {
    #ifndef ONLINE_JUDGE
        freopen("in.txt", "r", stdin);
        freopen("out.txt", "w", stdout);
    #endif
    ios::sync_with_stdio(0), cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(12);
    return 0;
}();
```

<div style="page-break-after:always;"></div>

### 在线头文件（简洁版）

```c++
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
    #include <bits/wida.h>
#endif


signed main() {
    int Task = 1;
    for (cin >> Task; Task; Task--) {
        
    }
}

int __OI_INIT__ = []() {
    ios::sync_with_stdio(0), cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(12);
    return 0;
}();
```

<div style="page-break-after:always;"></div>

### 基础函数重载

```c++
int mypow(int n, int k, int p = MOD) { // 复杂度是 log N
    int r = 1;
    for (; k; k >>= 1, n = n * n % p) {
        if (k & 1) r = r * n % p;
    }
    return r;
}
int mylcm(int x, int y) {
    return x / __gcd(x, y) * y;
}
int Log2(int x) { // 计算log2(x)，向下取整
    return 31 - __builtin_clz(x);
}
int ceiledLog2(int x) { // 计算log2(x)，但是向上取整
    return Log2(x) + (__builtin_popcount(x) != 1);
}
template <class T> T sign(const T &a) {
    return a == 0 ? 0 : (a < 0 ? -1 : 1);
}
template <class T> T floor(const T &a, const T &b) { // 注意大数据计算时会丢失精度
    T A = abs(a), B = abs(b);
    assert(B != 0);
    return sign(a) * sign(b) > 0 ? A / B : -(A + B - 1) / B;
}
template <class T> T ceil(const T &a, const T &b) { // 注意大数据计算时会丢失精度
    T A = abs(a), B = abs(b);
    assert(b != 0);
    return sign(a) * sign(b) > 0 ? (A + B - 1) / B : -A / B;
}
```

<div style="page-break-after:always;"></div>

### 对拍相关

**C++ 对拍** 

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    for (int Case = 1; Case <= 10000; Case ++) {
        cout << "==============\n";
        system("Juruo.exe");
        double start = clock();
        system("Shenben.exe");
        double end = clock();
        system("Ask.exe");
        
        if (system("fc Juruo.out Shenben.out")) {
            cout << "\033[31m" << "Wrong Answer\n" << "\033[0m";
            exit(0);
        } else {
            cout<< "\033[32m" << "Accept!\n"<< "\033[0m"; 
            cout << "测试点 #" << Case << "，用时"  << end - start << "ms\n";
        }
    }
    return 0;
}
```

**bat 对拍**

```c++
:loop
Ask
Juruo
Shenben
fc Juruo.out Shenben.out
if errorlevel==1 pause
goto loop
```

**样例编造**

```c++
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
    #include <bits/wida.h>
#endif
#define endl "\n"
#define int long long

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
int r(int a, int b) {
    return rnd() % (b - a + 1) + a;
}
template<class... Args> void __(Args... args) {
    auto _ = [&](auto x) { cout << x << " "; };
    int __[] = {(_(args), 0)...};
    cout << "\n";
}

signed main() {
    
}

int __Ask__ = []() {
    freopen("Ask.txt", "w", stdout);
    ios::sync_with_stdio(0), cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(12);
    return 0;
}();
```

**文件读写函数**

直接复制到文件底部即可，这样定义的空函数中的内容会自动先于 `main` 函数运行

```c++
int __Shenben__ = []() {
    freopen("Ask.txt","r",stdin);
    freopen("Shenben.out","w",stdout);
    return 0;
}();
```

```c++
int __Juruo__ = []() {
    freopen("Ask.txt","r",stdin);
    freopen("Juruo.out","w",stdout);
    return 0;
}();
```

<div style="page-break-after:always;"></div>

### 手工随机哈希

```c++
#include <ext/pb_ds/assoc_container.hpp>

struct myhash {
    static uint64_t hash(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const {
        static const uint64_t SEED = chrono::steady_clock::now().time_since_epoch().count();
        return hash(x + SEED);
    }
    size_t operator()(pair<uint64_t, uint64_t> x) const {
        static const uint64_t SEED = chrono::steady_clock::now().time_since_epoch().count();
        return hash(x.first + SEED) ^ (hash(x.second + SEED) >> 1);
    }
};
#define mymap __gnu_pbds::gp_hash_table

// mymap<int, int, myhash> dic;
// unordered_map<int, int, myhash> dic;
```

<div style="page-break-after:always;"></div>

### 全排列生成

```c++
int n;
cin >> n;
vector<int> a(n);
// iota(a.begin(), a.end(), 1);
for (auto &it : a) {
    cin >> it;
}
sort(a.begin(), a.end());

do {
    for (auto it : a) {
        cout << it << " ";
    }
    cout << endl;
} while (next_permutation(a.begin(), a.end()));
```

<div style="page-break-after:always;"></div>

### 快读

```c++
// 注意，在当前较新的 C++ 版本中，使用 getchar() 的快读是无意义的，只有使用 fread() 的才能提速

namespace QuickRead { // 快读
    char buf[1 << 21], *p1 = buf, *p2 = buf;
    inline int getc() {
        return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
    }
    template <typename T> void Cin(T &a) {
        T ans = 0;
        bool f = 0;
        char c = getc();
        for (; c < '0' || c > '9'; c = getc()) {
            if (c == '-') f = 1;
        }
        for (; c >= '0' && c <= '9'; c = getc()) {
            ans = ans * 10 + c - '0';
        }
        a = f ? -ans : ans;
    }
    template <typename T, typename... Args> void Cin(T &a, Args &...args) {
        Cin(a), Cin(args...);
    }
    template <typename T> void write(T x) { // 注意，这里输出不带换行
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
} // namespace QuickRead

using namespace QuickRead;
```

<div style="page-break-after:always;"></div>

### int128输入输出流控制

```c++
namespace my128 { // 读入优化封装，支持__int128
    using i64 = __int128_t;
    i64 abs(const i64 &x) {
        return x > 0 ? x : -x;
    }
    auto &operator>>(istream &it, i64 &j) {
        string val;
        it >> val;
        reverse(val.begin(), val.end());
        i64 ans = 0;
        bool f = 0;
        char c = val.back();
        val.pop_back();
        for (; c < '0' || c > '9'; c = val.back(), val.pop_back()) {
            if (c == '-') {
                f = 1;
            }
        }
        for (; c >= '0' && c <= '9'; c = val.back(), val.pop_back()) {
            ans = ans * 10 + c - '0';
        }
        j = f ? -ans : ans;
        return it;
    }
    auto &operator<<(ostream &os, const i64 &j) {
        string ans;
        function<void(i64)> write = [&](i64 x) {
            if (x < 0) ans += '-', x = -x;
            if (x > 9) write(x / 10);
            ans += x % 10 + '0';
        };
        write(j);
        return os << ans;
    }
} // namespace my128

using namespace my128;
```

<div style="page-break-after:always;"></div>

### 样例构造（随机数、树、图生成）

```c++
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
int r(int a, int b) {
    return rnd() % (b - a + 1) + a;
}

void graph(int n, int root = -1, int m = -1) {
    vector<pair<int, int>> t;
    for (int i = 1; i < n; i++) { // 先建立一棵以0为根节点的树
        t.emplace_back(i, r(0, i - 1));
    }

    vector<pair<int, int>> edge;
    set<pair<int, int>> uni;
    if (root == -1) {
        root = r(0, n - 1); // 确定根节点
    }
    for (auto [x, y] : t) { // 偏移建树
        x = (x + root) % n + 1;
        y = (y + root) % n + 1;
        edge.emplace_back(x, y);
        uni.emplace(x, y);
    }

    if (m != -1) { // 如果是图，则在树的基础上继续加边
        for (int i = n; i <= m; i++) {
            while (true) {
                int x = r(1, n), y = r(1, n);
                if (x == y) continue; // 拒绝自环
                if (uni.count({x, y}) || uni.count({y, x})) continue; // 拒绝重边
                edge.emplace_back(x, y);
                uni.emplace(x, y);
                break;
            }
        }
    }

    random_shuffle(edge.begin(), edge.end()); // 打乱节点
    for (auto [x, y] : edge) {
        cout << x << " " << y << endl;
    }
}
```

<div style="page-break-after:always;"></div>

# 斜率优化DP板子

```c++
/* 
2024_SCAU暑期个人排位赛1
evilboy_   =====   2024/7/9
Problem D
*/

#include <bits/stdc++.h>

#define x first
#define y second
#define endl '\n'
#define int long long

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;


const int N = 100010, M = N * 2;
const int INF = 0x3f3f3f3f;

int n, m;

void solve()
{
    cin >> n;
    vector<int> x(n + 1), p(n + 1), c(n + 1);
    vector<int> dp(n + 1);
    for(int i = 1; i <= n; i++)
        cin >> x[i] >> p[i] >> c[i];
    vector<int> cnt(n + 1), sum(n + 1);
    for(int i = 1; i <= n; i++)
    {
        cnt[i] = cnt[i - 1] + p[i];
        sum[i] = sum[i - 1] + p[i] * x[i];
    }

    // for(int i = 1; i <= n; i++)
    // {
    //     dp[i] = INF;
    //     for(int j = 0; j < i; j++)
    //         dp[i] = min(dp[i], dp[j] + (cnt[i] - cnt[j]) * x[i] - (sum[i] - sum[j]) + c[i]);
    // }
    // cout << dp[n] << endl;

    /* 斜率优化DP
    dp[i] = min{ dp[j] + (cnt[i] - cnt[j]) * x[i] - (sum[i] - sum[j]) + c[i] }
          = cnt[i] * x[i] - sum[i] + c[i] + min{ dp[j] - cnt[j] * x[i] + sum[j] }
          = cnt[i] * x[i] - sum[i] + c[i] + min{ dp[j] + sum[j] - cnt[j] * x[i] }
    dp[j] + sum[j] - cnt[j] * x[i]
    令 Y = dp[j] + sum[j], K = x[i], X = cnt[j]
    则 min{ Y - KX }
    令 B = Y - KX, 即 min{ B }

    斜率DP模板
    for(int i = 1; i <= n; i++)
    {
        while(hh < tt && (Y[q[hh + 1]] - Y[q[hh]]) <= (X[q[hh + 1]] - X[q[hh]]) * K[i])
            hh ++;
        dp[i] = ...
        while(hh < tt && (Y[q[tt]] - Y[q[tt - 1]]) * (X[i] - X[q[tt]]) >= (Y[i] - Y[q[tt]]) * (X[q[tt]] - X[q[tt - 1]]))
            tt --;
        q[++ tt] = i;
    }
    */
    vector<int> q(n + 1);
    int hh = 0, tt = 0;
    for(int i = 1; i <= n; i++)
    {
        while(hh < tt && ((dp[q[hh + 1]] + sum[q[hh + 1]]) - (dp[q[hh]] + sum[q[hh]])) <= (cnt[q[hh + 1]] - cnt[q[hh]]) * x[i])
            hh ++;
        dp[i] = dp[q[hh]] + (cnt[i] - cnt[q[hh]]) * x[i] - (sum[i] - sum[q[hh]]) + c[i];
        while(hh < tt && ((dp[q[tt]] + sum[q[tt]]) - (dp[q[tt - 1]] + sum[q[tt - 1]])) * (cnt[i] - cnt[q[tt]]) >= ((dp[i] + sum[i]) - (dp[q[tt]] + sum[q[tt]])) * (cnt[q[tt]] - cnt[q[tt - 1]]))
            tt --;
        q[++ tt] = i;
    }

    int ans = dp[n];
    while(n >= 0 && p[n] == 0)
        ans = min(ans, dp[-- n]);
    cout << ans << endl;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int T = 1;
    // cin >> T;
    while(T --)
        solve();

    return 0;
}

/*
题目描述
L 公司有 n 个工厂, 由高到低分布在一座山上, 工厂1在山顶, 工厂n在山脚。
由于这座山处于高原内陆地区(干燥少雨), L 公司一般把产品直接堆放在露天, 以节省费用。 突然有一天, 
L 公司的总裁 L 先生接到气象部门的电话, 被告知三天之后将有一场暴雨, 于是 L 先生决定紧急在某些工
厂建立一些仓库以免产品被淋坏。
由于地形的不同, 在不同工厂建立仓库的费用可能是不同的。 第 i 个工厂目前已有成品 pi 件, 在第 i 个
工厂位置建立仓库的费用是 ci 。
对于没有建立仓库的工厂, 其产品应被运往其他的仓库进行储藏, 而由于 L 公司产品的对外销售处设置在
山脚的工厂n, 故产品只能往山下运(即只能运往编号更大的工厂的仓库), 当然运送产品也是需要费用的,
一件产品运送一个单位距离的费用是 1 。
假设建立的仓库容量都是足够大的, 可以容下所有的产品。 你将得到以下数据:
+ 工厂 i 距离工厂 1 的距离 xi (其中 x1 = 0)
+ 工厂 i 目前已有成品数量 pi
+ 在工厂 i 建立仓库的费用 ci
请你帮助 L 公司寻找一个仓库建设的方案, 使得总的费用(建造费用 + 运输费用)最小

输入格式
输入的第一行是一个整数 n , 代表工厂的个数。
第 2 到 (n + 1) 行, 每行有三个用空格隔开的整数, 第 (i + 1) 行的整数依次代表 xi, pi, ci

输出格式
仅输出一行一个整数, 代表最优方案的费用。

样例
3
0 5 10
5 3 100
9 6 10

32
*/
```

<div style="page-break-after:always;"></div>

# 扩展卢卡斯定理

**扩展卢卡斯定理** 

求 $\dbinom{n}{m} \ mod \ p$ , 其中 $p$ 较小且不保证 $p$ 是质数

<br>

**Part 1: 中国剩余定理** 

首先按照唯一分解定理将 $p$ 分解质因数: $p= \prod\limits_{i = 1}^{k} q_i^{\alpha_i}$ 

如果能够求出 $\left\{\begin{matrix} 
  \dbinom{n}{m} \ mod \ q_1^{\alpha_1} \\  
  \dbinom{n}{m} \ mod \ q_2^{\alpha_2} \\ 
  \cdots \\
  \dbinom{n}{m} \ mod \ q_k^{\alpha_k} 
\end{matrix}\right. $ 

那么, 因为 $\forall i \ne j$ , $gcd(q_i^{\alpha_i}, q_j^{\alpha_j}) = 1$ , 所以可以用 `CRT` 合并

问题就变成了求解 $\dbinom{n}{m} \ mod \ q_i^{\alpha_i}$ 

<br>

**Part 2: 移除分子分母中的质因数** 

$\dbinom{n}{m} = \dfrac{n!}{m!(n - m)!} \equiv n! \cdot inv(m!) \cdot inv[(n - m)!] \ (mod \ q^{\alpha})$ 

但 $m!$ , $(n - m)!$ 与 $q^{\alpha}$ 不一定互质, 所以不一定存在逆元

我们将分子和分母中的 $q$ 的倍数全部提出来, 设 $n!$ , $m!$ , $(n - m)!$ 分别含 $x$ , $y$ , $z$ 个质因数 $q$ 

$\dfrac{n!}{m!(n - m)!} = \dfrac{\dfrac{n!}{q^x}}{\dfrac{m!}{q^y} \cdot \dfrac{(n - m)!}{q^z}} \cdot q^{x - y - z} \equiv \dfrac{n!}{q^x} \cdot inv(\dfrac{m!}{q^y}) \cdot inv[\dfrac{(n - m)!}{q^z}] \ (mod \ q^{\alpha})$ 

这时, $\dfrac{m!}{q^y}$ , $\dfrac{(n - m)!}{q^z}$ 都与 $q^{\alpha}$ 互质

<br>

**Part 3: 计算** 

以 $n!$ 为例: $n! = (q \times 2q \times \cdots \times \lfloor\dfrac{n}{q}\rfloor q) \times \prod\limits_{q \nmid i}i = q^{\lfloor \frac{n}{q} \rfloor} \times \lfloor \dfrac{n}{q} \rfloor! \times \prod\limits_{q \nmid i}^{n}i$ 

其中, $q^{\lfloor \frac{n}{q} \rfloor}$ 可以用快速幂直接算, $\lfloor \dfrac{n}{q} \rfloor!$ 可以递归求解, 后面的 $\prod\limits_{q \nmid i}^{n}i$ 就不好算了

我们发现, 因为模数是 $q^{\alpha}$ , 又有 $x + q^{\alpha} \equiv x \ (mod \ q^{\alpha})$ , 所以可以将 $q^{\alpha}$ 作为一个循环周期, 暴力算出 $\prod\limits_{q \nmid i}^{q^{\alpha}}i$ , 然后循环实际上有 $\lfloor \dfrac{n}{q^{\alpha}} \rfloor$ 个, 直接用快速幂

对于多出来的部分, 长度也一定小于 $q^{\alpha}$ , 也可以暴力算

以 $n = 19$ , $p = 3$ , $\alpha = 2$ 为例: 

$19! = 1 \times 2 \times 3 \times 4 \times 5 \times 6 \times 7 \times 8 \times 9 \times 10 \times 11 \times 12 \times 13 \times 14 \times 15 \times 16 \times 17 \times 18 \times 19$ 

$\quad\ = (1 \times 2 \times 4 \times 5 \times 7 \times 8) \times (10 \times 11 \times 13 \times 14 \times 16 \times 17) \times 19 \times (3 \times 6 \times 9 \times 12 \times 15 \times 18)$ 

$\quad\ = (1 \times 2 \times 4 \times 5 \times 7 \times 8) \times (10 \times 11 \times 13 \times 14 \times 16 \times 17) \times 19 \times 3^6 (1 \times 2 \times 3 \times 4 \times 5 \times 6)$ 

$\quad\ = (1 \times 2 \times 4 \times 5 \times 7 \times 8)^2 \times 19 \times 3^6 \times 6! \ (mod \ 3^2)$ 

$\quad\ = \prod\limits_{3 \nmid i}^{19}i \times 3^{\lfloor \frac{19}{3} \rfloor} \times \lfloor\dfrac{19}{3} \rfloor!$ 

再递归计算 $6! \ mod \ 3^2$ 即可

递归部分代码如下:

```c++
LL cal(LL n, LL p, LL pa) // pa = p ^ alpha
{
    if(!n) return 1;
    LL ans = 1;
    for(int i = 1; i <= pa; i++)
        if(i % p) ans = ans * i % pa;
    ans = qmi(ans, n / pa, pa);
    for(int i = 1; i <= n % pa; i++)
        if(i % p) ans = ans * i % pa;
    return ans * cal(n / p, p, pa) % pa;
}
```

这部分其实求的就是 $\dfrac{n!}{q^x}$ 

<br>

**Part 4: 合并** 

求出 $\dfrac{n!}{q^x}$ , $\dfrac{m!}{q^y}$ , $\dfrac{(n - m)!}{q^z}$ 后, 只需要求出 $x$ , $y$ , $z$ 就可以得到 $q^{x - y - z}$ 了

至此可以求出 $\dbinom{n}{m} \ mod \ q_i^{\alpha_i}$ , 使用 `CRT` 合并就完成了求解 $\dbinom{n}{m} \ mod \ p$ 的过程

<br>

**模板** 

```c++
LL n, m, p;
LL a[20], b[20];

LL qmi(LL m, LL k, LL p)
{
    LL res = 1;
    while(k)
    {
        if(k & 1) res = res * m % p;
        m = m * m % p;
        k >>= 1;
    }
    return res;
}

LL cal(LL n, LL p, LL pa) // pa = p ^ alpha
{
    if(!n) return 1;
    LL ans = 1;
    for(int i = 1; i <= pa; i++)
        if(i % p) ans = ans * i % pa;
    ans = qmi(ans, n / pa, pa);
    for(int i = 1; i <= n % pa; i++)
        if(i % p) ans = ans * i % pa;
    return ans * cal(n / p, p, pa) % pa;
}

LL cnt_p(LL n, LL m, LL p)
{
    LL cnt = 0;
    for(LL i = p; i <= n; i *= p)
        cnt += n / i;
    for(LL i = p; i <= m; i *= p)
        cnt -= m / i;
    for(LL i = p; i <= n - m; i *= p)
        cnt -= (n - m) / i;
    return cnt;
}

LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

LL inv(LL a, LL p)
{
    LL x, y;
    exgcd(a, p, x, y);
    x = (x % p + p) % p;
    return x;
}

LL C(LL n, LL m, LL p, LL pa) // pa = p ^ alpha
{
    LL a = cal(n, p, pa), b = cal(m, p, pa), c = cal(n - m, p, pa), cnt = cnt_p(n, m, p);
    return a * inv(b, pa) % pa * inv(c, pa) % pa * qmi(p, cnt, pa) % pa;
}

LL CRT(int n)
{
    LL m = 1;
    for(int i = 1; i <= n; i++)
        m *= a[i];
    LL ans = 0;
    for(int i = 1; i <= n; i++)
    {
        LL mi = m / a[i];
        LL Mi = inv(mi, a[i]);
        ans = (ans + b[i] * mi % m * Mi % m) % m;
    }
    return ans;
}

LL exLucas(LL n, LL m, LL p)
{
    int k = 0;
    for(LL i = 2; i <= p / i; i++)
        if(p % i == 0)
        {
            a[++ k] = 1;
            while(p % i == 0)
            {
                a[k] *= i;
                p /= i;
            }
            b[k] = C(n, m, i, a[k]);
        }
    if(p > 1)
    {
        a[++ k] = p;
        b[k] = C(n, m, p, p);
    }
    return CRT(k);
}

int main()
{
    cin >> n >> m >> p;
    cout << exLucas(n, m, p) << '\n';
}
```

<div style="page-break-after:always;"></div>

# DP 求本质不同子序列个数

+ 求长度为 $n$ 的序列 $a_1, a_2, \cdots, a_n$ 的本质不同子序列数

**Method 1** 

设 $f_i$ 表示以 $i$ 结尾 **且之前没出现过** 的子序列个数, $las_v$ 表示 $v$ 上一次出现的位置, 则

$f_i = \sum\limits_{j = las_{a_i}}^if_j$ 

前缀和优化即可 $O(n)$ 完成

```c++
int dif_sub(vector<int> a) // 1 base 数组, m 为字符集大小
{
    int n = a.size() - 1;
    vector<int> f(n + 1, 0), last(m + 1, 0);
    f[0] = 1;
    for(int i = 1; i <= n; i++)
    {
        f[i] = f[i - 1] - (last[a[i]] ? f[last[a[i]] - 1] : 0);
        f[i] += f[i - 1];
        last[a[i]] = i;
    }
    return f[n] - 1;
}
```

<br>

**Method 2** 

设 $f_i$ 表示前 $i$ 个数构成的本质不同子序列个数, $las_v$ 表示 $v$ 上一次出现的位置, 如果 $a_i$ 没有出现过, 那么 $f_i = 2f_{i - 1} + 1$ 

否则 $a_i$ 出现过, 因此需要减去重复统计的部分, $f_i = 2f_{i - 1} - f_{las_{a_i} - 1}$ 

```c++
int dif_sub(vector<int> a) // 1 base 数组, m 为字符集大小
{
    int n = a.size() - 1;
    vector<int> f(n + 1, 0), last(m + 1, 0);
    for(int i = 1; i <= n; i++)
    {
        f[i] = last[a[i]] ? 2 * f[i - 1] - f[last[a[i]] - 1] : 2 * f[i - 1] + 1;
        last[a[i]] = i;
    }
    return f[n];
}
```

<div style="page-break-after:always;"></div>

# k进制异或哈希

异或哈希利用了异或操作的特殊性和哈希降低冲突的原理, 可以用于快速找到一个组合是否出现、序列中的数是否出现了 $k$ 次

<br>

**例 1 (CF 1175F)** 

+ 给定一个长度为 $n$ 的数组 $a$ , 找到所有的连续子序列 $[l, r]$ 满足: 正好包含 $1$ 到 $r - l + 1$ (即 $1$ 到 $r - l + 1$ 的排列)
+ $1 \le n \le 3 \cdot 10^5$ , $1 \le a_i \le n$ 

朴素暴力 $O(n^3)$ :

从 $1$ 到 $n$ 遍历 $l$ , 从 $l$ 到 $n$ 遍历 $r$ , 判断 $[l, r]$ 是否包含 $1$ 到 $r - l + 1$ 

异或哈希 $O(n^2)$ :

根据异或的交换律可知, 对于 $n$ 的每个全排列, 异或和都相同. 可以通过异或和来判断数组中是否是一个排列, 但由于直接异或的结果集 $\approx n$ , 所以一定会发生冲突

为了解决冲突, 可以利用哈希将异或的结果集扩大, 将数字 $i$ 哈希成 $64$ 位无符号整数. 那么结果集就扩大为了 $2^{64}$ , 冲突的概率是 $\dfrac{n \cdot (n - 1)}{2^{65}}$ 

```c++
mt19937_64 rnd(time(0));
typedef uint64_t hash_t;

const int N = 300010;
hash_t code[N], xorn[N], Xor[N];
int n, a[N];

void solve()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        code[i] = rnd();
        xorn[i] = xorn[i - 1] ^ code[i];
    }

    for(int i = 1; i <= n; i++)
        cin >> a[i];
    for(int i = 1; i <= n; i++)
        Xor[i] = Xor[i - 1] ^ code[a[i]];

    int res = 0;
    for(int l = 1; l <= n; l++)
        for(int r = l; r <= n; r++)
            if((Xor[r] ^ Xor[l - 1]) == xorn[r - l + 1])
                res ++;
    cout << res << '\n';
}
```

提取性质优化 $O(n)$ :

满足条件的区间肯定有且仅有一个 $1$ 和等于区间长度的最大值 $mx$ , 枚举右端点 $r$ 时维护 $[last_1, r]$ 区间的最大值 $mx$ , 同理对 $l$ 也扫一遍

```c++
mt19937_64 rnd(time(0));
typedef uint64_t hash_t;

const int N = 300010;
hash_t code[N], xorn[N], Xor[N];
int n, a[N];

void solve()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        code[i] = rnd();
        xorn[i] = xorn[i - 1] ^ code[i];
    }

    for(int i = 1; i <= n; i++)
        cin >> a[i];
    for(int i = 1; i <= n; i++)
        Xor[i] = Xor[i - 1] ^ code[a[i]];

    int res = 0;
    int last_one = 0, mx = 0;
    for(int r = 1; r <= n; r++)
    {
        if(a[r] == 1) 
        {
            res ++;
            last_one = r, mx = 1;
        }
        else if(last_one)
        {
            mx = max(mx, a[r]);
            if(mx >= (r - last_one + 1) && r - mx + 1 >= 1)
            {
                int l = r - mx + 1;
                if((Xor[r] ^ Xor[l - 1]) == xorn[mx])
                    res ++;
            }
        }
    }
    last_one = 0, mx = 0;
    for(int l = n; l >= 1; l--)
    {
        if(a[l] == 1)
            last_one = l, mx = 1;
        else if(last_one)
        {
            mx = max(mx, a[l]);
            if(mx >= (last_one - l + 1) && l + mx - 1 <= n)
            {
                int r = l + mx - 1;
                if((Xor[r] ^ Xor[l - 1]) == xorn[mx])
                    res ++;
            }
        }
    }
    cout << res << '\n';
}
```

<br>

**例 2** 

+ 给定一个长度为 $n$ 的数组 $a$ , 找到所有的连续子序列 $[l, r]$ 满足: 所有 $a_i, \ i \in [l, r]$ 出现的次数都是 $k$ 的倍数

将 $2$ 进制推广到 $k$ 进制即可

```c++
const int N = 60;

typedef array<int, N> num;

num operator ^(const num &a, const num &b){
    num c;
    for(int i = 0; i < N; i++)
    {
        c[i] = a[i] + b[i];
        if (c[i] >= k) c[i] -= k;
    }
    return c;
}

vector<num> nums(n);
    forn(i, n) forn(j, N) nums[i][j] = rnd() % k;
```

<br>

**例 3 (CF 1418G)** 

+ 给定一个长度为 $n$ 的数组 $a$ , 找到所有的连续子序列 $[l, r]$ 满足: 所有 $a_i, \ i \in [l, r]$ 出现的次数都是 $3$ 次
+ $1 \le n \le 5 \cdot 10^5$ , $1 \le a_i \le n$ 

要让 $cnt = 3$ , 可以等价于 $cnt \ge 3$ 且 $cnt \le 3$ 

第一个约束 $cnt \ge 3$ 可以用 $3$ 进制下的哈希异或来维护

对于第二个约束, 考虑用类似于双指针的算法. 对于每一个满足约束二的区间 $[l, r]$ , 右指针每次往右移动, 都有可能会破坏原本"满足约束二"的性质. 为了让其重新满足约束二, 需要让左指针一直向右移动, 直到区间再次满足约束二. 每次对区间两个约束条件维护完毕后, 统计满足 $Xor_r = Xor_{pos}, \ pos \in [l, r]$ 的 $pos$ 数量, 可以用 $map$ 完成, 复杂度 $O(N \ log_2N)$ 

```c++
mt19937_64 rnd(42);
const int N = 60, k = 3;
typedef array<int, N> num;

num operator ^(const num &a, const num &b){
    num c;
    for(int i = 0; i < N; i++)
    {
        c[i] = a[i] + b[i];
        if (c[i] >= k) c[i] -= k;
    }
    return c;
}

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    vector<num> nums(n + 1);
    for(int i = 1; i <= n; i++)
        for(int j = 0; j < N; j++)
            nums[i][j] = rnd() % k;

    long long res = 0;
    vector<vector<int>> pos(n + 1, vector<int> ()); // 每个数字出现的位置
    vector<num> Xor(n + 1);
    map<num, long long> cnt;
    cnt[Xor[0]] = 1;
    for(int i = 1, j = 1; i <= n; i++)
    {
        pos[a[i]].push_back(i);
        Xor[i] = Xor[i - 1] ^ nums[a[i]];
        if(pos[a[i]].size() > k)
        {
            while(j < pos[a[i]][(int)pos[a[i]].size() - k - 1])
            {
                cnt[Xor[j - 1]] --;
                j ++;
            }
        }
        res += cnt[Xor[i]];
        cnt[Xor[i]] ++;
    } 
    cout << res << '\n';
}
```
