<h1 align = "center"> 邪童 の 鬼火笔记</h1>

<img src="E:\编程\笔记\鬼火笔记\队名图片\29.png" alt="29" style="zoom: 25%;" />

<img src="E:\编程\笔记\鬼火笔记\队名由来.png" alt="队名由来" style="zoom: 50%;" />

<div style="page-break-after:always;"></div>

![1-2023 ICPC Hangzhou Member1 Certificate10394854365439810813](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\1-2023 ICPC Hangzhou Member1 Certificate10394854365439810813.png)

![2-2024ICPC Wuhan9658802Medal16736833695189407132(1)(1)](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\2-2024ICPC Wuhan9658802Medal16736833695189407132(1)(1).png)

<div style="page-break-after:always;"></div>

![3-GDCPC2024_华南农业大学 _梁嘉俊 _陈国豪 _郑昊驰 _杨秋妹 _B(1)(1)](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\3-GDCPC2024_华南农业大学 _梁嘉俊 _陈国豪 _郑昊驰 _杨秋妹 _B(1)(1).png)

![4-CCPC2024YQSGZ_华南农业大学 _梁嘉俊 _陈国豪 _郑昊驰 _杨秋妹 _B](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\4-CCPC2024YQSGZ_华南农业大学 _梁嘉俊 _陈国豪 _郑昊驰 _杨秋妹 _B.jpg)

<div style="page-break-after:always;"></div>

![5-1005977-doi-cpc-in-the-company-Jiajun-Liang-Guohao-Chen-Qinzheng-He-Xiangji-Chen](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\5-1005977-doi-cpc-in-the-company-Jiajun-Liang-Guohao-Chen-Qinzheng-He-Xiangji-Chen.png)

![6-CCPC2024GSCQ_华南农业大学 _梁嘉俊 _何勤政 _陈国豪 _陈湘骥 _B](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\6-CCPC2024GSCQ_华南农业大学 _梁嘉俊 _何勤政 _陈国豪 _陈湘骥 _B.jpg)

<div style="page-break-after:always;"></div>

![7-The 2024 ICPC Asia Kunming Certificate Jiajun Liang 10309847494687413977595281](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\7-The 2024 ICPC Asia Kunming Certificate Jiajun Liang 10309847494687413977595281.png)

![8-099华南农业大学South China Agricultural University14128065454701854514(1)](E:\编程\笔记\鬼火笔记\图片\新建文件夹 (2)\8-099华南农业大学South China Agricultural University14128065454701854514(1).png)

<div style="page-break-after:always;"></div>

![宣言(1)](E:\编程\笔记\鬼火笔记\图片\宣言(1).jpg)

<div style="page-break-after:always;"></div>

## 目录

+ Manacher 封装
+ 笛卡尔树
+ 线段树上二分
+ 切糕模型
+ 数论分块
+ wqs二分
+ 区间问题 - 科技线段树
+ 吉司机线段树

<div style="page-break-after:always;"></div>

# Manacher

```c++
struct Manacher{
    int n, N;
    string s;
    vector<int> lc;
    vector<char> ch;
    Manacher(string _s){init(_s);manacher();}
    /* s 1 bas */ /* lc 0 bas */
    void init(string _s){
        n = _s.size();
        s = " " + _s;
        lc.resize(n * 2 + 10), ch.resize(n * 2 + 10);
        ch[n * 2 + 1] = '#';
        ch[0] = '@';
        ch[n * 2 + 2] = '\0';
        for(int i = n; i >= 1; i--) {
            ch[i * 2] = s[i];
            ch[i * 2 - 1] = '#';
        }
        N = 2 * n +1;
    }
    void manacher(){
        lc[1] = 1;  
        int k = 1;
        for(int i = 2; i <= N; i++) {
            int p = k + lc[k] - 1;
            if(i <= p) {
                lc[i] = min(lc[2 * k - i], p - i + 1);
            } else {  
                lc[i] = 1;  
            }
            while(ch[i + lc[i]] == ch[i - lc[i]]) lc[i] ++;
            if(i + lc[i] > k + lc[k]) k = i;
        }
    }
    void debug(){
        for(int i = 0; ch[i] != '\0'; i++)
            cout << ch[i];
        cout << '\n';
        for (int i = 1; i <= N; i++) {
            cout << "lc[" << i << "] = " << lc[i] << '\n';
        }
    }
};
```

<div style="page-break-after:always;"></div>

# 笛卡尔树

笛卡尔树是一种数据结构, 每个点由两个值, 键值 `key` 和权值 `val` 组成

+ 键值满足二叉树性质
  + 点的左子树内所有点的键值均小于点的键值, 右子树内所有点的键值均大于点的键值
  + 笛卡尔树按中序遍历就会得到原序列
  + 通常笛卡尔树的键值就是下标
+ 权值满足堆的性质
  + 可以是大根堆, 也可以是小根堆
  + 以小根堆为例, 点的权值是该点子树内所有点的权值最小值
  + 每个点代表一个连续区间的信息

+ 如果某笛卡尔树, 键值和权值互不相等, 则建出来的笛卡尔树是唯一的

![笛卡尔树](E:\个人博客\博客内容\算法竞赛\牛客算法进阶课\其它\偷情板子\笛卡尔树.png)

用栈维护笛卡尔树当前的右链, $O(n)$ 完成建树

```c++
int n = 11;
int h[] = {0, 9, 3, 7, 1, 8, 12, 10, 20, 15, 18, 5};
int lson[N], rson[N], root;

void build()
{
    stack<int> stk;
    for(int i = 1; i <= n; i++)
    {
        while(!stk.empty() && h[stk.top()] >= h[i])
            lson[i] = stk.top(), stk.pop();
        if(!stk.empty()) rson[stk.top()] = i;
        stk.push(i);
    }
    while(!stk.empty()) root = stk.top(), stk.pop();
}
```

<div style="page-break-after:always;"></div>

# 线段树上二分

**模板题 洛谷U502676** 

给出一段长度为 $n$ 的数列 $a$ 与 $m$ 个询问, 每组询问给出 $l$ , $r$ , $k$ , 询问在 $[l, r]$ 中第一个大于 $k$ 的数的位置 (下标). 如果不存在, 输出 $-1$ 

$1 \le n, m, k, a_i \le 2 \times 10^6$ , $1 \le l \le r \le n$ 

```c++
int n, m, a[N];
struct node {
    int l, r;
    int mx;
}tr[N * 4];

void pushup(int u) {
    tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
}

void build(int u, int l, int r) {
    tr[u] = {l, r};
    if(l == r) {
        tr[u].mx = a[l];
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

int query(int u, int l, int r, int k) {
    if(tr[u].mx <= k) return -1;
    if(tr[u].l >= l && tr[u].r <= r) {
        if(tr[u].l == tr[u].r) return tr[u].l;
        if(tr[u << 1].mx > k) return query(u << 1, l, r, k);
        else return query(u << 1 | 1, l, r, k);
    }
    int mid = tr[u].l + tr[u].r >> 1, res = -1;
    if(l <= mid) res = query(u << 1, l, r, k);
    if(r > mid && res == -1) res = query(u << 1 | 1, l, r, k);
    return res;
}

void solve()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    build(1, 1, n);

    while(m --) {
        int l, r, k;
        cin >> l >> r >> k;
        cout << query(1, l, r, k) << '\n';
    }
}
```

<div style="page-break-after:always;"></div>

**2023ICPC HK Problem L** 

给出一个长度为 $n$ 的排列 $a$ , 以及 $k$ 种操作, 每种操作可以删除长度正好为 $l_i$ 的区间中的最大值, 每种操作最多使用一次. 问是否能将排列 $a$ 通过操作变为 $b$ 

$1 \le m \le n \le 2 \cdot 10^5$ , $1 \le k \le 2 \cdot 10^5$ , $1 \le a_i, b_i, l_i \le n$ 

```c++
int n, m, k;
int a[N], b[N], pos[N];

struct Segment_Tree {
    struct node {
        int l, r, mx;
    }tr[N * 4];
    void pushup(int u) {
        tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r};
        if(l == r) {
            tr[u].mx = a[l];
            return;
        }
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int x, int c) {
        if(tr[u].l == tr[u].r) {
            tr[u].mx = c;
            return;
        }
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, c);
        else modify(u << 1 | 1, x, c);
        pushup(u);
    }
    int query_left(int u, int l, int r, int c) {
        if(tr[u].mx <= c) return 0;
        if(tr[u].l >= l && tr[u].r <= r) {
            if(tr[u].l == tr[u].r) return tr[u].l;
            if(tr[u << 1 | 1].mx > c) return query_left(u << 1 | 1, l, r, c);
            else return query_left(u << 1, l, r, c);
        }
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(r > mid) res = query_left(u << 1 | 1, l, r, c);
        if(l <= mid && res == 0) res = query_left(u << 1, l, r, c);
        return res;
    }
    int query_right(int u, int l, int r, int c) {
        if(tr[u].mx <= c) return n + 1;
        if(tr[u].l >= l && tr[u].r <= r) {
            if(tr[u].l == tr[u].r) return tr[u].l;
            if(tr[u << 1].mx > c) return query_right(u << 1, l, r, c);
            else return query_right(u << 1 | 1, l, r, c);
        }
        int mid = tr[u].l + tr[u].r >> 1, res = n + 1;
        if(l <= mid) res = query_right(u << 1, l, r, c);
        if(r > mid && res == n + 1) res = query_right(u << 1 | 1, l, r, c);
        return res;
    }
}Tr;

struct Binary_Indexeds_Tree {
    int tr[N];
    int lowbit(int x) {
        return x & -x;
    }
    void add(int x, int c) {
        for(int i = x; i <= n; i += lowbit(i))
            tr[i] += c;
    }
    int sum(int x) {
        int res = 0;
        for(int i = x; i; i -= lowbit(i))
            res += tr[i];
        return res;
    }
    void init() {
        for(int i = 1; i <= n; i++)
            tr[i] = 0;
        for(int i = 1; i <= n; i++)
            add(i, 1);
    }
}tr;

void solve()
{
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        pos[a[i]] = i;
    }
    vector<int> st(n + 1, 0);
    for(int i = 1; i <= m; i++) {
        cin >> b[i];
        st[b[i]] = 1;
    }
    multiset<int> del;
    for(int i = 0, x; i < k; i++) {
        cin >> x;
        del.insert(x);
    }

    int p = 1;
    for(int i = 1; i <= n; i++)
        if(a[i] == b[p]) p ++;
    if(p <= m) {
        cout << "NO\n";
        return;
    }

    Tr.build(1, 1, n);
    tr.init();
    for(int i = n; i >= 1; i--)
        if(!st[i]) {
            int l = Tr.query_left(1, 1, pos[i], i) + 1;
            int r = Tr.query_right(1, pos[i], n, i) - 1;
            int len = tr.sum(r) - tr.sum(l - 1);
            auto it = del.upper_bound(len);
            if(it == del.begin()) {
                cout << "NO\n";
                return;
            }
            del.erase(prev(it));
            Tr.modify(1, pos[i], 0);
            tr.add(pos[i], -1);
        }
    cout << "YES\n";
}
```

<div style="page-break-after:always;"></div>

# 切糕模型 (距离限制模型/基于最小割)

**切糕模型** 

距离限制模型, 基于最小割实现. 每个元素选择时, 有多种选择, 并且相邻两个元素之间的选择会相互限制.  

例题: [P3227 [HNOI2013\] 切糕](https://www.luogu.com.cn/problem/P3227)

习题: [2025春季HDU7-1006发送他们房子](https://acm.hdu.edu.cn/contest/problem?cid=1156&pid=1006) 、[The 3rd UCUP28-Currency](https://contest.ucup.ac/contest/1903/problem/9692)

进阶: 2016国集论文《网络流的一些建模方法》(姜志豪) 最小割离散变量模型、[P6054 [RC-02\] 开门大吉](https://www.luogu.com.cn/problem/P6054)

<br>

# P3227 [HNOI2013] 切糕

## 题目描述

经过千辛万苦小 A 得到了一块切糕，切糕的形状是长方体，小 A 打算拦腰将切糕切成两半分给小 B。出于美观考虑，小 A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。

出于简便考虑，我们将切糕视作一个长 P、宽 Q、高 R 的长方体点阵。我们将位于第 z 层中第 x 行、第 y 列上的点称 (x,y,z)，它有一个非负的不和谐值 v(x,y,z)。一个合法的切面满足以下两个条件：

- 与每个纵轴（一共有 P×Q 个纵轴）有且仅有一个交点。即切面是一个函数 f(x,y)，对于所有 (x,y)(x∈[1,P],y∈[1,Q])，我们需指定一个切割点 f(x,y)，且 1≤f(x,y)≤R。
- 切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的 1≤x,x′≤P 和 1≤y,y′≤Q，若 |x−x′|+|y−y′|=1，则 |f(x,y)−f(x′,y′)|≤D，其中 D 是给定的一个非负整数。

可能有许多切面 f 满足上面的条件，小 A 希望找出总的切割点上的不和谐值最小的那个。

## 输入格式

第一行是三个正整数 P,Q,R，表示切糕的长宽高。

第二行有一个非负整数 D，表示光滑性要求。

接下来是 R 个 P 行 Q 列的矩阵，第 z 个矩阵的第 x 行第 y 列是 v(x,y,z)(1≤x≤P,1≤y≤Q,1≤z≤R)。

## 输出格式

仅包含一个整数，表示在合法基础上最小的总不和谐值。

## 输入输出样例 #1

### 输入 #1

```
2 2 2
1
6 1
6 1
2 6
2 6
```

### 输出 #1

```
6
```

## 说明/提示

#### 输入输出样例 1 解释

最佳切面的 f 为 f(1,1)=f(2,1)=2,f(1,2)=f(2,2)=1。

#### 数据规模与约定

对于 100% 的数据，1≤P,Q,R≤40,0≤D≤R，且给出的所有的不和谐值不超过 1000。

<br>

假设没有高度差的限制, 源点向第1层连无限大的边, 点(x, y, z)向点(x, y, z+1)连边权为v(x, y, z)的边, 第r+1层向汇点连无限大的边. 建图跑最小割, 表示每一竖列取最小值. (以p=1, q=2, r=5, d=2为例)

![切糕1](file:///E:/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%9C%80%E5%90%8E%E4%B8%80%E5%B9%B4%EF%BC%8C%E5%BC%80%E4%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%A7/%E5%88%87%E7%B3%951.jpg?lastModify=1747664807)

建图来限制高度差, 点(x, y, z)向相邻竖的(x', y', z-d)连无限大的边. 如果选择了左侧选择了红边, 则右侧只能选择绿边上方的边, 否则无法将图割掉(中间的割边容量为inf不可选). 右侧同样往左侧连边, 可以完成高度差限制.

![切糕2](file:///E:/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%9C%80%E5%90%8E%E4%B8%80%E5%B9%B4%EF%BC%8C%E5%BC%80%E4%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%A7/%E5%88%87%E7%B3%952.jpg?lastModify=1747664807)

```c++
template<typename T> struct Flow_ {
    const int n;
    const T inf = numeric_limits<T>::max();
    struct Edge {
        int to;
        T w;
        Edge(int to, T w) : to(to), w(w) {}
    };
    vector<Edge> ver;
    vector<vector<int>> h;
    vector<int> cur, d;

    Flow_(int n) : n(n), h(n + 1) {}
    void add(int u, int v, T c)
    {
        h[u].push_back(ver.size());
        ver.emplace_back(v, c);
        h[v].push_back(ver.size());
        ver.emplace_back(u, 0);
    }
    bool bfs(int s, int t)
    {
        d.assign(n + 1, -1);
        d[s] = 0;
        queue<int> q;
        q.push(s);
        while(!q.empty())
        {
            auto x = q.front();
            q.pop();
            for(auto it: h[x])
            {
                auto [y, w] = ver[it];
                if(w && d[y] == -1)
                {
                    d[y] = d[x] + 1;
                    if(y == t) return true;
                    q.push(y);
                }
            }
        }
        return false;
    }
    T dfs(int u, int t, T f)
    {
        if(u == t) return f;
        auto r = f;
        for(int &i = cur[u]; i < h[u].size(); i++)
        {
            auto j = h[u][i];
            auto &[v, c] = ver[j];
            auto &[u, rc] = ver[j ^ 1];
            if(c && d[v] == d[u] + 1)
            {
                auto a = dfs(v, t, std::min(r, c));
                c -= a;
                rc += a;
                r -= a;
                if(!r) return f;
            }
        }
        return f - r;
    }
    T work(int s, int t)
    {
        T ans = 0;
        while(bfs(s, t))
        {
            cur.assign(n + 1, 0);
            ans += dfs(s, t, inf);
        }
        return ans;
    }
};
using Flow = Flow_<int>;

const int inf = 0x3f3f3f3f3f3f3f3f;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
void solve()
{
    int p, q, r, d;
    cin >> p >> q >> r >> d;
    vector<vector<vector<int>>> v(p + 1, vector<vector<int>> (q + 1, vector<int> (r + 1)));
    for(int k = 1; k <= r; k++)
        for(int i = 1; i <= p; i++)
            for(int j = 1; j <= q; j++)
                cin >> v[i][j][k];

    auto id = [&](int i, int j, int k) {
        return (k - 1) * p * q + (j - 1) * p + i;
    };

    Flow flow(p * q * (r + 1) + 2);
    int s = p * q * (r + 1) + 1, t = p * q * (r + 1) + 2;
    for(int i = 1; i <= p; i++)
        for(int j = 1; j <= q; j++) {
            flow.add(s, id(i, j, 1), inf);
            flow.add(id(i, j, r + 1), t, inf);
        }
    for(int i = 1; i <= p; i++)
        for(int j = 1; j <= q; j++)
            for(int k = 1; k <= r + 1; k++) {
                if(k + 1 <= r + 1) flow.add(id(i, j, k), id(i, j, k + 1), v[i][j][k]);
                if(k - d >= 1) {
                    for(int t = 0; t < 4; t++) {
                        int ii = i + dx[t], jj = j + dy[t];
                        if(ii >= 1 && ii <= p && jj >= 1 && jj <= q)
                            flow.add(id(i, j, k), id(ii, jj, k - d), inf);
                    }
                }
            }

    cout << flow.work(s, t) << '\n';
}
```

<br>

# 发送他们房子

## **Problem Description**

村里拆迁了，政府给村里的 n 户人家准备了一个安置小区。这个小区是长条型的，里面有 m 栋楼，这些楼房坐落在一条东西走向的马路旁，自西向东依次标号 1 ∼ m ，小区的大门在最西边，第 i 栋楼距离小区大门 pi 米。

拆迁户是挑剔的，每一户人家对每栋楼都有着不同的不满意度，记 si,j 为第 i 户人家对第 j 栋楼的不满意度。

你作为村委会干部被领导安排给这 n 户村民分配房子，**每栋楼里安置村民的户数没有上限**。

特别的，村民们向你提了 k 个条件，每个条件是这样的，由于第 x 户村民与第 y 户村民是好朋友，他们两户房子的相距不能超过 d 米。

现在你需要在满足这 k 个条件的前提下，给每户村民分配房子，使得总的不满意度最小。

## **Input**

第一行一个整数 T (1≤T≤11) ，表示测试数据组数。

每组数据的第一行包含三个整数 n, m ,k (1≤n×m≤2000,0≤k≤n(n−1)2,0≤k×m≤104) ，分别代表村民户数，小区楼数与村民要求数。

接下来一行 m 个整数 p1,p2,⋯,pm (0≤pi≤109) ，其中 pi 代表第 i 栋楼的位置。

接下来 n 行，每行包含 m 个整数 si,1,si,2,⋯si,m (1≤si,j≤1000) 。

接下来 k 行，每行包含三个整数 x, y, d (1≤x,y≤n,0≤d≤109) ，表示一个条件。

## **Output**

对于每组数据，输出一行一个整数，表示最小总不满意度。

## **Sample**

### **Sample Input**

```
2
4 2 4
1 2
6 2
1 6
6 2
1 6
1 2 2
1 3 2
2 4 2
3 4 2
4 2 2
1 3
6 2
1 6
6 2
1 6
1 2 1
1 3 1
```

### **Sample Output**

```
6
11
```

<br>

**注意: 限制割边连的是, 可以选的, 距离最大的边** 

```c++
template<typename T> struct Flow_ {
    const int n;
    const T inf = numeric_limits<T>::max();
    struct Edge {
        int to;
        T w;
        Edge(int to, T w) : to(to), w(w) {}
    };
    vector<Edge> ver;
    vector<vector<int>> h;
    vector<int> cur, d;

    Flow_(int n) : n(n), h(n + 1) {}
    void add(int u, int v, T c)
    {
        h[u].push_back(ver.size());
        ver.emplace_back(v, c);
        h[v].push_back(ver.size());
        ver.emplace_back(u, 0);
    }
    bool bfs(int s, int t)
    {
        d.assign(n + 1, -1);
        d[s] = 0;
        queue<int> q;
        q.push(s);
        while(!q.empty())
        {
            auto x = q.front();
            q.pop();
            for(auto it: h[x])
            {
                auto [y, w] = ver[it];
                if(w && d[y] == -1)
                {
                    d[y] = d[x] + 1;
                    if(y == t) return true;
                    q.push(y);
                }
            }
        }
        return false;
    }
    T dfs(int u, int t, T f)
    {
        if(u == t) return f;
        auto r = f;
        for(int &i = cur[u]; i < h[u].size(); i++)
        {
            auto j = h[u][i];
            auto &[v, c] = ver[j];
            auto &[u, rc] = ver[j ^ 1];
            if(c && d[v] == d[u] + 1)
            {
                auto a = dfs(v, t, std::min(r, c));
                c -= a;
                rc += a;
                r -= a;
                if(!r) return f;
            }
        }
        return f - r;
    }
    T work(int s, int t)
    {
        T ans = 0;
        while(bfs(s, t))
        {
            cur.assign(n + 1, 0);
            ans += dfs(s, t, inf);
        }
        return ans;
    }
};
using Flow = Flow_<int>;

typedef pair<int,int> pii;
const int inf = 0x3f3f3f3f3f3f3f3f;
void solve()
{
    int n, m, k;
    cin >> n >> m >> k;
    
    // 对房子按距离排序
    vector<pii> p(m + 1);
    for(int i = 1; i <= m; i++) {
        cin >> p[i].first;
        p[i].second = i;
    }
    sort(p.begin() + 1, p.end());
    vector<int> f(m + 1);   // 房子编号映射
    for(int i = 1; i <= m; i++)
        f[p[i].second] = i;

    auto id = [&](int i, int j) {
        return (j - 1) * n + i;
    };

    Flow flow(n * (m + 1) + 2);
    int s = n * (m + 1) + 1, t = n * (m + 1) + 2;
    for(int i = 1; i <= n; i++) {
        flow.add(s, id(i, 1), inf);
        flow.add(id(i, m + 1), t, inf);
    }
    for(int i = 1; i <= n; i++) {
        vector<int> s(m + 1);
        for(int j = 1; j <= m; j++)
            cin >> s[f[j]];
        for(int j = 1; j <= m; j++)
            flow.add(id(i, j), id(i, j + 1), s[j]);
    }

    while(k --) {
        int u, v, d;
        cin >> u >> v >> d;
        for(int i = m, j = m; i >= 1; i--) {
            while(j - 1 >= 1 && p[i].first - p[j - 1].first <= d)
                j --;
            flow.add(id(u, i), id(v, j), inf);
            flow.add(id(v, i), id(u, j), inf);
        }
    }

    cout << flow.work(s, t) << '\n';
}
```

<br>

# Currency

## **Problem Description**

There is a 2×n grid, and you need to walk from the top-left corner (1,1) to the bottom-right corner (2,n). Each edge has a weight, and there are m additional constraints. Each constraint is described by three integers, i, j, and c. What they mean is: if you traverse both edges (1,i) to (1,i+1) and (2,j) to (2,j+1), you incur an additional cost of c. Find the minimum value of the sum of the edge weights plus the costs incurred.

## **Input**

 The first line contains two integers, n and m (1≤n≤500;1≤m≤1000). 

The next three lines describe the weights of each edge:

The first of these lines contains n−1 integers, where the i-th integer represents the weight of the edge from (1,i) to (1,i+1). 

The second of these lines contains n integers, where the i-th integer represents the weight between (1,i) and (2,i). 

The third of these lines contains n−1 integers, where the i-th integer represents the weight of the edge from (2,i) to (2,i+1). 

All edge weights are positive and do not exceed 109. 

Each of the following m lines contains three integers, i, j, and c, representing a constraint (1≤i,j<n;1≤c≤109).

## **Output**

 Print a line containing a single integer: the answer to the problem.

## **Sample**

### **Sample Input**

```
 5 2
 2 3 5 2
 6 1 2 1 1
 1 2 4 2
 1 4 4
 2 3 1
```

### **Sample Output**

```
13
```

<br>

**题解:**  相当于对每个 i，我们需要在 (1,i) 到 (1,i+1) 与 (2,i) 到 (2,i+1) 之间选择一个走。选每一种需要一个代价，如果 i 和 i+1 选择了不同的行，那么就需要额外付出 (1,i+1) 到 (2,i+1) 之间边的代价。再加上 m 条限制，是一个小型的切糕模型，直接建图跑网络流即可。

相邻不同行的额外代价, 也可以等价为一个限制. 对于限制 (i,j,v) , 用如下方式建图

![切糕3](file:///E:/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%9C%80%E5%90%8E%E4%B8%80%E5%B9%B4%EF%BC%8C%E5%BC%80%E4%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%A7/%E5%88%87%E7%B3%953.jpg?lastModify=1747664807)

如果割掉了 i 下方的边和 j 下方的边, 即满足限制 (i,j,v) , 则必须同时割掉中间的割边, 才能将图完全割掉, 将中间的割边容量设为限制的额外代价即可. 

```c++
template<typename T> struct Flow_ {
	const int n;
	const T inf = numeric_limits<T>::max();
	struct Edge {
		int to;
		T w;
		Edge(int to, T w) : to(to), w(w) {}
	};
	vector<Edge> ver;
	vector<vector<int>> h;
	vector<int> cur, d;

	Flow_(int n) : n(n), h(n + 1) {}
	void add(int u, int v, T c)
	{
		h[u].push_back(ver.size());
		ver.emplace_back(v, c);
		h[v].push_back(ver.size());
		ver.emplace_back(u, 0);
	}
	bool bfs(int s, int t)
	{
		d.assign(n + 1, -1);
		d[s] = 0;
		queue<int> q;
		q.push(s);
		while(!q.empty())
		{
			auto x = q.front();
			q.pop();
			for(auto it: h[x])
			{
				auto [y, w] = ver[it];
				if(w && d[y] == -1)
				{
					d[y] = d[x] + 1;
					if(y == t) return true;
					q.push(y);
				}
			}
		}
		return false;
	}
	T dfs(int u, int t, T f)
	{
		if(u == t) return f;
		auto r = f;
		for(int &i = cur[u]; i < h[u].size(); i++)
		{
			auto j = h[u][i];
			auto &[v, c] = ver[j];
			auto &[u, rc] = ver[j ^ 1];
			if(c && d[v] == d[u] + 1)
			{
				auto a = dfs(v, t, std::min(r, c));
				c -= a;
				rc += a;
				r -= a;
				if(!r) return f;
			}
		}
		return f - r;
	}
	T work(int s, int t)
	{
		T ans = 0;
		while(bfs(s, t))
		{
			cur.assign(n + 1, 0);
			ans += dfs(s, t, inf);
		}
		return ans;
	}
};
using Flow = Flow_<int>;

const int inf = 0x3f3f3f3f3f3f3f3f;
void solve()
{
    int n, m;
	cin >> n >> m;

	auto id = [&](int i, int j) {
		return i * 3 + j;
	};

	Flow flow((n + 1) * 3 + 2);
	int s = (n + 1) * 3 + 1, t = (n + 1) * 3 + 2;
	
	for(int i = 0; i <= n; i++) {
		flow.add(s, id(i, 1), inf);
		flow.add(id(i, 3), t, inf);
	}
	// 起点在上方
	flow.add(id(0, 1), id(0, 2), 0);
	flow.add(id(0, 2), id(0, 3), inf);
	// 终点在下方
	flow.add(id(n, 1), id(n, 2), inf);
	flow.add(id(n, 2), id(n, 3), 0);
	for(int i = 1; i < n; i++) {
		int v;
		cin >> v;
		flow.add(id(i, 1), id(i, 2), v);
	}
	for(int i = 1; i <= n; i++) {
		int v;
		cin >> v;
		flow.add(id(i - 1, 2), id(i, 2), v);
		flow.add(id(i, 2), id(i - 1, 2), v);
	}
	for(int i = 1; i < n; i++) {
		int v;
		cin >> v;
		flow.add(id(i, 2), id(i, 3), v);
	}
	while(m --) {
		int i, j, v;
		cin >> i >> j >> v;
		flow.add(id(j, 2), id(i, 2), v);
	}

	cout << flow.work(s, t) << '\n';
} 
```

<div style="page-break-after:always;"></div>

# wqs二分

wqs 二分最初由王钦石在 2012 年国家集训队论文中提出, 而从 IOI 2016 的 Aliens 题目开始, 这种方法开始逐步在竞赛圈中有了一定的地位. 在国内一般称为 「wqs 二分」, 而在国外一般称为「Alien Trick」

wqs二分适用的题目类型:

> 给定 $n$ 个物品, 需要在其中**恰好**选择 $k$ 个, 并且需要最大化收益. 设对应的收益为 $g_k$ , 那么需要满足**在最大化收益的前提下, 每多选择一个物品, 额外产生的收益是单调递减的**, 也就是 $g_{k + 1} - g_k \le g_k - g_{k - 1}$ . 同时, 如果**对物品的选择数量没有限制**, 即 $k$ 不存在, 那么应当能够快速地计算出最大的收益, 以及达到最大的收益需要选择的物品数量. 

<br>

 由于增量单调性的存在, 如果将 $(k, g_k)$ 看成平面直角坐标系上的点, 那么这些点就组成了一个上凸壳:

<img src="E:\个人博客\博客内容\算法竞赛\最后一年，开个新文件夹吧\wqs1.jpg" alt="wqs1" style="zoom: 25%;" />

枚举所有斜率为 $c$ , 且经过上凸壳上一点的直线. 

<img src="E:\个人博客\博客内容\算法竞赛\最后一年，开个新文件夹吧\wqs2.jpg" alt="wqs2" style="zoom:25%;" />

假设斜率为 $c$ 的直线与上凸壳上点 $(k, g_k)$ 相切, 则该直线在 $y$ 轴上的截距为 $g_k - k \cdot c$ , 且该直线的截距是所有直线中最大的. 

可以这样理解这条切线的截距: $g_k$ 表示 $k$ 个物品带来的收益, 如果将这个收益减去 $k \cdot c$ , 那么就可以看做 **每一个物品带来的收益都减少了 $c$** . 

我们将所有物品的收益都减去 $c$ , 做没有限制的朴素问题求解, 得到的最大收益就是 $g_k - k \cdot c$ , 再加上 $k \cdot c$ , 得到的就是恰好选 $k$ 个物品的最大收益. 

由于上凸壳具有单调性, 斜率越大的直线, 会相切在上凸壳横坐标越小的点上. 因此, 如果能快速处理不带限制的朴素问题, 并且知道最大收益下的物品个数, 就能通过二分直线的斜率 $c$ , 使直线与横坐标为 $k$ 的上凸壳点相切, 从而求出带限制 $k$ 下的最大收益. 

<div style="page-break-after:always;"></div>

# 区间问题 - 科技线段树

**线段树处理一类统计区间数量问题** 

特征: 区间内每种数出现次数都恰好为 $k$ 次

例题: [D-Interval Selection_2024牛客暑期多校训练营7](https://ac.nowcoder.com/acm/contest/81602/D)

习题: [2023ICPC HK E. Goose, Goose, DUCK?](https://codeforces.com/gym/104172/problem/E) 、[B-Break Sequence_2024牛客暑期多校训练营9](https://ac.nowcoder.com/acm/contest/81604/B)

<br>

---

### 2024牛客多校7 D - Interval Selection

**题意: ** 给定一个长度为 $n$ $(1 \le n \le 2 \cdot 10^5)$ 的序列, 求区间 $[l, r]$ 个数, 满足区间内每个元素出现次数恰好为 $k$ $(1 \le k \le n)$ 

考虑倒序枚举左端点, 求合法右端点的个数. 对于第 $i$ 个元素:

它向右第 $k$ 个与 $a_i$ 相同元素的下标, 记为 $L$ , 向右第 $k + 1$ 个与 $a_i$ 相同元素的下标, 记为 $R$ 

当 $i$ 作为左端点 $l$ 时, 合法的右端点 $r$ 区间为 $[L, R - 1]$ 

用线段树标记不合法的位置, 对于以 $i$ 为左端点 $l$ 时, 合法的右端点 $r$ 数量, 即为区间 $[i, n]$ 中未被标记的下标数量

<br>

```c++
struct segment_tree {
    struct node {
        int l, r;
        // 最小值, 最小值个数, 懒标记
        int mn, cnt, lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        if(tr[u << 1].mn == tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
        }
        if(tr[u << 1].mn < tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].cnt = tr[u << 1].cnt;
        }
        if(tr[u << 1].mn > tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1 | 1].mn;
            tr[u].cnt = tr[u << 1 | 1].cnt;
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r, 0, 1, 0};
        if(l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    segment_tree(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void pushdown(int u) {
        if(tr[u].lazy) {
            tr[u << 1].mn += tr[u].lazy;
            tr[u << 1].lazy += tr[u].lazy;
            tr[u << 1 | 1].mn += tr[u].lazy;
            tr[u << 1 | 1].lazy += tr[u].lazy;
            tr[u].lazy = 0;
        }
    }
    void modify(int u, int l, int r, int c) {
        if(l > r) return;
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].mn += c;
            tr[u].lazy += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].cnt * (tr[u].mn == 0);
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res += query(u << 1, l, r);
        if(r > mid) res += query(u << 1 | 1, l, r);
        return res;
    }
};

void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1), alls;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        alls.push_back(a[i]);
    }
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    for(int i = 1; i <= n; i++)
        a[i] = lower_bound(alls.begin(), alls.end(), a[i]) - alls.begin();
    int m = alls.size();

    // 下一个相同元素的下标, 下 k 个相同元素的下标
    vector<int> nx(n + 1, 0), nk(n + 1, 0);
    vector<vector<int>> p(m, vector<int> ());
    for(int i = 1; i <= n; i++)
        p[a[i]].push_back(i);
    for(int i = 1; i <= n; i++) {
        int pos = lower_bound(p[a[i]].begin(), p[a[i]].end(), i) - p[a[i]].begin();
        if(pos + 1 < p[a[i]].size()) nx[i] = p[a[i]][pos + 1];
        if(pos + k - 1 < p[a[i]].size()) nk[i] = p[a[i]][pos + k - 1];
    }


    segment_tree Tr(n);
    auto update = [&](int i, int op) -> void {
        // 第 i 个位置作为左端点, 合法的右端点位于 [l, r)
        int l = nk[i] ? nk[i] : n + 1;
        int r = nx[nk[i]] ? nx[nk[i]] : n + 1;
        // 需要打标记的区间为 [i, l - 1], [r, n]
        Tr.modify(1, i, l - 1, op), Tr.modify(1, r, n, op);
    };

    int ans = 0;
    for(int i = n; i >= 1; i--) {
        // 消除上一个位置的标记
        if(nx[i]) update(nx[i], -1); 
        // 对当前位置的不合法右端点打标记
        update(i, 1);
        ans += Tr.query(1, i, n);
    }
    cout << ans << '\n';
}
```

<br>

---

### 2023ICPC HK E. Goose, Goose, DUCK?

**题意: ** 给定一个长度为 $n$ $(1 \le n \le 10^6)$ 的序列, 求区间 $[l, r]$ 个数, 满足区间内没有元素出现次数恰好为 $k$ $(1 \le k \le n)$ 

同样考虑倒序枚举左端点 $l$ , 对不合法的右端点 $r$ 打标记

<br>

```c++
struct segment_tree {
    struct node {
        int l, r;
        // 最小值, 最小值个数, 懒标记
        int mn, cnt, lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        if(tr[u << 1].mn == tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
        }
        if(tr[u << 1].mn < tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].cnt = tr[u << 1].cnt;
        }
        if(tr[u << 1].mn > tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1 | 1].mn;
            tr[u].cnt = tr[u << 1 | 1].cnt;
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r, 0, 1, 0};
        if(l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    segment_tree(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void pushdown(int u) {
        if(tr[u].lazy) {
            tr[u << 1].mn += tr[u].lazy;
            tr[u << 1].lazy += tr[u].lazy;
            tr[u << 1 | 1].mn += tr[u].lazy;
            tr[u << 1 | 1].lazy += tr[u].lazy;
            tr[u].lazy = 0;
        }
    }
    void modify(int u, int l, int r, int c) {
        if(l > r) return;
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].mn += c;
            tr[u].lazy += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].cnt * (tr[u].mn == 0);
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res += query(u << 1, l, r);
        if(r > mid) res += query(u << 1 | 1, l, r);
        return res;
    }
};

void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1), alls;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        alls.push_back(a[i]);
    }
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    for(int i = 1; i <= n; i++)
        a[i] = lower_bound(alls.begin(), alls.end(), a[i]) - alls.begin();
    int m = alls.size();

    // 下一个相同元素的下标, 下 k 个相同元素的下标
    vector<int> nx(n + 1, 0), nk(n + 1, 0);
    vector<vector<int>> p(m, vector<int> ());
    for(int i = 1; i <= n; i++)
        p[a[i]].push_back(i);
    for(int i = 1; i <= n; i++) {
        int pos = lower_bound(p[a[i]].begin(), p[a[i]].end(), i) - p[a[i]].begin();
        if(pos + 1 < p[a[i]].size()) nx[i] = p[a[i]][pos + 1];
        if(pos + k - 1 < p[a[i]].size()) nk[i] = p[a[i]][pos + k - 1];
    }


    segment_tree Tr(n);
    auto update = [&](int i, int op) -> void {
        // 第 i 个位置作为左端点, 不合法的右端点位于 [l, r)
        int l = nk[i] ? nk[i] : n + 1;
        int r = nx[nk[i]] ? nx[nk[i]] : n + 1;
        Tr.modify(1, l, r - 1, op);
    };

    int ans = 0;
    for(int i = n; i >= 1; i--) {
        // 消除上一个位置的标记
        if(nx[i]) update(nx[i], -1); 
        // 对当前位置的不合法右端点打标记
        update(i, 1);
        ans += Tr.query(1, i, n);
    }
    cout << ans << '\n';
}
```

<br>

---

### 2024牛客多校9 B - Break Sequence

**题意: ** 给定一个长度为 $n$ $(1 \le n \le 2 \cdot 10^5)$ 的序列和一个大小为 $m$ $(0 \le m \le 10)$ 的集合 $S$ , 求有多少种方案, 将原序列分割成若干个连续子序列, 满足每个子序列中, 出现元素的个数, 不等于集合 $S$ 中的数

考虑 $dp_i$ 表示以 $i$ 为某个分割左端点的方案数, 暴力转移就是枚举所有合法的右端点 $j$ , $dp_i \gets dp_{j + 1}$ , 最终 $dp_1$ 即为总方案数

同样的, 用线段树维护不合法的右端点下标, $dp$ 转移就是所有合法右端点下一位的 $dp$ 值之和

<br>

```c++
const int mod = 998244353;
struct segment_tree {
    struct node {
        int l, r;
        // 最小值, 最小值位置的dp之和, 懒标记
        int mn, dp_sum, lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        if(tr[u << 1].mn == tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].dp_sum = (tr[u << 1].dp_sum + tr[u << 1 | 1].dp_sum) % mod;
        }
        if(tr[u << 1].mn < tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1].mn;
            tr[u].dp_sum = tr[u << 1].dp_sum;
        }
        if(tr[u << 1].mn > tr[u << 1 | 1].mn) {
            tr[u].mn = tr[u << 1 | 1].mn;
            tr[u].dp_sum = tr[u << 1 | 1].dp_sum;
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r, 0, 0, 0};
        if(l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    segment_tree(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void pushdown(int u) {
        if(tr[u].lazy) {
            tr[u << 1].mn += tr[u].lazy;
            tr[u << 1].lazy += tr[u].lazy;
            tr[u << 1 | 1].mn += tr[u].lazy;
            tr[u << 1 | 1].lazy += tr[u].lazy;
            tr[u].lazy = 0;
        }
    }
    void modify(int u, int l, int r, int c) {
        if(l > r) return;
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].mn += c;
            tr[u].lazy += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].dp_sum * (tr[u].mn == 0) % mod;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res = (res + query(u << 1, l, r)) % mod;
        if(r > mid) res = (res + query(u << 1 | 1, l, r)) % mod;
        return res;
    }
    void update(int u, int x, int c) {
        if(tr[u].l == tr[u].r) {
            tr[u].dp_sum = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) update(u << 1, x, c);
        else update(u << 1 | 1, x, c);
        pushup(u);
    }
};

void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1), alls;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        alls.push_back(a[i]);
    }
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    for(int i = 1; i <= n; i++)
        a[i] = lower_bound(alls.begin(), alls.end(), a[i]) - alls.begin();
    int m = alls.size();
    vector<int> s(k);
    for(int i = 0; i < k; i++)
        cin >> s[i];

    // 下一个相同元素的下标
    vector<int> nx(n + 1, 0);
    vector<vector<int>> p(m, vector<int> ());
    for(int i = 1; i <= n; i++)
        p[a[i]].push_back(i);
    for(int i = 1; i <= n; i++) {
        int pos = lower_bound(p[a[i]].begin(), p[a[i]].end(), i) - p[a[i]].begin();
        if(pos + 1 < p[a[i]].size()) nx[i] = p[a[i]][pos + 1];
    }

    segment_tree Tr(n);
    auto update = [&](int i, int op) -> void {
        int pos = lower_bound(p[a[i]].begin(), p[a[i]].end(), i) - p[a[i]].begin();
        for(auto x: s) {
            // 第 i 个位置作为左端点, 不合法的右端点位于 [l, r)
            int l = pos + x - 1 < p[a[i]].size() ? p[a[i]][pos + x - 1] : n + 1;
            int r = pos + x < p[a[i]].size() ? p[a[i]][pos + x] : n + 1;
            Tr.modify(1, l, r - 1, op);
        }
    };

    vector<int> dp(n + 1, 0);
    Tr.update(1, n, 1);
    for(int i = n; i >= 1; i--) {
        // 消除上一个位置的标记
        if(nx[i]) update(nx[i], -1); 
        // 对当前位置的不合法右端点打标记
        update(i, 1);
        dp[i] = Tr.query(1, i, n);
        if(i - 1) Tr.update(1, i - 1, dp[i]);
    }
    cout << dp[1] << '\n';
}
```

<div style="page-break-after:always;"></div>

# 吉司机线段树

**吉司机线段树** 

维护区间最值和历史最值的线段树, 来源于《国家集训队2016论文集 - 区间最值操作与历史最值问题 杭州学军中学 吉如一》

例题: [HDU5306 Gorgeous Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=5306) 、[BZOJ4695 最假女选手](https://hydro.ac/p/bzoj-P4695)、 [U180387 CTSN loves segment tree - 洛谷](https://www.luogu.com.cn/problem/U180387) 、[P4314 CPU 监控 - 洛谷](https://www.luogu.com.cn/problem/P4314)、[【清华集训2015】V - 题目 - Universal Online Judge](https://uoj.ac/problem/164)、[【UR #11】元旦老人与数列 - 题目 - Universal Online Judge](https://uoj.ac/problem/169)

板题: [P6242 【模板】线段树 3（区间最值操作、区间历史最值） - 洛谷](https://www.luogu.com.cn/problem/P6242) 

进阶: [第十三届重庆市赛 G LCA & MST](https://codeforces.com/gym/105887)

还有一些找不到提交链接, 仅存在于吉司机论文中的题面描述: Picks loves segment tree 、AcrossTheSky loves segment tree 、Mzl loves segment tree、Dzy loves segment tree、Rikka with Sequences

<br>

---

### Gorgeous Sequence

**题意** 

给出一个长度为 $n$ 的数组 $A$ , 接下来有 $m$ 次操作, 操作有如下三种:

1. 给出 $l$ , $r$ , $x$ , 对所有的 $i \in [l, r]$ , 把 $A_i$ 变成 $min(A_i, x)$ 
2. 给出 $l$ , $r$ , 对所有的 $i \in [l, r]$ , 询问 $A_i$ 的最大值
3. 给出 $l$ , $r$ , 询问 $\sum_{i = l}^{r} A_i$ 

数据范围: $n, m \le 10^6$ 

**样例输入** 

```
1
5 5
1 2 3 4 5
1 1 5
2 1 5
0 3 5 3
1 1 5
2 1 5
```

**样例输出** 

```
5
15
3
12
```

<br>

因为在给一个节点打上区间取 $min$ 标记的时候, 我们无法快速更新区间和, 所以这一个问题是无法通过传统的懒标记来解决的. 

考虑对线段树中的每一个节点除了维护区间和 $sum$ 以外, 还要额外维护区间中的最大值 $ma$ 、严格次大值 $se$ 以及最大值个数 $t$ . 

现在假设我们要让区间 $[L, R]$ 对 $x$ 取 $min$ , 我们先在线段树中定位这个区间, 对定位的每一个节点, 我们开始暴力搜索. 搜索到每一个节点时, 我们分三种情况讨论: 

1. 当 $ma \le x$ 时, 显然这一次修改不会对这个节点产生影响, 直接退出. 
2. 当 $se < x < ma$ 时, 显然这一次修改只会影响到所有最大值, 所以我们把 $sum$ 加上 $t \cdot (x - ma)$ , 把 $ma$ 更新为 $x$ , 接着打上标记然后退出.
3. 当 $se \ge x$ 时, 我们无法直接更新这一个节点的信息, 因此在这时, 我们对当前节点的左儿子和右儿子进行递归搜索. 

通过势能分析, 可以证明这个算法的复杂度是 $O(m \log n)$ 的

<br>

```c++
const int N = 1000010;
int a[N];

struct Segment_Tree_Beats {
    struct node {
        int l, r;
        // 区间和, 最大值, 次大值, 最大值个数
        int sum, mx, se, cnt;
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
        tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
        if(tr[u << 1].mx == tr[u << 1 | 1].mx) {
            tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
            tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].se);
        } else if(tr[u << 1].mx > tr[u << 1 | 1].mx) {
            tr[u].cnt = tr[u << 1].cnt;
            tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].mx);
        } else {
            tr[u].cnt = tr[u << 1 | 1].cnt;
            tr[u].se = max(tr[u << 1].mx, tr[u << 1 | 1].se);
        }
    }
    void pushdown(int u) {  // 最大值即相当于懒标记
        if(tr[u << 1].mx > tr[u].mx) {
            tr[u << 1].sum -= (tr[u << 1].mx - tr[u].mx) * tr[u << 1].cnt;
            tr[u << 1].mx = tr[u].mx;
        }
        if(tr[u << 1 | 1].mx > tr[u].mx) {
            tr[u << 1 | 1].sum -= (tr[u << 1 | 1].mx - tr[u].mx) * tr[u << 1 | 1].cnt;
            tr[u << 1 | 1].mx = tr[u].mx;
        }
    }
    void build(int u, int l, int r) {
        if(l == r) {
            tr[u] = {l, r, a[l], a[l], -1, 1};
            return;
        }
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    /* 修改里看似没有处理 c <= tr[u].se 的情况
       但一直递归到叶子节点, 因为叶子节点自身是没有次大值的
       叶子节点一定会出现 c > tr[u].se 的情况

       需要注意的是: 当涉及区间 + 操作时, 叶子节点的次大值会被操作, 
       因此初始化时需要把叶子节点的次大值初始化为 -inf (而不是 -1)
    */
    void modify(int u, int l, int r, int c) {
        if(c >= tr[u].mx) return;
        if(tr[u].l >= l && tr[u].r <= r && c > tr[u].se) {
            tr[u].sum -= (tr[u].mx - c) * tr[u].cnt;
            tr[u].mx = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query_max(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].mx;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res = max(res, query_max(u << 1, l, r));
        if(r > mid) res = max(res, query_max(u << 1 | 1, l, r));
        return res;
    }
    int query_sum(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res += query_sum(u << 1, l, r);
        if(r > mid) res += query_sum(u << 1 | 1, l, r);
        return res;
    }
};

void solve()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    Segment_Tree_Beats Tr(n);
    while(m --) {
        int op;
        cin >> op;
        if(op == 0) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify(1, l, r, c);
        } else if(op == 1) {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_max(1, l, r) << '\n';
        } else {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_sum(1, l, r) << '\n';
        }
    }
}
```

<br>

---

### BZOJ4695 最假女选手

**题意** 

维护一个序列 $a$ , 执行以下操作: 

1. `1 l r x` $\forall \ l \le i \le r$ , $a_i = a_i + x$ 
2. `2 l r x` $\forall \ l \le i \le r$ , $a_i = max(a_i, x)$ 
3. `3 l r x` $\forall \ l \le i \le r$ , $a_i = min(a_i, x)$ 
4. `4 l r` 输出 $\sum\limits_{i = l}^{r} a_i$ 
5. `5 l r` 输出 $\max\limits_{i = l}^{r} a_i$ 
6. `6 l r` 输出 $\min\limits_{i = l}^{r}a_i$ 

数据范围: $n, m \le 5 \times 10^5$ , $|a_i| \le 10^8$ . 所有类型 $1$ 操作有 $|x| \le 10^3$ , 其余操作满足 $|x| \le 10^8$ 

**样例输入1** 

```
2
1 2
2
2 1 2 2
4 1 2
```

**样例输出1** 

```
4
```

<br>

同样的方法, 我们维护最大、次大、最大个数、最小、次小、最小个数、区间和. 除了这些信息, 我们还需要维护区间 $max$ 、区间 $min$ 、区间加的标记. 相比上一题, 这就涉及到标记下传的顺序问题了. 我们采取这样的策略: 

> 1. 我们认为区间加的标记是最优先的, 其余两种标记地位平等. 
> 2. 对一个结点加上一个 $v$ 标记, 除了用 $v$ 更新卫星信息和当前结点的区间加标记外, 我们用这个 $v$ 更新区间 $max$ 和区间 $min$ 的标记.
> 3. 对一个结点取 $v$ 的 $min$ (这里忽略暴搜的过程, 假定标记满足添加的条件), 除了更新卫星信息, 我们要与区间 $max$ 的标记做比较. 如果 $v$ 小于区间 $max$ 的标记, 则所有的数最后都会变成 $v$ , 那么把区间 $max$ 的标记也变成 $v$ . 否则不管. 
> 4. 区间取 $v$ 的 $max$ 同理. 

在维护信息的时候, 当只有一个数或两个数的时候可能发生数集重合, 比如一个数既是最大值又是次小值, 需要特判. 

<br>

```c++
const int N = 500010;
const int inf = 0x3f3f3f3f3f3f3f3f;
int a[N];

struct Segment_Tree_Beats {
    struct node {
        int l, r;
        // 区间和, 最大值, 次大值, 最大值个数
        // 最小值, 次小值, 最小值个数, 区间加懒标记
        int sum, mx, mx2, cmx, mn, mn2, cmn, lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
        tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
        tr[u].mn = min(tr[u << 1].mn, tr[u << 1 | 1].mn);
        if(tr[u << 1].mx == tr[u << 1 | 1].mx) {
            tr[u].cmx = tr[u << 1].cmx + tr[u << 1 | 1].cmx;
            tr[u].mx2 = max(tr[u << 1].mx2, tr[u << 1 | 1].mx2);
        } else if(tr[u << 1].mx > tr[u << 1 | 1].mx) {
            tr[u].cmx = tr[u << 1].cmx;
            tr[u].mx2 = max(tr[u << 1].mx2, tr[u << 1 | 1].mx);
        } else {
            tr[u].cmx = tr[u << 1 | 1].cmx;
            tr[u].mx2 = max(tr[u << 1].mx, tr[u << 1 | 1].mx2);
        }
        if(tr[u << 1].mn == tr[u << 1 | 1].mn) {
            tr[u].cmn = tr[u << 1].cmn + tr[u << 1 | 1].cmn;
            tr[u].mn2 = min(tr[u << 1].mn2, tr[u << 1 | 1].mn2);
        } else if(tr[u << 1].mn < tr[u << 1 | 1].mn) {
            tr[u].cmn = tr[u << 1].cmn;
            tr[u].mn2 = min(tr[u << 1].mn2, tr[u << 1 | 1].mn);
        } else {
            tr[u].cmn = tr[u << 1 | 1].cmn;
            tr[u].mn2 = min(tr[u << 1].mn, tr[u << 1 | 1].mn2);
        }
    }
    void pushdown(int u) {
        if(tr[u].lazy) {
            tr[u << 1].sum += (tr[u << 1].r - tr[u << 1].l + 1) * tr[u].lazy;
            tr[u << 1].lazy += tr[u].lazy;
            tr[u << 1].mx += tr[u].lazy, tr[u << 1].mx2 += tr[u].lazy, tr[u << 1].mn += tr[u].lazy, tr[u << 1].mn2 += tr[u].lazy;
            tr[u << 1 | 1].sum += (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * tr[u].lazy;
            tr[u << 1 | 1].lazy += tr[u].lazy;
            tr[u << 1 | 1].mx += tr[u].lazy, tr[u << 1 | 1].mx2 += tr[u].lazy, tr[u << 1 | 1].mn += tr[u].lazy, tr[u << 1 | 1].mn2 += tr[u].lazy;
            tr[u].lazy = 0;
        }
        if(tr[u << 1].mx > tr[u].mx) {
            tr[u << 1].sum -= (tr[u << 1].mx - tr[u].mx) * tr[u << 1].cmx;
            if(tr[u << 1].mn2 == tr[u << 1].mx) tr[u << 1].mn2 = tr[u].mx;
            if(tr[u << 1].mn == tr[u << 1].mx) {
                tr[u << 1].mn = tr[u].mx, tr[u << 1].mn2 = inf, tr[u << 1].cmn = tr[u << 1].r - tr[u << 1].l + 1;
            }
            tr[u << 1].mx = tr[u].mx;
        }
        if(tr[u << 1 | 1].mx > tr[u].mx) {
            tr[u << 1 | 1].sum -= (tr[u << 1 | 1].mx - tr[u].mx) * tr[u << 1 | 1].cmx;
            if(tr[u << 1 | 1].mn2 == tr[u << 1 | 1].mx) tr[u << 1 | 1].mn2 = tr[u].mx;
            if(tr[u << 1 | 1].mn == tr[u << 1 | 1].mx) {
                tr[u << 1 | 1].mn = tr[u].mx, tr[u << 1 | 1].mn2 = inf, tr[u << 1 | 1].cmn = tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1;
            }
            tr[u << 1 | 1].mx = tr[u].mx;
        }
        if(tr[u << 1].mn < tr[u].mn) {
            tr[u << 1].sum += (tr[u].mn - tr[u << 1].mn) * tr[u << 1].cmn;
            if(tr[u << 1].mx2 == tr[u << 1].mn) tr[u << 1].mx2 = tr[u].mn;
            if(tr[u << 1].mx == tr[u << 1].mn) {
                tr[u << 1].mx = tr[u].mn, tr[u << 1].mx2 = -inf, tr[u << 1].cmx = tr[u << 1].r - tr[u << 1].l + 1;
            }
            tr[u << 1].mn = tr[u].mn;
        }
        if(tr[u << 1 | 1].mn < tr[u].mn) {
            tr[u << 1 | 1].sum += (tr[u].mn - tr[u << 1 | 1].mn) * tr[u << 1 | 1].cmn;
            if(tr[u << 1 | 1].mx2 == tr[u << 1 | 1].mn) tr[u << 1 | 1].mx2 = tr[u].mn;
            if(tr[u << 1 | 1].mx == tr[u << 1 | 1].mn) {
                tr[u << 1 | 1].mx = tr[u].mn, tr[u << 1 | 1].mx2 = -inf, tr[u << 1 | 1].cmx = tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1;
            }
            tr[u << 1 | 1].mn = tr[u].mn;
        }
    }
    void build(int u, int l, int r) {
        if(l == r) {
            tr[u] = {l, r, a[l], a[l], -inf, 1, a[l], inf, 1, 0};
            return;
        }
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    // ai <- min(ai, c)
    void modify_mn(int u, int l, int r, int c) {
        if(c >= tr[u].mx) return;
        if(tr[u].l >= l && tr[u].r <= r && c > tr[u].mx2) {
            tr[u].sum -= (tr[u].mx - c) * tr[u].cmx;
            if(tr[u].mn2 == tr[u].mx) tr[u].mn2 = c;
            if(tr[u].mn == tr[u].mx) {
                tr[u].mn = c, tr[u].mn2 = inf, tr[u].cmn = tr[u].r - tr[u].l + 1;
            }
            tr[u].mx = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_mn(u << 1, l, r, c);
        if(r > mid) modify_mn(u << 1 | 1, l, r, c);
        pushup(u);
    }
    // ai <- max(ai, c)
    void modify_mx(int u, int l, int r, int c) {
        if(c <= tr[u].mn) return;
        if(tr[u].l >= l && tr[u].r <= r && c < tr[u].mn2) {
            tr[u].sum += (c - tr[u].mn) * tr[u].cmn;
            if(tr[u].mx2 == tr[u].mn) tr[u].mx2 = c;
            if(tr[u].mx == tr[u].mn) {
                tr[u].mx = c, tr[u].mx2 = -inf, tr[u].cmx = tr[u].r - tr[u].l + 1;
            }
            tr[u].mn = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_mx(u << 1, l, r, c);
        if(r > mid) modify_mx(u << 1 | 1, l, r, c);
        pushup(u);
    }
    // ai <- ai + c
    void modify_add(int u, int l, int r, int c) {
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].sum += (tr[u].r - tr[u].l + 1) * c;
            tr[u].lazy += c;
            tr[u].mx += c, tr[u].mx2 += c, tr[u].mn += c, tr[u].mn2 += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_add(u << 1, l, r, c);
        if(r > mid) modify_add(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query_sum(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res += query_sum(u << 1, l, r);
        if(r > mid) res += query_sum(u << 1 | 1, l, r);
        return res;
    }
    int query_mx(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].mx;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = -inf;
        if(l <= mid) res = max(res, query_mx(u << 1, l, r));
        if(r > mid) res = max(res, query_mx(u << 1 | 1, l, r));
        return res;
    }
    int query_mn(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].mn;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = inf;
        if(l <= mid) res = min(res, query_mn(u << 1, l, r));
        if(r > mid) res = min(res, query_mn(u << 1 | 1, l, r));
        return res;
    }
};

void solve()
{
    int n, m;
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    Segment_Tree_Beats Tr(n);
    cin >> m;
    while(m --) {
        int op;
        cin >> op;
        if(op == 1) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_add(1, l, r, c);
        } else if(op == 2) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_mx(1, l, r, c);
        } else if(op == 3) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_mn(1, l, r, c);
        } else if(op == 4) {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_sum(1, l, r) << '\n';
        } else if(op == 5) {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_mx(1, l, r) << '\n';
        } else {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_mn(1, l, r) << '\n';
        }
    }
}
```

<br>

---

### Picks loves segment tree

给出一个长度为 $n$ 的数列 $A$ . 接下来进行了 $m$ 次操作, 操作有三种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $min(A_i, x)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ ( $x$ 可能为负数)
3. 对于所有的 $i \in [l, r]$ , 询问 $A_i$ 的和

数据范围 $n, m \le 3 \times 10^5$ .

<br>

---

### AcrossTheSky loves segment tree

给出一个长度为 $n$ 的数列 $A$ . 接下来进行了 $m$ 次操作, 操作有三种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $min(A_i, x)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $max(A_i, x)$ 
3. 对于所有的 $i \in [l, r]$ , 询问 $A_i$ 的和

数据范围 $n, m \le 3 \times 10^5$ .

<br>

---

### Mzl loves segment tree

给出一个长度为 $n$ 的数列 $A$ , 定义一个数组 $B$ , 最开始数组 $B$ 的所有数都是 $0$ . 接下来进行了 $m$ 次操作, 操作有四种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $min(A_i, x)$ 
2. 对于所有的 $i \in [l, ]r $, 将 $A_i$ 变成 $max(A_i, x)$ 
3. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
4. 对于所有的 $i \in [l, r]$ , 询问 $B_i$ 的和

在每次操作之后, 对于每一个位置 $i$ , 如果 $A_i$ 的值发生了变化, 那么就给 $B_i$ 加上一, 否则 $B_i$ 不变

数据范围 $n, m \le 3 \times 10^5$ 

<br>

---

### ChiTuShaoNian loves segment tree

**题意** 

给出两个长度为 $n$ 的数列 $A$ 和 $B$ . 接下来进行了 $m$ 次操作, 操作有五种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $min(A_i, x)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $B_i$ 变成 $min(B_i, x)$ 
3. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
4. 对于所有的 $i \in [l, r]$ , 将 $B_i$ 加上 $x$ 
5. 对于所有的 $i \in [l, r]$ , 询问 $A_i + B_i$ 的最大值

数据范围: $n, m \le 3 \times 10^5$ 

**样例输入1** 

```
7 10
-11 -13 -12 -4 -8 18 16
17 9 -19 6 -17 -4 -9
2 1 7 1
4 4 7 -16
5 4 7
1 1 2 18
2 4 6 -7
5 5 7
2 4 7 -10
5 4 4
4 7 7 6
5 2 5
```

**样例输出1** 

```
-2
-2
-19
-12
```

**样例输入2** 

```
8 12
-9 18 10 -12 -14 7 16 -3
-5 18 -4 -15 2 -3 15 12
5 1 2
2 5 8 1
3 2 2 4
5 2 2
2 3 5 -5
5 1 6
4 5 8 15
5 3 7
3 7 7 -1
3 3 8 -14
1 3 3 -1
5 4 8
```

**样例输出2** 

```
36
40
40
32
17
```

<br>

我们将区间 $[l, r]$ 中的备选答案 $A_i + B_i$ 分成四类: $A_i$ , $B_i$ 均不是序列 $A$ , $B$ 区间最大值、$A_i$ 是序列 $A$ 区间最大值但是 $B_i$ 不是序列 $B$ 区间最大值、$A_i$ 不是序列 $A$ 区间最大值但是 $B_i$ 是序列 $B$ 区间最大值、$A_i$ , $B_i$ 均是序列 $A$ , $B$ 区间最大值. 我们不妨分别设为 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ . 此外我们正常维护序列 $A$ , $B$ 的区间最大值和次大值. 对 $A$ 的 $min$ 标记会影响到 $C_{1, 1}$ 和 $C_{1, 0}$ , 对 $B$ 的标记会影响到 $C_{1, 1}$ 和 $C_{0, 1}$ . 对 $A$ , $B$ 的加法则会对 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ 均产生影响. 只需要注意 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ 不存在的边界情况即可 (例如区间 $[i, i]$ 只有 $A$ , $B$ 的最大值与 $C_{1, 1}$ 存在). 

接下来需要考虑在 $pushup$ 时如何维护 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ . 可以考虑完成 $A$ , $B$ 最大值的更新之后, 讨论左右儿子的 $A$ , $B$ 最大值是否与当前节点 $A$ , $B$ 最大值相等, 对左儿子进行如下处理, 右儿子同理: 

> + 当左儿子的 $A$ , $B$ 最大值与当前节点的最大值均相等时, 左儿子的 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ 会分别对当前节点的 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ 产生贡献
> + 当左儿子的 $A$ 最大值与当前节点 $A$ 最大值相等, 但是 $B$ 最大值不相等时, 左儿子的 $C_{1, 0}$ , $C_{1, 1}$ 会对该节点的 $C_{1, 0}$ 产生贡献,$C_{0, 0}$ , $C_{0, 1}$ 会对该节点的 $C_{0, 0}$ 产生贡献
> + 当左儿子的 $A$ 的最大值与当前节点 $A$ 最大值不相等, 但是 $B$ 最大值相等时, 左儿子的 $C_{0, 1}$ , $C_{1, 1}$ 会对该节点的 $C_{0, 1}$ 产生贡献, $C_{0, 0}$ , $C_{1, 0}$ 会对该节点的 $C_{0, 0}$ 产生贡献
> + 当左儿子的 $A$ , $B$ 最大值与当前节点的 $A$ , $B$ 最大值均不相等时, 左儿子的 $C_{0, 0}$ , $C_{1, 0}$ , $C_{0, 1}$ , $C_{1, 1}$ 仅会对该节点的 $C_{0, 0}$ 产生贡献

区间查询结果的 $max(C_{0, 1}, C_{1, 0}, C_{0, 1}, C_{1, 1})$ 即为所求

<br>

```c++
const int N = 300010;
const int inf = 0x3f3f3f3f3f3f3f3f;
int a[N], b[N];

struct Segment_Tree_Beats {
    struct node {
        int l, r;
        // 0: a, 1: b
        int mx_ab[2][2], mx[2], mx2[2], lazy[2];
        int max_val() {
            return max(max(mx_ab[0][0], mx_ab[0][1]), max(mx_ab[1][0], mx_ab[1][1]));
        }
        void init(int a, int b) {
            mx[0] = a, mx[1] = b, mx2[0] = mx2[1] = -inf;
            mx_ab[0][0] = mx_ab[0][1] = mx_ab[1][0] = -inf, mx_ab[1][1] = a + b;
            lazy[0] = lazy[1] = 0;
        }
        void update(node &u) {
            if(u.mx[0] == mx[0] && u.mx[1] == mx[1]) {
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][0]);
                mx_ab[0][1] = max(mx_ab[0][1], u.mx_ab[0][1]);
                mx_ab[1][0] = max(mx_ab[1][0], u.mx_ab[1][0]);
                mx_ab[1][1] = max(mx_ab[1][1], u.mx_ab[1][1]);
            } else if(u.mx[0] == mx[0] && u.mx[1] != mx[1]) {
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][0]);
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][1]);
                mx_ab[1][0] = max(mx_ab[1][0], u.mx_ab[1][0]);
                mx_ab[1][0] = max(mx_ab[1][0], u.mx_ab[1][1]);
            } else if(u.mx[0] != mx[0] && u.mx[1] == mx[1]) {
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][0]);
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[1][0]);
                mx_ab[0][1] = max(mx_ab[0][1], u.mx_ab[0][1]);
                mx_ab[0][1] = max(mx_ab[0][1], u.mx_ab[1][1]);
            } else {
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][0]);
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[0][1]);
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[1][0]);
                mx_ab[0][0] = max(mx_ab[0][0], u.mx_ab[1][1]);
            }
        }
        void pushup(node L, node R) {
            for(int i = 0; i < 2; i++) {
                mx[i] = max(L.mx[i], R.mx[i]);
                if(L.mx[i] == R.mx[i])
                    mx2[i] = max(L.mx2[i], R.mx2[i]);
                else if(L.mx[i] > R.mx[i])
                    mx2[i] = max(L.mx2[i], R.mx[i]);
                else
                    mx2[i] = max(L.mx[i], R.mx2[i]);
            }
            update(L), update(R);
        }
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].init(-inf, -inf);
        tr[u].pushup(tr[u << 1], tr[u << 1 | 1]);
    }
    void pushdown(int u) {
        for(int i = 0; i < 2; i++)
            if(tr[u].lazy[i]) {
                tr[u << 1].mx_ab[0][0] += tr[u].lazy[i];
                tr[u << 1].mx_ab[0][1] += tr[u].lazy[i];
                tr[u << 1].mx_ab[1][0] += tr[u].lazy[i];
                tr[u << 1].mx_ab[1][1] += tr[u].lazy[i];
                tr[u << 1].mx[i] += tr[u].lazy[i];
                tr[u << 1].mx2[i] += tr[u].lazy[i];
                tr[u << 1].lazy[i] += tr[u].lazy[i];
                tr[u << 1 | 1].mx_ab[0][0] += tr[u].lazy[i];
                tr[u << 1 | 1].mx_ab[0][1] += tr[u].lazy[i];
                tr[u << 1 | 1].mx_ab[1][0] += tr[u].lazy[i];
                tr[u << 1 | 1].mx_ab[1][1] += tr[u].lazy[i];
                tr[u << 1 | 1].mx[i] += tr[u].lazy[i];
                tr[u << 1 | 1].mx2[i] += tr[u].lazy[i];
                tr[u << 1 | 1].lazy[i] += tr[u].lazy[i];
                tr[u].lazy[i] = 0;
            }
        for(int op = 0; op < 2; op++) {
            if(tr[u << 1].mx[op] > tr[u].mx[op]) {
                if(!op) {
                    tr[u << 1].mx_ab[1][0] -= (tr[u << 1].mx[op] - tr[u].mx[op]);
                    tr[u << 1].mx_ab[1][1] -= (tr[u << 1].mx[op] - tr[u].mx[op]);
                } else { 
                    tr[u << 1].mx_ab[0][1] -= (tr[u << 1].mx[op] - tr[u].mx[op]);
                    tr[u << 1].mx_ab[1][1] -= (tr[u << 1].mx[op] - tr[u].mx[op]);
                }
                tr[u << 1].mx[op] = tr[u].mx[op];
            }
            if(tr[u << 1 | 1].mx[op] > tr[u].mx[op]) {
                if(!op) {
                    tr[u << 1 | 1].mx_ab[1][0] -= (tr[u << 1 | 1].mx[op] - tr[u].mx[op]);
                    tr[u << 1 | 1].mx_ab[1][1] -= (tr[u << 1 | 1].mx[op] - tr[u].mx[op]);
                } else { 
                    tr[u << 1 | 1].mx_ab[0][1] -= (tr[u << 1 | 1].mx[op] - tr[u].mx[op]);
                    tr[u << 1 | 1].mx_ab[1][1] -= (tr[u << 1 | 1].mx[op] - tr[u].mx[op]);
                }
                tr[u << 1 | 1].mx[op] = tr[u].mx[op];
            }
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r};
        if(l == r) {
            tr[u].init(a[l], b[l]);
            return;
        }
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void modify_mn(int u, int l, int r, int c, int op) {
        if(c >= tr[u].mx[op]) return;
        if(tr[u].l >= l && tr[u].r <= r && c > tr[u].mx2[op]) {
            if(!op) {
                tr[u].mx_ab[1][0] -= (tr[u].mx[op] - c);
                tr[u].mx_ab[1][1] -= (tr[u].mx[op] - c);
            } else {
                tr[u].mx_ab[0][1] -= (tr[u].mx[op] - c);
                tr[u].mx_ab[1][1] -= (tr[u].mx[op] - c);
            }
            tr[u].mx[op] = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_mn(u << 1, l, r, c, op);
        if(r > mid) modify_mn(u << 1 | 1, l, r, c, op);
        pushup(u);
    }
    void modify_add(int u, int l, int r, int c, int op) {
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].mx[op] += c, tr[u].mx2[op] += c, tr[u].lazy[op] += c;
            tr[u].mx_ab[0][0] += c, tr[u].mx_ab[0][1] += c, tr[u].mx_ab[1][0] += c, tr[u].mx_ab[1][1] += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_add(u << 1, l, r, c, op);
        if(r > mid) modify_add(u << 1 | 1, l, r, c, op);
        pushup(u);
    }
    node query(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u];
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid && r > mid) {
            node res; res.init(-inf, -inf);
            res.pushup(query(u << 1, l, r), query(u << 1 | 1, l, r));
            return res;
        } else if(l <= mid) {
            return query(u << 1, l, r);
        }
        else {
            return query(u << 1 | 1, l, r);
        } 
    }
    void modify_mn_a(int u, int l, int r, int c) {
        modify_mn(u, l, r, c, 0);
    }
    void modify_mn_b(int u, int l, int r, int c) {
        modify_mn(u, l, r, c, 1);
    }
    void modify_add_a(int u, int l, int r, int c) {
        modify_add(u, l, r, c, 0);
    }
    void modify_add_b(int u, int l, int r, int c) {
        modify_add(u, l, r, c, 1);
    }
};

void solve()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    for(int i = 1; i <= n; i++)
        cin >> b[i];

    Segment_Tree_Beats Tr(n);
    while(m --) {
        int op;
        cin >> op;
        if(op == 1) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_mn_a(1, l, r, c);
        } else if(op == 2) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_mn_b(1, l, r, c);
        } else if(op == 3) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_add_a(1, l, r, c);
        } else if(op == 4) {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_add_b(1, l, r, c);
        } else {
            int l, r;
            cin >> l >> r;
            cout << Tr.query(1, l, r).max_val() << '\n';
        }
    }
}
```

<br>

---

### Dzy loves segment tree

给出一个长度为 $n$ 的数列 $A$ . 接下来进行了 $m$ 次操作, 操作有三种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $min(A_i, x)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
3. 询问 $gcd(A_l, A_{l + 1}, \cdots, A_{r - 1}, A_r)$ 

数据范围: $n, m \le 10^5$ 

<br>

---

### 第十三届重庆市赛 G - LCA & MST

**题意** 

给有根树和结点的权值数组 $w$ , 定义有根树上的生成图是完全图, 且 $(u, v)$ 边的权值是 $w_{LCA(u, v)}$ . 求这个图的最小生成树. 同时包含 $q$ 次操作, 每次操作选一个结点 $p$ 让它和它子树的所有结点的 $w_i \gets w_i + x$ . 每次操作完都要回答最小生成树的大小. 

**样例输入** 

```
7 4
1 2
1 3
2 4
2 5
4 6
4 7
7 6 5 4 3 2 1
5 4
4 3
1 5
2 2
```

**样例输出** 

```
34
34
38
68
72
```

<br>

容易发现, 除了根, 每个点连向自己祖先里 $w$ 最小的那个点得到的生成树大小是最小的. 令 $f(i)$ 表示从根走到 $i$ 这个点的路径上最小的 $w$ . 则答案为 $\sum_{i = 2}^{n} f(i)$ . 

现在加入修改, 假设现在要把 $p$ 的子树节点的 $w$ 加上 $x$ . 对于其中的一个结点 $u$ 来说, 若原先这个结点的祖先中 $w$ 最小的结点在这个结点到 $p$ 的路径上, 则新的 $f(u) = min\{f(p), f(u) + x \}$ ; 若原先的这个结点的祖先中 $w$ 最小的结点在 $p$ 到根的路径上, 则新的 $f(u) = f(p)$ 且此时一定有 $f(p)$ 要比 $u$ 到 $p$ 之间的 $w$ 还要小, 因此最终 $f(u) = min\{f(p), f(u) + x \}$ . 这个过程可以用 $Segment Tree Beats$ 完成. 

<br>

```c++
const int N = 200010;
const int inf = 0x3f3f3f3f3f3f3f3f;
int f[N];
vector<int> e[N];
int w[N], L[N], R[N], id[N], dfn;

struct Segment_Tree_Beats {
    struct node {
        int l, r;
        // 区间和, 最大值, 次大值, 最大值个数, 区间加懒标记
        int sum, mx, se, cnt, lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
        tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
        if(tr[u << 1].mx == tr[u << 1 | 1].mx) {
            tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
            tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].se);
        } else if(tr[u << 1].mx > tr[u << 1 | 1].mx) {
            tr[u].cnt = tr[u << 1].cnt;
            tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].mx);
        } else {
            tr[u].cnt = tr[u << 1 | 1].cnt;
            tr[u].se = max(tr[u << 1].mx, tr[u << 1 | 1].se);
        }
    }
    void pushdown(int u) { 
        if(tr[u].lazy) {
            tr[u << 1].sum += tr[u].lazy * (tr[u << 1].r - tr[u << 1].l + 1);
            tr[u << 1].mx += tr[u].lazy;
            tr[u << 1].se += tr[u].lazy;
            tr[u << 1].lazy += tr[u].lazy;
            tr[u << 1 | 1].sum += tr[u].lazy * (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1);
            tr[u << 1 | 1].mx += tr[u].lazy;
            tr[u << 1 | 1].se += tr[u].lazy;
            tr[u << 1 | 1].lazy += tr[u].lazy;
            tr[u].lazy = 0;
        }
        if(tr[u << 1].mx > tr[u].mx) {
            tr[u << 1].sum -= (tr[u << 1].mx - tr[u].mx) * tr[u << 1].cnt;
            tr[u << 1].mx = tr[u].mx;
        }
        if(tr[u << 1 | 1].mx > tr[u].mx) {
            tr[u << 1 | 1].sum -= (tr[u << 1 | 1].mx - tr[u].mx) * tr[u << 1 | 1].cnt;
            tr[u << 1 | 1].mx = tr[u].mx;
        }
    }
    void build(int u, int l, int r) {
        if(l == r) {
            tr[u] = {l, r, f[id[l]], f[id[l]], -inf, 1, 0};
            return;
        }
        tr[u] = {l, r, -inf, -inf, -inf - 1, 1, 0};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void modify(int u, int l, int r, int c) {
        if(c >= tr[u].mx) return;
        if(tr[u].l >= l && tr[u].r <= r && c > tr[u].se) {
            tr[u].sum -= (tr[u].mx - c) * tr[u].cnt;
            tr[u].mx = c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    void add(int u, int l, int r, int c) {
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].sum += c * (tr[u].r - tr[u].l + 1);
            tr[u].mx += c;
            tr[u].se += c;
            tr[u].lazy += c;
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) add(u << 1, l, r, c);
        if(r > mid) add(u << 1 | 1, l, r, c);
        pushup(u);
    }
    int query(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = 0;
        if(l <= mid) res += query(u << 1, l, r);
        if(r > mid) res += query(u << 1 | 1, l, r);
        return res;
    }
};

void dfs(int u, int fa) {
    L[u] = ++ dfn, id[dfn] = u;
    for(auto v: e[u])
        if(v != fa) {
            f[v] = min(f[u], w[u]);
            dfs(v, u);
        }
    R[u] = dfn;
}

void solve()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        f[i] = inf;
        e[i].clear();
    }
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for(int i = 1; i <= n; i++)
        cin >> w[i];

    dfn = 0;
    dfs(1, -1);

    Segment_Tree_Beats Tr(n);
    cout << Tr.query(1, 2, n) << '\n';
    while(m --) {
        int p, c;
        cin >> p >> c;
        int val = Tr.query(1, L[p], L[p]);
        Tr.add(1, L[p], R[p], c);
        Tr.modify(1, L[p], R[p], val);
        cout << Tr.query(1, 2, n) << '\n';
    }
}
```

**<font color='red'>需要注意的是: </font> 朴素的吉司机线段树中, 修改操作看似没有处理 `c <= tr[u].se`  的情况, 但一直递归到叶子节点, 因为叶子节点自身是没有次大值的, 叶子节点一定会出现 `c > tr[u].se` 的情况**
**当涉及区间 `+` 操作时, 叶子节点的次大值会被操作,  因此初始化时需要把叶子节点的次大值初始化为 `-inf` (而不是 `-1` )**

<br>

---

# 历史最值问题

### CPU监控

**题意** 

给出一个长度为 $n$ 的数列 $A$ , 同时定义一个辅助数组 $B$ , $B$ 开始与 $A$ 完全相同. 接下来进行了 $m$ 次操作, 操作有四种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $x$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
3. 对于所有的 $i \in [l, r]$ , 询问 $A_i$ 的最大值
4. 对于所有的 $i \in [l, r]$ , 询问 $B_i$ 的最大值

在每一次操作后, 我们都进行一次更新, 让 $B_i = max(B_i, A_i)$ 

数据范围: $n, m \le 10^5$ 

**样例输入** 

```
10
-62 -83 -9 -70 79 -78 -31 40 -18 -5 
20
A 2 7
A 4 4
Q 4 4
P 2 2 -74
P 7 9 -71
P 7 10 -8
A 10 10
A 5 9
C 1 8 10
Q 6 6
Q 8 10
A 1 7
P 9 9 96
A 5 5
P 8 10 -53
P 6 6 5
A 10 10
A 4 4
Q 1 5
P 4 9 -69
```

**样例输出** 

```
79
-70
-70
-5
79
10
10
79
79
-5
10
10
```

<br>

考虑用传统的懒标记来解决, 首先如果只是询问区间最大值, 只需要使用区间加减这一个懒标记(用 $Add$ 表示)就能解决. 

现在考虑询问区间历史最大值的最大值. 我们定义一种新的懒标记: 历史最大的加减标记(用 $Pre$ 表示). 这个标记的定义是: 从上一次把这个节点的标记下传的时刻到当前时刻这一时间段中, 这个节点中的 $Add$ 标记值达过的最大值. 

现在考虑把第 $i$ 个节点的标记下传到它的儿子 $l$ , 不难发现标记是可以合并的: $Pre_l = max(Pre_l, Add_l + Pre_i)$ , $Add_l = Add_l = Add_i$ . 至于区间历史最大值信息的更新也与标记的合并类似, 只需要将当前的区间最大值加上 $Pre_i$ 然后与原来的历史最大值进行比较即可. 

现在回到原题, 我们观察在修改操作过程中, 被影响到的节点的变化: 如果一个节点没有发生标记下传, 那么最开始它一直被区间加减操作所影响, 这时我们可以用上面描述的 $Pre$ 标记来记录, 直到某一时刻, 这个节点被区间覆盖标记影响了, 那么这时这个节点中的所有数都变得相同, 再之后的所有区间加减修改, 对这个节点来说, 与区间覆盖操作并没有不同. 

因此每一个节点受到的标记可以分成两个部分: 第一个部分是区间加减, 第二个部分是区间覆盖. 因此我们可以用 $(x, y)$ 来表示历史最值标记, 它的定义是当前区间在第一阶段时最大的加减标记是 $x$ , 在第二个阶段时最大的覆盖标记是 $y$ . 显然这个标记是可以进行合并与更新的. 

到此我们就使用最传统的懒标记方法解决了这个问题, 时间复杂度 $O(m \log n)$ . 

<br>

```c++
const int N = 100010;
const int inf = 0x3f3f3f3f3f3f3f3f;
int a[N];

struct Segment_Tree_Beats {
    struct node {
        int l, r;
        // 当前最大值, 历史最大值;
        // 区间加懒标记, 懒标记最大值, 区间覆盖懒标记, 懒标记最大值
        int mx, mmx, add, max_add, fill, max_fill;
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
        tr[u].mmx = max(tr[u << 1].mmx, tr[u << 1 | 1].mmx);
    }
    void pushdown(int u) {
        if(tr[u].max_add > -inf / 2) {
            tr[u << 1].mmx = max(tr[u << 1].mmx, tr[u << 1].mx + tr[u].max_add);
            if(tr[u << 1].max_fill > -inf / 2) {
                tr[u << 1].max_fill = max(tr[u << 1].max_fill, tr[u << 1].mx + tr[u].max_add);
                tr[u << 1].mx += tr[u].add;
                tr[u << 1].fill = tr[u << 1].mx;
            } else {
                tr[u << 1].mx += tr[u].add;
                tr[u << 1].max_add = max(tr[u << 1].max_add, tr[u << 1].add + tr[u].max_add);
                tr[u << 1].add += tr[u].add;
            }
            tr[u << 1 | 1].mmx = max(tr[u << 1 | 1].mmx, tr[u << 1 | 1].mx + tr[u].max_add);
            if(tr[u << 1 | 1].max_fill > -inf / 2) {
                tr[u << 1 | 1].max_fill = max(tr[u << 1 | 1].max_fill, tr[u << 1 | 1].mx + tr[u].max_add);
                tr[u << 1 | 1].mx += tr[u].add;
                tr[u << 1 | 1].fill = tr[u << 1 | 1].mx;
            } else {
                tr[u << 1 | 1].mx += tr[u].add;
                tr[u << 1 | 1].max_add = max(tr[u << 1 | 1].max_add, tr[u << 1 | 1].add + tr[u].max_add);
                tr[u << 1 | 1].add += tr[u].add;
            }
            tr[u].add = 0, tr[u].max_add = -inf;
        }
        if(tr[u].max_fill > -inf / 2) {
            tr[u << 1].mmx = max(tr[u << 1].mmx, tr[u].max_fill);
            tr[u << 1].mx = tr[u].fill;
            tr[u << 1].fill = tr[u].fill;
            tr[u << 1].max_fill = max(tr[u << 1].max_fill, tr[u].max_fill);
            tr[u << 1 | 1].mmx = max(tr[u << 1 | 1].mmx, tr[u].max_fill);
            tr[u << 1 | 1].mx = tr[u].fill;
            tr[u << 1 | 1].fill = tr[u].fill;
            tr[u << 1 | 1].max_fill = max(tr[u << 1 | 1].max_fill, tr[u].max_fill);
            tr[u].fill = -inf, tr[u].max_fill = -inf;
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r, -inf, -inf, 0, -inf, -inf, -inf};
        if(l == r) {
            tr[u].mx = tr[u].mmx = a[l];
            return;
        }
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    // 区间覆盖
    void modify_fill(int u, int l, int r, int c) {
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].mx = c, tr[u].mmx = max(tr[u].mmx, tr[u].mx);
            tr[u].fill = c, tr[u].max_fill = max(tr[u].max_fill, tr[u].fill);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_fill(u << 1, l, r, c);
        if(r > mid) modify_fill(u << 1 | 1, l, r, c);
        pushup(u);
    }
    // 区间加
    void modify_add(int u, int l, int r, int c) {
        if(tr[u].l >= l && tr[u].r <= r) {
            if(tr[u].max_fill > -inf / 2) { // 有区间覆盖, 将区间加转换成区间覆盖
                modify_fill(u, l, r, tr[u].mx + c);
                return;
            }
            tr[u].mx += c, tr[u].mmx = max(tr[u].mmx, tr[u].mx);
            tr[u].add += c, tr[u].max_add = max(tr[u].max_add, tr[u].add);  
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify_add(u << 1, l, r, c);
        if(r > mid) modify_add(u << 1 | 1, l, r, c);
        pushup(u);
    }
    // 当前最值
    int query_mx(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].mx;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = -inf;
        if(l <= mid) res = max(res, query_mx(u << 1, l, r));
        if(r > mid) res = max(res, query_mx(u << 1 | 1, l, r));
        return res;
    }
    // 历史最值
    int query_mmx(int u, int l, int r) {
        if(tr[u].l >= l && tr[u].r <= r)
            return tr[u].mmx;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1, res = -inf;
        if(l <= mid) res = max(res, query_mmx(u << 1, l, r));
        if(r > mid) res = max(res, query_mmx(u << 1 | 1, l, r));
        return res;
    }
};

void solve()
{
    int n, m;
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    Segment_Tree_Beats Tr(n);
    cin >> m;
    while(m --) {
        char op;
        cin >> op;
        if(op == 'Q') {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_mx(1, l, r) << '\n';
        } else if(op == 'A') {
            int l, r;
            cin >> l >> r;
            cout << Tr.query_mmx(1, l, r) << '\n';
        } else if(op == 'P') {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_add(1, l, r, c);
        } else {
            int l, r, c;
            cin >> l >> r >> c;
            Tr.modify_fill(1, l, r, c);
        }
    }
}
```

**<font color='red'>需要注意的是: </font> 在 $pushdown$ 区间加的懒标记下传时, 也需要先判断后继节点是否进行过区间覆盖操作** 

<br>

---

### V

**题意** 

给出一个长度为 $n$ 的数列 $A$ , 同时定义一个辅助数组 $B$ , $B$ 开始与 $A$ 完全相同. 接下来进行了 $m$ 次操作, 操作有五种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $max(A_i - x, 0)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
3. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $x$ 
4. 给出一个 $i$ , 询问 $A_i$ 的值
5. 给出一个 $i$ , 询问 $B_i$ 的值

在每一次操作后, 我们都进行一次更新, 让 $B_i = max(B_i, A_i)$ 

数据范围: $n, m \le 5 \times 10^5$ 

**样例输入** 

```
5 6
1 2 3 4 5
2 1 3 2
4 1
1 1 4 1
5 3
3 1 5 4
4 2
```

**样例输出** 

```
0
3
4
```

<br>

首先我们定义一种标记 $(a, b)$ , 表示给这个区间中的所有数先加上 $a$ , 然后再对 $b$ 取 $max$ . 不难发现题目中涉及的三种操作都可以用这一个标记来表示, 分别为 $(-x, 0)$ , $(x, -inf)$ , $(-inf, x)$ . 

考虑合并两个标记 $(a, b)$ 与 $(c, d)$ , 那么显然得到的就是 $(a + c, max(b + c, d))$ . 因此对于询问 $4$ , 我们只需要把询问的叶子节点到根路径上的所有标记都下传到叶子节点, 就能直接求得答案了. 

现在考虑历史最大标记. 我们可以把标记给看成一个函数, 每一个数字对应的函数值表示这个数在作用了这个标记后的答案, 在这个问题中, 标记 $(a, b)$ 就相当于一个分段函数, 第一段是一条与 $x$ 轴平行的直线, 第二段是一条斜率为 $1$ 的直线. 

在更新历史最大标记的时候, 我们相当于把两个标记的图象同时放到一个坐标系中, 然后取出上方的那一段. 下图展示的是标记合并时可能出现的一种情况, 蓝色的部分是原来的两个标记, 红色部分是更新后得到的标记. 

<img src="E:\个人博客\博客内容\算法竞赛\最后一年，开个新文件夹吧\吉司机线段树1.png" alt="吉司机线段树1" style="zoom:33%;" />

因为在更新标记之后形式和原来相同, 所以这个历史最值标记是可以维护的. 因此对于询问 $5$ , 我们也只需要把所有相关的标记给下传下去, 就能得到答案了. 时间复杂度 $O(m \log n)$ . 

<br>

```c++
// MLE 了 n = 500000 的四个点
#include <bits/stdc++.h>
#define int long long
using namespace std;

typedef pair<int,int> pii;
const int inf = 0x3f3f3f3f3f3f3f3f;

struct Segment_Tree_Beats {
    const pii none = {0, -inf}, low = {-inf, -inf};
    pii merge(pii a, pii b) {
        return make_pair(max(a.first + b.first, -inf), max(a.second + b.first, b.second));
    }
    pii max_pii(pii a, pii b) {
        if(a.second < b.second) swap(a, b);
        int x1 = a.second - a.first, y1 = a.second;
        int x2 = b.second - b.first, y2 = b.second;
        int x3 = min(x1, x2 + y1 - y2), y3 = y1;
        return make_pair(y3 - x3, y3);
        // return make_pair(max(a.first, b.first), max(a.second, b.second));
    }
    struct node {
        int l, r;
        // 当前标记, 历史最大标记, 懒标记, 最大懒标记
        pii now, mx, lazy, mx_lazy;
    };
    vector<node> tr;
    void pushup(int u) {
        tr[u].now = max_pii(tr[u << 1].now, tr[u << 1 | 1].now);
        tr[u].mx = max_pii(tr[u << 1].mx, tr[u << 1 | 1].mx);
    }
    void pushdown(int u) {
        if(tr[u].mx_lazy != low) {
            tr[u << 1].mx = max_pii(tr[u << 1].mx, merge(tr[u << 1].now, tr[u].mx_lazy));
            tr[u << 1].now = merge(tr[u << 1].now, tr[u].lazy);
            tr[u << 1].mx_lazy = max_pii(tr[u << 1].mx_lazy, merge(tr[u << 1].lazy, tr[u].mx_lazy));
            tr[u << 1].lazy = merge(tr[u << 1].lazy, tr[u].lazy);
            tr[u << 1 | 1].mx = max_pii(tr[u << 1 | 1].mx, merge(tr[u << 1 | 1].now, tr[u].mx_lazy));
            tr[u << 1 | 1].now = merge(tr[u << 1 | 1].now, tr[u].lazy);
            tr[u << 1 | 1].mx_lazy = max_pii(tr[u << 1 | 1].mx_lazy, merge(tr[u << 1 | 1].lazy, tr[u].mx_lazy));
            tr[u << 1 | 1].lazy = merge(tr[u << 1 | 1].lazy, tr[u].lazy);
            tr[u].lazy = none, tr[u].mx_lazy = low;
        }
    }
    void build(int u, int l, int r) {
        tr[u] = {l, r, none, none, none, low};
        if(l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    }
    Segment_Tree_Beats(int n) {
        tr.resize((n + 10) * 4);
        build(1, 1, n);
    }
    void modify(int u, int l, int r, pii c) {
        if(tr[u].l >= l && tr[u].r <= r) {
            tr[u].now = merge(tr[u].now, c);
            tr[u].lazy = merge(tr[u].lazy, c);
            tr[u].mx_lazy = max_pii(tr[u].mx_lazy, tr[u].lazy);
            tr[u].mx = max_pii(tr[u].mx, tr[u].now);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c);
        if(r > mid) modify(u << 1 | 1, l, r, c);
        pushup(u);
    }
    pii query_now(int u, int x) {
        if(tr[u].l == tr[u].r) 
            return tr[u].now;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) return query_now(u << 1, x);
        else return query_now(u << 1 | 1, x);
    }
    pii query_mx(int u, int x) {
        if(tr[u].l == tr[u].r) 
            return tr[u].mx;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) return query_mx(u << 1, x);
        else return query_mx(u << 1 | 1, x);
    }
};

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++)
        cin >> a[i];

    Segment_Tree_Beats Tr(n);
    while(m --) {
        int op;
        cin >> op;
        if(op == 1) {
            int l, r, x;
            cin >> l >> r >> x;
            Tr.modify(1, l, r, make_pair(x, -inf));
        } else if(op == 2) {
            int l, r, x;
            cin >> l >> r >> x;
            Tr.modify(1, l, r, make_pair(-x, 0));
        } else if(op == 3) {
            int l, r, x;
            cin >> l >> r >> x;
            Tr.modify(1, l, r, make_pair(-inf, x));
        } else if(op == 4) {
            int x;
            cin >> x;
            pii t = Tr.query_now(1, x);
            cout << max(a[x] + t.first, t.second) << '\n';
        } else {
            int x;
            cin >> x;
            pii t = Tr.query_mx(1, x);
            cout << max(a[x] + t.first, t.second) << '\n';
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int T = 1;
    // cin >> T;
    while(T --)
        solve();

    return 0;
}
```

<br>

---

### Rikka with Sequences 

给出一个长度为 $n$ 的数列 $A$ , 同时定义一个 $n \times n$ 的辅助数组 $B$ , 最开始 $B_{i, j} = \sum_{k = i}^{j}A_k$ . 接下来进行了 $m$ 次操作, 操作有两种类型: 

1. 给出两个整数 $l$ 和 $x$ , 把 $A_l$ 的值变成 $x$ 
2. 给出两个整数 $l$ 和 $r$ , 保证 $l < r$ , 表示询问 $B_{l, r}$ 的值

在每次操作之后, 我们都会进行一次更新: $B_{i, j} = min(B_{i, j}, \sum_{k = i}^{j}A_k)$ 

数据范围: $n , m \le 10^5$ 

<br>

---

### 元旦老人与数列

**题意** 

给出一个长度为 $n$ 的数列 $A$ , 同时定义一个辅助数组 $B$ , $B$ 开始与 $A$ 完全相同. 接下来进行了 $m$ 次操作, 操作有四种类型: 

1. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 变成 $max(A_i, x)$ 
2. 对于所有的 $i \in [l, r]$ , 将 $A_i$ 加上 $x$ 
3. 对于所有的 $i \in [l, r]$ , 询问 $A_i$ 的最小值
4. 对于所有的 $i \in [l, r]$ , 询问 $B_i$ 的最小值

在每一次操作后, 我们都进行一次更新, 让 $B_i = min(B_i, A_i)$ 

数据范围: $n, m \le 3 \times 10^5$ 

**样例输入** 

```
3 6
1 2 3
4 3 3
1 2 3 -2
3 1 3
4 3 3
2 2 3 4
3 1 3
```

**样例输出** 

```
3
0
1
1
```

